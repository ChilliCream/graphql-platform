{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/distributed-schema/schema-federations","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/distributed-schema/schema-federations/"},"frontmatter":{"title":"Schema Federations"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Schema Federations\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In schema federations, the extension points of the gateway schema are defined on the downstream services.\\nTherefore you need to configure federations in two places: the gateway schema and the downstream service.\"), mdx(\"p\", null, \"The schemas can either be pushed to a Redis cache and then pulled from the gateway or directly be pulled by the gateway from the downstream service.\"), mdx(\"h1\", null, \"Federation with Redis\"), mdx(\"p\", null, \"HotChocolate uses the Redis cache as a pub/sub system to signal changes on the downstream services.\\nWith a cache, the gateway schema is also more stable and faster in bootstrapping, because it does not require to call all downstream services on startup.\"), mdx(\"p\", null, \"You will need to add a package reference to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Stitching.Redis\"), \" to all your services:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"dotnet add package HotChocolate.Stitching.Redis\\n\")), mdx(\"h2\", null, \"Configuration of a domain service\"), mdx(\"p\", null, \"A domain service has to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"publish the schema definition\"), \".\\nThe schema is published on the initialization of the schema.\\nBy default, a schema is lazy and only initialized when the first request is sent.\\nYou can also initialize the schema on startup with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IntitializeOnStartup\"), \".\\nEvery schema requires a unique name. This name is used in several places to reference the schema.\\nBy calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PublishSchemaDefinition\"), \" you can configure how the schema should be published.\"), mdx(\"p\", null, \"Schemas are published to Redis under a configuration name. The gateway is subscribed to this configuration.\\nAll schemas that are registered under this name, will be discovered by the gateway\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void ConfigureServices(IServiceCollection services)\\n{\\n    services\\n        // This is the connection multiplexer that redis will use\\n        .AddSingleton(ConnectionMultiplexer.Connect(\\\"stitching-redis.services.local\\\"))\\n        .AddGraphQLServer()\\n        .AddQueryType<Query>()\\n        // We initialize the schema on startup so it is published to the redis as soon as possible\\n        .InitializeOnStartup()\\n        // We configure the publish definition\\n        .PublishSchemaDefinition(c => c\\n            // The name of the schema. This name should be unique\\n            .SetName(\\\"accounts\\\")\\n            .PublishToRedis(\\n                // The configuration name under which the schema should be published\\n                \\\"Demo\\\", \\n                // The connection multiplexer that should be used for publishing\\n                sp => sp.GetRequiredService<ConnectionMultiplexer>()));\\n}\\n\")), mdx(\"h2\", null, \"Configuration of the gateway\"), mdx(\"p\", null, \"The gateway needs HttpClients to fetch the data from the domain services.\\nYou have to register them on the service collection.\\nThe name of the HttpClient has to be the same as the name of the schema it refers to.\\nAs you may use the schema names in several places, it is good practise to store them as constant.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public static class WellKnownSchemaNames \\n{\\n    public const string Accounts = \\\"accounts\\\";\\n    public const string Inventory = \\\"inventory\\\";\\n    public const string Products = \\\"products\\\";\\n    public const string Reviews = \\\"reviews\\\";\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddHttpClient(Accounts, c => c.BaseAddress = new Uri(\\\"http://accounts.service.local/graphql\\\"));\\nservices.AddHttpClient(Inventory, c => c.BaseAddress = new Uri(\\\"http://inventory.service.local/graphql\\\"));\\nservices.AddHttpClient(Products, c => c.BaseAddress = new Uri(\\\"http://products.service.local/graphql\\\"));\\nservices.AddHttpClient(Reviews, c => c.BaseAddress = new Uri(\\\"http://reviews.service.local/graphql\\\"));\\n\")), mdx(\"p\", null, \"The gateway is subscribed to the Redis cache.\\nAs soon as the domain service has published its schema, the gateway grab the changes and update its own schema.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services\\n    // This is the connection multiplexer that redis will use\\n    .AddSingleton(ConnectionMultiplexer.Connect(\\\"stitching-redis.services.local\\\"))\\n    .AddGraphQLServer()\\n    .AddRemoteSchemasFromRedis(\\\"Demo\\\", sp => sp.GetRequiredService<ConnectionMultiplexer>());\\n\")), mdx(\"h2\", null, \"Example\"), mdx(\"p\", null, \"You can find a full schema federation example here \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/hotchocolate-examples/tree/master/misc/Stitching/federated-with-hot-reload\"\n  }), \"Federated Schema with Redis\")), mdx(\"h1\", null, \"Federation with schema polling\"), mdx(\"p\", null, \"You can also use federations without a Redis cache. In this case, you cannot hot reload the schema.\\nThe configuration is very much the same as in Redis except the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PublishToRedis\"), \" part.\\nYour schema will expose an additional field. This field is used by the Gateway to fetch the schema definition.\"), mdx(\"p\", null, \"You will need to add a package reference to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Stitching.Redis\"), \" to all your services:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cli\"\n  }), \"dotnet add package HotChocolate.Stitching\\n\")), mdx(\"h2\", null, \"Configuration of a domain service\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void ConfigureServices(IServiceCollection services)\\n{\\n\\n    services\\n      .AddGraphQLServer()\\n      .AddQueryType<Query>()\\n      // We initialize the schema on startup so it is published to the redis as soon as possible\\n      .InitializeOnStartup()\\n      // We configure the publish definition\\n      .PublishSchemaDefinition(c => c\\n          // The name of the schema. This name should be unique\\n          .SetName(\\\"accounts\\\"));\\n}\\n\")), mdx(\"h2\", null, \"Configuration of the gateway\"), mdx(\"p\", null, \"With the polling approach, we need to make the schema aware of the domain services.\\nWe can just add the schema with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddRemoteSchema\"), \". \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public static class WellKnownSchemaNames \\n{\\n    public const string Accounts = \\\"accounts\\\";\\n    public const string Inventory = \\\"inventory\\\";\\n    public const string Products = \\\"products\\\";\\n    public const string Reviews = \\\"reviews\\\";\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void ConfigureServices(IServiceCollection services)\\n{\\n    // register the http clients th\\n    services.AddHttpClient(Accounts, c => c.BaseAddress = new Uri(\\\"http://accounts.service.local/graphql\\\"));\\n    services.AddHttpClient(Inventory, c => c.BaseAddress = new Uri(\\\"http://inventory.service.local/graphql\\\"));\\n    services.AddHttpClient(Products, c => c.BaseAddress = new Uri(\\\"http://products.service.local/graphql\\\"));\\n    services.AddHttpClient(Reviews, c => c.BaseAddress = new Uri(\\\"http://reviews.service.local/graphql\\\"));\\n\\n    services\\n        .AddGraphQLServer()\\n        // add the remote schemas\\n        .AddRemoteSchema(Accounts)\\n        .AddRemoteSchema(Inventory)\\n        .AddRemoteSchema(Products)\\n        .AddRemoteSchema(Reviews);\\n\")), mdx(\"h2\", null, \"Example\"), mdx(\"p\", null, \"You can find a full schema federation with polling example here \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/hotchocolate-examples/tree/master/misc/Stitching/federated-with-pull\"\n  }), \"Federated Schema with polling\")), mdx(\"h1\", null, \"Configuration\"), mdx(\"p\", null, \"By default, all the fields that are declared on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Mutation\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" are exposed on the gateway.\\nIn case the schema you do not want to expose the root fields and prefer to define the extension points in an extension file, you can also ignore the root types for a schema on the domain service.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void ConfigureServices(IServiceCollection services)\\n{\\n    services\\n        // This is the connection multiplexer that redis will use\\n        .AddSingleton(ConnectionMultiplexer.Connect(\\\"stitching-redis.services.local\\\"))\\n        .AddGraphQLServer()\\n        .AddQueryType<Query>()\\n        .PublishSchemaDefinition(c => c\\n            .SetName(\\\"accounts\\\")\\n            // Ignore the root types of accounts\\n            .IgnoreRootTypes()\\n            // Declares where the type extension is used\\n            .AddTypeExtensionsFromFile(\\\"./Stitching.graphql\\\")\\n            .PublishToRedis(\\n                // The configuration name under which the schema should be published\\n                \\\"Demo\\\", \\n                // The connection multiplexer that should be used for publishing\\n                sp => sp.GetRequiredService<ConnectionMultiplexer>()));\\n}\\n\")), mdx(\"p\", null, \"In case you choose to ignore the root types, make sure to add a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Mutation\"), \" type to the gateway.\\nIf there are no root types registered on the gateway the schema will be invalid.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services\\n    // This is the connection multiplexer that redis will use\\n    .AddSingleton(ConnectionMultiplexer.Connect(\\\"stitching-redis.services.local\\\"))\\n    .AddGraphQLServer()\\n    .AddQueryType(d => d.Name(\\\"Query\\\"))\\n    .AddRemoteSchemasFromRedis(\\\"Demo\\\", sp => sp.GetRequiredService<ConnectionMultiplexer>());\\n\")), mdx(\"p\", null, \"For further configuration with extension files, have a look at \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/hotchocolate/distributed-schema/schema-configuration\"\n  }), \"Schema Configuration\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#federation-with-redis","title":"Federation with Redis","items":[{"url":"#configuration-of-a-domain-service","title":"Configuration of a domain service"},{"url":"#configuration-of-the-gateway","title":"Configuration of the gateway"},{"url":"#example","title":"Example"}]},{"url":"#federation-with-schema-polling","title":"Federation with schema polling","items":[{"url":"#configuration-of-a-domain-service-1","title":"Configuration of a domain service"},{"url":"#configuration-of-the-gateway-1","title":"Configuration of the gateway"},{"url":"#example-1","title":"Example"}]},{"url":"#configuration","title":"Configuration"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11.1 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"descriptions","title":"Schema Documentation"},{"path":"operations","title":"Operations"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"extending-types","title":"Extending types"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"distributed-schema","title":"Distributed Schemas","items":[{"path":"index","title":"Overview"},{"path":"schema-stitching","title":"Schema Stitching"},{"path":"schema-federations","title":"Schema Federations"},{"path":"schema-configuration","title":"Schema Configuration"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/distributed-schema/schema-federations.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}