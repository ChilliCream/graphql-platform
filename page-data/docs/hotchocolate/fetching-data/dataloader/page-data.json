{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/fetching-data/dataloader","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/fetching-data/dataloader/"},"frontmatter":{"title":"DataLoader"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"DataLoader\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If you want to read more about data loaders in general, you can head over to Facebook's \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/facebook/dataloader\"\n  }), \"GitHub repository\"), \".\")), mdx(\"p\", null, \"Every data fetching technology suffers the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"n+1\"), \" problem.\\nThe difference between GraphQL and e.g. REST is, that the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"n+1\"), \" problem occurs on the server, rather than on the client.\\nThe clear benefit is, that we only have to deal with this problem once on the server, rather than on every client. \"), mdx(\"p\", null, \"To depict the issue that data loaders solve in this context, let assume we have this schema:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  person(id: ID): Person\\n}\\n\\ntype Person {\\n  id: ID\\n  name: String\\n  friends: [Person]\\n}\\n\")), mdx(\"p\", null, \"The above schema allows to fetch a person by its internal identifier and each person has a list of friends that is represented by a list of persons.\"), mdx(\"p\", null, \"A query against the above schema could look like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  a: person(id: \\\"a\\\") {\\n    name\\n  }\\n\\n  b: person(id: \\\"b\\\") {\\n    name\\n  }\\n}\\n\")), mdx(\"p\", null, \"The above request fetches two persons in one go without the need to call the backend twice. The problem with the GraphQL backend is that field resolvers are atomic and do not have any knowledge about the query as a whole. So, a field resolver does not know that it will be called multiple times in parallel to fetch similar or equal data from the same data source.\"), mdx(\"p\", null, \"The idea of a dataloader is to batch these two requests into one call to the database.\"), mdx(\"p\", null, \"Let's look at some code to understand what data loaders are doing. First, let's have a look at how we would write our field resolver without data loaders:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public async Task<Person> GetPerson(string id, [Service]IPersonRepository repository)\\n{\\n    return await repository.GetPersonById(id);\\n}\\n\")), mdx(\"p\", null, \"The above example would result in two calls to the person repository that would then fetch the persons one by one from our data source.\"), mdx(\"p\", null, \"If you think that through you see that each GraphQL request would cause multiple requests to our data source resulting in sluggish performance and unnecessary round-trips to our data source.\"), mdx(\"p\", null, \"This means that we reduced the round-trips from our client to our server with GraphQL but still have the round-trips between the data sources and the service layer.\"), mdx(\"p\", null, \"With data loaders we can now centralise the data fetching and reduce the number of round trips to our data source.\"), mdx(\"p\", null, \"Instead of fetching the data from the repository directly, we fetch the data from the data loader.\\nThe data loader batches all the requests together into one request to the database.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"// This is one way of implementing a data loader. You will find the different ways of declaring\\n// data loaders further down the page.\\npublic class PersonBatchDataLoader : BatchDataLoader<string, Person>\\n{\\n    private readonly IPersonRepository _repository;\\n\\n    public PersonBatchDataLoader(\\n        IPersonRepository repository,\\n        IBatchScheduler batchScheduler,\\n        DataLoaderOptions<string>? options = null)\\n        : base(batchScheduler, options)\\n    {\\n        _repository = repository;\\n    }\\n\\n    protected override async Task<IReadOnlyDictionary<string, Person>> LoadBatchAsync(\\n        IReadOnlyList<string> keys,\\n        CancellationToken cancellationToken)\\n    {\\n        // instead of fetching one person, we fetch multiple persons\\n        var persons =  await _repository.GetPersonByIds(keys);\\n        return persons.ToDictionary(x => x.Id);\\n    }\\n}\\n\\n\\npublic class Query \\n{\\n    public async Task<Person> GetPerson(\\n        string id, \\n        PersonBatchDataLoader dataLoader)\\n        => await dataLoader.LoadAsync(id);\\n}\\n\")), mdx(\"h1\", null, \"Execution\"), mdx(\"p\", null, \"With a data loader, you can fetch entities with a key.\\nThese are the two generics you have in the class data loaders:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class BatchDataLoader<TId, TEntity>\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TId\"), \" is used as an identifier of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TEntity\"), \". \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TId\"), \" is the type of the values you put into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LoadAsync\"), \".\"), mdx(\"p\", null, \"The execution engine of HotChocolate tries to batch as much as possible.\\nIt executes resolvers until the queue is empty and then triggers the data loader to resolve the data for the waiting resolvers. \"), mdx(\"h1\", null, \"Data Consistency\"), mdx(\"p\", null, \"Dataloader do not only batch calls to the database, they also cache the database response.\\nA data loader guarantees data consistency in a single request.\\nIf you load an entity with a data loader in your request more than once, it is given that these two entities are equivalent. \"), mdx(\"p\", null, \"Data loaders do not fetch an entity if there is already an entity with the requested key in the cache. \"), mdx(\"h1\", null, \"Types of Data loaders\"), mdx(\"p\", null, \"In HotChocolate you can declare data loaders in two different ways.\\nYou can separate the data loading concern into separate classes or you can use a delegate in the resolver to define data loaders on the fly.\\nBelow you will find the different types of data loaders with examples for class and delegate definition. \"), mdx(\"h2\", null, \"Batch DataLoader\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"One - To - One, usually used for fields like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"personById\"), \" or one to one relations\")), mdx(\"p\", null, \"The batch data loader collects requests for entities and send them as a batch request to the data source. Moreover, the data loader caches the retrieved entries within a request.\"), mdx(\"p\", null, \"The batch data loader gets the keys as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IReadOnlyList<TKey>\"), \" and returns an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IReadOnlyDictionary<TKey, TValue>\"), \".\"), mdx(\"h3\", null, \"Class\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class PersonBatchDataLoader : BatchDataLoader<string, Person>\\n{\\n    private readonly IPersonRepository _repository;\\n\\n    public PersonBatchDataLoader(\\n        IPersonRepository repository,\\n        IBatchScheduler batchScheduler,\\n        DataLoaderOptions<string>? options = null)\\n        : base(batchScheduler, options)\\n    {\\n        _repository = repository;\\n    }\\n\\n    protected override async Task<IReadOnlyDictionary<string, Person>> LoadBatchAsync(\\n        IReadOnlyList<string> keys,\\n        CancellationToken cancellationToken)\\n    {\\n        // instead of fetching one person, we fetch multiple persons\\n        var persons =  await _repository.GetPersonByIds(keys);\\n        return persons.ToDictionary(x => x.Id);\\n    }\\n}\\n\\n\\npublic class Query \\n{\\n    public async Task<Person> GetPerson(\\n        string id, \\n        PersonBatchDataLoader dataLoader)\\n        => await dataLoader.LoadAsync(id);\\n}\\n\")), mdx(\"h3\", null, \"Delegate\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Task<Person> GetPerson(\\n    string id,\\n    IResolverContext context,\\n    [Service] IPersonRepository repository)\\n{\\n    return context.BatchDataLoader<string, Person>(\\n            async (keys, ct) =>\\n            {\\n                var result = await repository.GetPersonByIds(keys);\\n                return result.ToDictionary(x => x.Id);\\n            })\\n        .LoadAsync(id);\\n}\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"An example with the \", mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"Batch Dataloader\"), \" can be found \", mdx(\"a\", _extends({\n    parentName: \"em\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/graphql-workshop/blob/master/code/complete/GraphQL/DataLoader/TrackByIdDataLoader.cs\"\n  }), \"here\"), \".\")), mdx(\"h2\", null, \"Group DataLoader\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"One - To - Many, usually used for fields like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"personsByLastName\"), \" or one to many relations \")), mdx(\"p\", null, \"The group data loader is also a batch data loader but instead of returning one entity per key, it returns multiple entities per key. As with the batch data loader retrieved collections are cached within a request.\"), mdx(\"p\", null, \"The group data loader gets the keys as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IReadOnlyList<TKey>\"), \" and returns an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ILookup<TKey, TValue>\"), \".\"), mdx(\"h3\", null, \"Class\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class PersonsByLastNameDataloader\\n    : GroupedDataLoader<string, Person>\\n{\\n    private readonly IPersonRepository _repository;\\n\\n    public PersonsByLastNameDataloader(\\n        IPersonRepository repository,\\n        IBatchScheduler batchScheduler,\\n        DataLoaderOptions<string>? options = null)\\n        : base(batchScheduler, options)\\n    {\\n        _repository = repository;\\n    }\\n\\n\\n    protected override async Task<ILookup<string, Person>> LoadGroupedBatchAsync(\\n        IReadOnlyList<string> names,\\n        CancellationToken cancellationToken)\\n    {\\n        var persons = await _repository.GetPersonsByLastName(names);\\n        return persons.ToLookup(x => x.LastName);\\n    }\\n}\\n\\npublic class Query \\n{\\n    public async Task<Person> GetPersonByLastName(\\n        string lastName, \\n        PersonsByLastNameDataloader dataLoader)\\n        => await dataLoader.LoadAsync(lastName);\\n}\\n\")), mdx(\"h3\", null, \"Delegate\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Task<IEnumerable<Person>> GetPersonByLastName(\\n   string lastName, \\n   IResolverContext context, \\n   [Service]IPersonRepository repository)\\n{\\n    return context.GroupDataLoader<string, Person>(\\n            async (keys, ct) =>\\n            {\\n                var result = await repository.GetPersonsByLastName(keys);\\n                return result.ToLookup(t => t.LastName);\\n            })\\n        .LoadAsync(lastName);\\n}\\n\")), mdx(\"h2\", null, \"Cache DataLoader\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"No batching, just caching. This data loader is used rarely. You most likely want to use the batch data loader.\")), mdx(\"p\", null, \"The cache data loader is the easiest to implement since there is no batching involved. You can just use the initial \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GetPersonById\"), \" method. We do not get the benefits of batching with this one, but if in a query graph the same entity is resolved twice we will load it only once from the data source.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Task<Person> GetPerson(string id, IResolverContext context, [Service]IPersonRepository repository)\\n{\\n    return context.CacheDataLoader<string, Person>(\\\"personById\\\", keys => repository.GetPersonById(keys)).LoadAsync(id);\\n}\\n\")), mdx(\"h1\", null, \"Stacked DataLoader Calls\"), mdx(\"p\", null, \"This is more like an edge case that is supported than a certain type of data loader. Sometimes we have more complex resolvers that might first fetch data from one data loader and use that to fetch data from the next. \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Task<IEnumerable<Customer>> GetCustomers(\\n    string personId, \\n    PersonByIdDataLoader personByIdDataLoader, \\n    CustomerByIdsDataLoader customerByIdsDataloader)\\n{\\n    Person person = await personByIdDataLoader.LoadAsync(id);\\n    return await customerByIdsDataloader.LoadAsync(person.CustomerIds);\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#execution","title":"Execution"},{"url":"#data-consistency","title":"Data Consistency"},{"url":"#types-of-data-loaders","title":"Types of Data loaders","items":[{"url":"#batch-dataloader","title":"Batch DataLoader"},{"url":"#group-dataloader","title":"Group DataLoader"},{"url":"#cache-dataloader","title":"Cache DataLoader"}]},{"url":"#stacked-dataloader-calls","title":"Stacked DataLoader Calls"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11.1 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"descriptions","title":"Schema Documentation"},{"path":"operations","title":"Operations"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"extending-types","title":"Extending types"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"distributed-schema","title":"Distributed Schemas","items":[{"path":"index","title":"Overview"},{"path":"schema-stitching","title":"Schema Stitching"},{"path":"schema-federations","title":"Schema Federations"},{"path":"schema-configuration","title":"Schema Configuration"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"},{"path":"mongodb","title":"MongoDB"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"dependency-injection","title":"Dependency Injection"},{"path":"executable","title":"Executable"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/fetching-data/dataloader.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}