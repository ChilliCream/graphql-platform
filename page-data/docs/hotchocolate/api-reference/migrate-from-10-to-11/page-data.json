{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/api-reference/migrate-from-10-to-11","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/api-reference/migrate-from-10-to-11/"},"frontmatter":{"title":"Migrate from Hot Chocolate GraphQL server 10 to 11"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Migrate from Hot Chocolate GraphQL server 10 to 11\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This guide will walk you through the manual migration steps to get you Hot Chocolate GraphQL server to version 11.\"), mdx(\"p\", null, \"As a general preparation, we recommend removing all HotChocolate.\", \"*\", \" package references from your project. Then start by adding the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.AspNetCore\"), \" package. The server package now contains most of the needed packages.\"), mdx(\"p\", null, \"When do I need to add other Hot Chocolate packages explicitly?\"), mdx(\"p\", null, \"We have now added the most common packages to the Hot Chocolate core. But there are certain areas where we still need to add some additional packages.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Package\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Topic\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"HotChocolate.AspNetCore.Authorization\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The authorization package adds the authorization directive and integrates with Microsoft Authorization Policies\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"HotChocolate.Data\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The new data package represents our integration with all kinds of data sources. This package provides the fundamentals for filtering, sorting, and projection logic.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"HotChocolate.Types.Spatial\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"This package provides GeoJson spatial types.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"HotChocolate.Data.Spatial\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The package integrates the spatial types with the data package to allow for spatial filtering, sorting, and projections.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"HotChocolate.Subscriptions.Redis\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The in-memory subscription provider, is now integrated by default. To have an integration with Redis, you need to add this package.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"HotChocolate.PersistedQueries.FileSystem\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"This package provides a persisted query storage for the file system.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"HotChocolate.PersistedQueries.Redis\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"This package provides a persisted query storage for Redis.\")))), mdx(\"h1\", null, \"ASP.NET Core\"), mdx(\"p\", null, \"One of the main focuses of version 11 was to create a new configuration API that brings all our builders together into one unified API. This also means that we had to introduce breaking changes to the way we\\nconfigure schemas.\"), mdx(\"p\", null, \"After you have cleaned up your packages, head over to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Startup.cs\"), \" to start with the new configuration API migration.\"), mdx(\"h2\", null, \"ConfigureServices\"), mdx(\"p\", null, \"In your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Startup.cs\"), \" head over to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConfigureServices\"), \" methods.\\nThe configuration of a schema has slightly changed, and the new configuration API has replaced the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SchemaBuilder\"), \".\"), mdx(\"p\", null, \"We now start with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddGraphQLServer\"), \" to define a new GraphQL server, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddGraphQLServer\"), \", returns the new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IRequestExecutorBuilder\"), \" that lets us apply all the configuration methods that used to be on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SchemaBuilder\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StitchingBuilder\"), \" and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"QueryExecutionBuilder\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddGraphQL(sp  =>\\n    SchemaBuilder.New()\\n        .AddServices(sp)\\n        .AddQueryType<QueryType>()\\n        .AddMutationType<MutationType>()\\n        ...\\n        .Create());\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services\\n    .AddGraphQLServer()\\n    .AddQueryType<QueryType>()\\n    .AddMutationType<MutationType>()\\n    ...\\n\")), mdx(\"p\", null, \"If you were using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"QueryRequestBuilder\"), \" to configure request options or change the request pipeline, you need to add those things to the configuration chain of the ``\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IRequestExecutorBuilder\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services\\n    .AddGraphQLServer()\\n    .AddQueryType<QueryType>()\\n    .AddMutationType<MutationType>()\\n    ...\\n    .ModifyRequestOptions(o => o.ExecutionTimeout = TimeSpan.FromSeconds(180));\\n\")), mdx(\"h2\", null, \"Configure\"), mdx(\"p\", null, \"After migrating the schema configuration, the next area that has fundamentally changed is the schema middleware.\"), mdx(\"p\", null, \"Hot Chocolate server now embraces the new endpoint routing API from ASP.NET core and with that brings a lot of new features. Head over \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"aspnetcore\"\n  }), \"here\"), \" to read more about the ASP.NET Core integration.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"app.UseGraphQL();\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"app.UseRouting();\\n\\n// routing area\\n\\napp.UseEndpoints(x => x.MapGraphQL());\\n\")), mdx(\"h2\", null, \"Request Interceptor\"), mdx(\"p\", null, \"The query request interceptor was reworked and we renamed it to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IHttpRequestInterceptor\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public interface IHttpRequestInterceptor\\n{\\n    ValueTask OnCreateAsync(\\n        HttpContext context,\\n        IRequestExecutor requestExecutor,\\n        IQueryRequestBuilder requestBuilder,\\n        CancellationToken cancellationToken);\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddQueryRequestInterceptor(\\n    (context, builder, ct) =>\\n    {\\n        // your code\\n    });\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddGraphQLServer()\\n    ...\\n    .AddHttpRequestInterceptor(\\n    (context, executor, builder, ct) =>\\n    {\\n        // your code\\n    });\\n\")), mdx(\"p\", null, \"You can also extend \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DefaultHttpRequestInterceptor\"), \" and inject it like the following.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddGraphQLServer()\\n    ...\\n    .AddHttpRequestInterceptor<MyCustomExecutor>();\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"A request interceptor is a service that is used by all hosted schemas.\")), mdx(\"h2\", null, \"Entity Framework Serial Execution\"), mdx(\"p\", null, \"The serial execution for Entity Framework compatibility is gone. If you use Entity Framework Core we recommend using version 5 and the new context factory in combination with context pooling. This allows the execution engine to execute in parallel and still be memory efficient since context objects are pooled.\"), mdx(\"p\", null, \"Another variant here is to use our scoped service feature that scopes services for the resolver pipeline. This is explained in our GraphQL Workshop project.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/graphql-workshop\"\n  }), \"https://github.com/ChilliCream/graphql-workshop\")), mdx(\"h1\", null, \"Schema / Resolvers\"), mdx(\"h3\", null, \"Field ordering\"), mdx(\"p\", null, \"Hot Chocolate 11 follows the spec and returns the fields in the order they were defined. This feature\\nmakes migrations harder because the schema snapshot looks different compared to version 11. You can change this behavior with the following setting.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    builder.ModifyOptions(x => x.SortFieldsByName = true)\\n\")), mdx(\"h2\", null, \"DataLoaders\"), mdx(\"p\", null, \"With Hot Chocolate server 11, we have embraced the new DataLoader spec version 2. With that, we have decoupled the scheduler from the DataLoader itself, meaning you now have to pass on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IBatchScheduler\"), \" to the base implementation of the DataLoader.\\nApart from that, DataLoader now uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ValueTask\"), \" instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Task\"), \" when doing async work.\"), mdx(\"p\", null, \"If you were adding the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DataLoaderRegistry\"), \" to the services, remove that code since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"service.AddDataLoaderRegistry\"), \" is no longer needed.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class FooDataLoader : DataLoaderBase<Guid, Foo>\\n{\\n    private readonly IFooRepository _fooRepository;\\n\\n    public FooDataLoader(IFooRepository fooRepository)\\n    {\\n        _fooRepository = fooRepository;\\n    }\\n\\n\\n    protected override async Task<IReadOnlyList<Result<Foo>>> FetchAsync(\\n        IReadOnlyList<Guid> keys,\\n        CancellationToken cancellationToken)\\n    {\\n        ....\\n    }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class FooDataLoader : DataLoaderBase<Guid, Foo>\\n{\\n    private readonly IFooRepository _fooRepository;\\n\\n    public FooDataLoader(\\n        //    \\u25BC\\n        IBatchScheduler scheduler,\\n        IFooRepository fooRepository)\\n        : base(scheduler)\\n    {\\n        _fooRepository = fooRepository;\\n    }\\n\\n\\n    //                          \\u25BC\\n    protected override async ValueTask<IReadOnlyList<Result<Foo>>> FetchAsync(\\n        IReadOnlyList<Guid> keys,\\n        CancellationToken cancellationToken)\\n    {\\n\\n    ....\\n}\\n\")), mdx(\"h2\", null, \"Node Resolver\"), mdx(\"p\", null, \"With version 11, we have reworked how Relay node types are defined. Furthermore, we added pure code-first (annotation-based) support.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor\\n    .AsNode()\\n    .IdField(d => d.Id)\\n    .NodeResolver(async (ctx, id) => await ctx\\n        .DataLoader<FooDataLoader>()\\n        .LoadAsync(id, ctx.RequestAborted))\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"p\", null, \"The following example essentially aligns very closely to the old variant.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor\\n    .ImplementsNode()\\n    .IdField(d => d.Id)\\n    .ResolveNode(async (ctx, id) => await ctx\\n        .DataLoader<FooDataLoader>()\\n        .LoadAsync(id, ctx.RequestAborted))\\n\")), mdx(\"p\", null, \"But, we can now also use an external resolver like with standard resolvers. This allows us to write better testable code that takes advantage of the method parameter injection we use in everyday resolvers.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor\\n    .ImplementsNode()\\n    .IdField(d => d.Id)\\n    .ResolveNodeWith<NodeResolver>(t => t.GetNodeAsync(default, default));\\n\")), mdx(\"p\", null, \"But we can go even further now with pure code-first (annotation-based) support. By just annotating the entity with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NodeAttribute\"), \", we essentially told the schema builder that this is a node. The type initialization can then try to infer the node resolver directly from the type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[Node]\\npublic class MyEntity\\n{\\n    public string Id { get; set; }\\n\\n    public async Task<MyEntity> GetAsync(....)\\n    {\\n        ....\\n    }\\n}\\n\")), mdx(\"p\", null, \"Often, however, we want the repository logic decoupled from our domain object/entity. In this case, we can specify the entity resolver type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[Node(NodeResolverType = typeof(MyEntityResolver))]\\npublic class MyEntity\\n{\\n    public string Id { get; set; }\\n}\\n\\npublic class MyEntityResolver\\n{\\n    public async Task<MyEntity> GetAsync(....)\\n    {\\n        ....\\n    }\\n}\\n\")), mdx(\"p\", null, \"There are more variants possible, but to give an impression of the new convenience and flexibility around nodes. As a side note, if you do not want the node attribute on the domain objects, you can also now add your very own attribute or interface to mark this and rewrite that in the schema building process to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NodeAttribute\"), \".\"), mdx(\"h2\", null, \"Pagination\"), mdx(\"p\", null, \"The first thing to note around pagination is that we listened to a lot of feedback and have removed the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PaginationAmountType\"), \".\"), mdx(\"p\", null, \"Moreover, we have introduced new PagingOptions, which can be set with the new configuration API on the schema level. With the new options, you can configure the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MaxPageSize\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DefaultPageSize\"), \" and whether the total count shall be included \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IncludeTotalCount\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"builder.SetPagingOptions(\\n    new PagingOptions()\\n    {\\n        MaxPageSize = searchOptions.PaginationAmount,\\n        DefaultPageSize = searchOptions.PaginationAmount,\\n        IncludeTotalCount = true\\n    });\\n\")), mdx(\"p\", null, \"Further, you can override the paging option on the resolver level.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[UsePaging(MaxPageSize = 100)]\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor.Field(...).UsePaging(maxPageSize = 100)...\\n\")), mdx(\"h2\", null, \"Projections\"), mdx(\"p\", null, \"The selection middleware, that was available in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Types.Selections\"), \" was replaced by the projection middleware from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Data\"), \". \"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor.Field(...).UseSelection()...\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor.Field(...).UseProjection()...\\n\")), mdx(\"p\", null, \"Similarly, the attribute \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[UseSelection]\"), \" was replaced by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[UseProjection]\"), \". \"), mdx(\"p\", null, \"To use projections with your GraphQL endpoint you have to register it on the schema:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddGraphQLServer()\\n  // Your schmea configuration\\n  .AddProjections();\\n\")), mdx(\"h2\", null, \"Enum Type\"), mdx(\"p\", null, \"HotChocolate server 11 now follows the spec recommendation with the new enum name conventions and formats the enum values by default as UPPER_SNAIL_CASE.\"), mdx(\"p\", null, \"To avoid breaking changes to your schema, you will have to override the naming convention:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Configuration:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    builder\\n        .AddConvention<INamingConventions>(new CompatibilityNamingConvention())\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Convention:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    public class CompatibilityNamingConvention\\n        : DefaultNamingConventions\\n    {\\n        public override NameString GetEnumValueName(object value)\\n        {\\n            if (value == null)\\n            {\\n                throw new ArgumentNullException(nameof(value));\\n            }\\n\\n            return value.ToString().ToUpperInvariant();\\n        }\\n    }\\n\")), mdx(\"h2\", null, \"IResolverContext.Source\"), mdx(\"p\", null, \"The source result stack was removed from the resolver context for performance reasons. If you need such a functionality, you can write a middleware that aggregates the resulting path on the scoped context.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    public class FooType : ObjectType<Foo>\\n    {\\n        private static readonly object _empty = new object();\\n\\n        protected override void Configure(IObjectTypeDescriptor<Foo> descriptor)\\n        {\\n            descriptor\\n                .Field(\\\"bar\\\")\\n                .Type<NonNullType<BarType>>()\\n                .Resolver(_empty);\\n        }\\n    }\\n\\n    public class BarType : ObjectType\\n    {\\n        protected override void Configure(IObjectTypeDescriptor descriptor)\\n        {\\n            descriptor\\n                .Field(\\\"baz\\\")\\n                .Type<DateTimeType>()\\n                .Resolve(ctx =>\\n                    {\\n                        Foo foo = (Foo)ctx.Source.Pop().Peek();\\n                        return foo.Baz;\\n                    });\\n        }\\n    }\\n\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    public class FooType : ObjectType<Foo>\\n    {\\n        protected override void Configure(IObjectTypeDescriptor<Foo> descriptor)\\n        {\\n            descriptor\\n                .Field(\\\"bar\\\")\\n                .Type<NonNullType<BarType>>()\\n                .Resolve(\\n                    ctx =>\\n                    {\\n                        ctx.ScopedContextData =\\n                            ctx.ScopedContextData.SetItem(nameof(Foo), ctx.Parent<Foo>());\\n                        return new object();\\n                    });\\n        }\\n    }\\n\\n    public class BarType : ObjectType\\n    {\\n        protected override void Configure(IObjectTypeDescriptor descriptor)\\n        {\\n            descriptor\\n                .Field(\\\"baz\\\")\\n                .Type<DateTimeType>()\\n                .Resolve(\\n                    ctx =>\\n                    {\\n                        if (ctx.ScopedContextData.TryGetValue(nameof(Foo), out object? potentialFoo) &&\\n                            potentialFoo is Foo foo)\\n                        {\\n                            return foo.Baz;\\n                        }\\n\\n                        throw new GraphQLException(\\n                            ErrorBuilder.New()\\n                                .AddLocation(ctx.Field.SyntaxNode)\\n                                .SetMessage(\\\"Foo was not pushed down.\\\")\\n                                .SetPath(ctx.Path)\\n                                .Build());\\n                    });\\n        }\\n    }\\n\")), mdx(\"h2\", null, \"Authorization\"), mdx(\"p\", null, \"If you use authorization, you need to add a package reference to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.AspNetCore.Authorization\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    builder.AddAuthorizeDirectiveType()\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    builder.AddAuthorization()\\n\")), mdx(\"h2\", null, \"TypeBinding\"), mdx(\"p\", null, \"We have renamed the binding method from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BindClrType\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BindRuntimeType\"), \" to make it more clear what it does.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    builder.BindClrType<DateTime, DateTimeType>()\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    builder.BindRuntimeType<DateTime, DateTimeType>()\\n\")), mdx(\"h2\", null, \"FieldMiddleware\"), mdx(\"p\", null, \"Since all configuration APIs were integrated into one, we needed to make it more specific for what a middleware is defined. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseField\"), \" defines a middleware that is applied to the resolver pipeline / field pipeline whereas \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseRequest\"), \" defines a middleware that is defined for the request processing.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    builder.Use<CustomMiddleware>()\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    builder.UseField<CustomMiddleware>()\\n\")), mdx(\"h1\", null, \"Stitching\"), mdx(\"p\", null, \"The schema stitching configuration API has been completely integrated into the new configuration API. This means that a Gateway is nothing more than a GraphQL schema, which will make it easier for new users. However, you will need to completely rewire your stitching configuration.\"), mdx(\"h2\", null, \"Configuration\"), mdx(\"p\", null, \"The stitching builder no longer exists in version 11 and you need to use the new configuration API to configure your gateway.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    services.AddStitchedSchema(x => ....);\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    services.AddGraphQLServer()....\\n\")), mdx(\"h3\", null, \"AddSchemaFromHttp\"), mdx(\"p\", null, \"Registering a remote schema has slightly changed in version 11 to make it more clear that we are adding a remote schema into the local gateway schema. Removing, root types and importing a remote schema can be done in one go now.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    builder.AddSchemaFromHttp(\\\"SomeSchema\\\").IgnoreRootTypes(\\\"SomeSchema\\\");\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    builder.AddRemoteSchema(\\\"SomeSchema\\\", ignoreRootTypes: true);\\n\")), mdx(\"h2\", null, \"AddSchemaConfiguration\"), mdx(\"p\", null, \"In version 11 it is now much easier to configure the gateway schema.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    services.AddStitchedSchema(x => x.AddSchemaConfiguration(y => y.RegisterType<FooType>()));\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    services\\n        .AddGraphQLServer()\\n        .AddType<FooType>();\\n\")), mdx(\"h2\", null, \"IgnoreField\"), mdx(\"p\", null, \"The order of the parameters in ignore field and ignore type has changed since we moved optional parameters to the end.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    services.AddStitchedSchema(x => x.IgnoreField(\\\"SchemaName\\\", \\\"TypeName, \\\"FieldName\\\"));\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    services\\n        .AddGraphQLServer()\\n        .IgnoreField(\\\"TypeName, \\\"FieldName\\\", \\\"SchemaName\\\")\\n\")), mdx(\"h2\", null, \"SetExecutionOptions\"), mdx(\"p\", null, \"Execution options can now be configured on the root schema directly like for any other schema:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    services.AddStitchedSchema(\\n        x => x.SetExecutionOptions(\\n            new QueryExecutionOptions\\n                {\\n                    TracingPreference = TracingPreference.OnDemand\\n                }));\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    services\\n        .AddGraphQLServer()\\n        .ModifyRequestOptions(x => x.TracingPreference = TracingPreference.OnDemand);\\n\")), mdx(\"h2\", null, \"Configuring a downstream schema\"), mdx(\"p\", null, \"In case you want to configure a downstream schema, you can now just use the new configuration API since all downstream schemas have an in-memory representation.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    services\\n        .AddGraphQLServer()\\n        .AddRemoteSchema(\\\"SomeSchema\\\");\\n\\n    services\\n        .AddGraphQL(\\\"SomeSchema\\\")\\n        .AddType(new IntType(\\\"SpecialIntegerType\\\"));\\n\")), mdx(\"h2\", null, \"PaginationAmount\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PaginationAmount\"), \" scalar was removed since it caused a lot of issues with clients and only provided limited benefit. The arguments \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"first\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"last\"), \" use now \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Int\"), \" as a type. To avoid breaking schemas on a stitched schema, you can add a rewriter that rewrites all\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"first: Int\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"last: Int\"), \" on a connection to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"first: PaginationAmount\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"last: PaginationAmount\"), \".\\nYou also have to make sure that you register a new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IntType\"), \" on the root schema and rewrite all\\ndownstream schemas.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Configuration:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    services\\n        .AddGraphQLServer()\\n        .AddRemoteSchema(\\\"SomeSchema\\\")\\n        .AddType(new IntType())\\n        .AddType(new IntType(\\\"PaginationAmount\\\"))\\n        .AddMergedDocumentRewriter(\\n            d => (DocumentNode)new PagingAmountRewriter().Rewrite(d, null));\\n\\n    services\\n        .AddGraphQL(\\\"SomeSchema\\\")\\n        .AddType(new IntType())\\n        .AddType(new IntType(\\\"PaginationAmount\\\"));\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"PagingAmountRewriter:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    internal class PagingAmountRewriter : SchemaSyntaxRewriter<object?>\\n    {\\n        protected override FieldDefinitionNode RewriteFieldDefinition(\\n            FieldDefinitionNode node,\\n            object? context)\\n        {\\n            if (node.Type.NamedType().Name.Value.EndsWith(\\\"Connection\\\") &&\\n                (node.Arguments.Any(\\n                    t => t.Name.Value.EqualsOrdinal(\\\"first\\\") &&\\n                        t.Type.NamedType().Name.Value.EqualsOrdinal(\\\"Int\\\"))\\n                || node.Arguments.Any(\\n                    t => t.Name.Value.EqualsOrdinal(\\\"last\\\") &&\\n                        t.Type.NamedType().Name.Value.EqualsOrdinal(\\\"Int\\\"))\\n                ))\\n            {\\n                var arguments = node.Arguments.ToList();\\n\\n                InputValueDefinitionNode first =\\n                    arguments.FirstOrDefault(t => t.Name.Value.EqualsOrdinal(\\\"first\\\"));\\n\\n                InputValueDefinitionNode last =\\n                    arguments.FirstOrDefault(t => t.Name.Value.EqualsOrdinal(\\\"last\\\"));\\n\\n                if (first != null) arguments[arguments.IndexOf(first)] = first.WithType(RewriteType(first.Type, \\\"PaginationAmount\\\"));\\n\\n                if (last != null) arguments[arguments.IndexOf(last)] = last.WithType(RewriteType(last.Type, \\\"PaginationAmount\\\"));\\n\\n                node = node.WithArguments(arguments);\\n            }\\n\\n            return base.RewriteFieldDefinition(node, context);\\n        }\\n\\n        private static ITypeNode RewriteType(ITypeNode type, NameString name)\\n        {\\n            if (type is NonNullTypeNode nonNullType)\\n            {\\n                return new NonNullTypeNode(\\n                    (INullableTypeNode)RewriteType(nonNullType.Type, name));\\n            }\\n\\n            if (type is ListTypeNode listType)\\n            {\\n                return new ListTypeNode(RewriteType(listType.Type, name));\\n            }\\n\\n            return new NamedTypeNode(name);\\n        }\\n    }\\n\\n    internal static class StringExtensions\\n    {\\n        public static bool EqualsOrdinal(this string value, string other) =>\\n            string.Equals(value, other, StringComparison.Ordinal);\\n    }\\n\")), mdx(\"h2\", null, \"Batch responses\"), mdx(\"p\", null, \"In v10, responses to batched operations were returned as a JsonArray. In v11 the default is to return MultiPartChunked responses. To switch back to JsonArray, configure the HttpResult serializer as follows:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddHttpResultSerializer(\\n    batchSerialization: HttpResultSerialization.JsonArray\\n);\\n\")), mdx(\"h1\", null, \"Testing\"), mdx(\"p\", null, \"We have added a couple of test helpers to make the transition to the new configuration API easier.\"), mdx(\"h2\", null, \"Schema Snapshot Tests\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    SchemaBuilder.New()\\n        .AddQueryType<Query>()\\n        .Create()\\n        .ToString()\\n        .MatchSnapshot();\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    ISchema schema =\\n        await new ServiceCollection()\\n            .AddGraphQL()\\n            .AddQueryType<Query>()\\n            .BuildSchemaAsync();\\n\\n    schema.Print().MatchSnapshot();\\n\")), mdx(\"h2\", null, \"Request Tests\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    IQueryExecutor executor =\\n        SchemaBuilder.New()\\n            .AddQueryType<Query>()\\n            .Create()\\n            .MakeExecutable();\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"New:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    IRequestExecutor executor =\\n        await new ServiceCollection()\\n            .AddGraphQL()\\n            .AddQueryType<Query>()\\n            .BuildRequestExecutorAsync();\\n\\n    IExecutionResult result =\\n        await executor.ExecuteAsync(\\\"{ __typename }\\\");\\n\\n    result.ToJson().MatchSnapshot();\\n\")), mdx(\"p\", null, \"Or you can directly build and execute:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    IExecutionResult result =\\n        await new ServiceCollection()\\n            .AddGraphQL()\\n            .AddQueryType<Query>()\\n            .ExecuteRequestAsync(\\\"{ __typename }\\\");\\n\\n    result.ToJson().MatchSnapshot();\\n\")), mdx(\"h2\", null, \"DataLoader Testing\"), mdx(\"p\", null, \"Due to the changed constructor you now need to also create a scheduler for the dataloaders\"), mdx(\"p\", null, \"Old\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    FooDataLoader dataLoader = new FooDataLoader( fooRepoMock.Object);\\n\")), mdx(\"p\", null, \"New\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    var scheduler = new BatchScheduler();\\n    FooDataLoader dataLoader = new FooDataLoader(\\n        scheduler,\\n        fooRepoMock.Object);\\n\")), mdx(\"p\", null, \"// TODO : Type Converter\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#aspnet-core","title":"ASP.NET Core","items":[{"url":"#configureservices","title":"ConfigureServices"},{"url":"#configure","title":"Configure"},{"url":"#request-interceptor","title":"Request Interceptor"},{"url":"#entity-framework-serial-execution","title":"Entity Framework Serial Execution"}]},{"url":"#schema--resolvers","title":"Schema / Resolvers","items":[{"url":"#dataloaders","title":"DataLoaders"},{"url":"#node-resolver","title":"Node Resolver"},{"url":"#pagination","title":"Pagination"},{"url":"#projections","title":"Projections"},{"url":"#enum-type","title":"Enum Type"},{"url":"#iresolvercontextsource","title":"IResolverContext.Source"},{"url":"#authorization","title":"Authorization"},{"url":"#typebinding","title":"TypeBinding"},{"url":"#fieldmiddleware","title":"FieldMiddleware"}]},{"url":"#stitching","title":"Stitching","items":[{"url":"#configuration","title":"Configuration"},{"url":"#addschemaconfiguration","title":"AddSchemaConfiguration"},{"url":"#ignorefield","title":"IgnoreField"},{"url":"#setexecutionoptions","title":"SetExecutionOptions"},{"url":"#configuring-a-downstream-schema","title":"Configuring a downstream schema"},{"url":"#paginationamount","title":"PaginationAmount"},{"url":"#batch-responses","title":"Batch responses"}]},{"url":"#testing","title":"Testing","items":[{"url":"#schema-snapshot-tests","title":"Schema Snapshot Tests"},{"url":"#request-tests","title":"Request Tests"},{"url":"#dataloader-testing","title":"DataLoader Testing"}]}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11.1 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"descriptions","title":"Schema Documentation"},{"path":"operations","title":"Operations"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"extending-types","title":"Extending types"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"distributed-schema","title":"Distributed Schemas","items":[{"path":"index","title":"Overview"},{"path":"schema-stitching","title":"Schema Stitching"},{"path":"schema-federations","title":"Schema Federations"},{"path":"schema-configuration","title":"Schema Configuration"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"},{"path":"mongodb","title":"MongoDB"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"dependency-injection","title":"Dependency Injection"},{"path":"executable","title":"Executable"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/api-reference/migrate-from-10-to-11.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}