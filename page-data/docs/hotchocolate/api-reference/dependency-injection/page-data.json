{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/api-reference/dependency-injection","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/api-reference/dependency-injection/"},"frontmatter":{"title":"Dependency Injection"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dependency Injection\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Hot Chocolate is deeply integrated with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Microsoft.Extension.DependencyInjection\"), \" but can also be used with other dependency injection frameworks as long as they implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IServiceProvider\"), \".\"), mdx(\"p\", null, \"While it is possible to have constructor dependency injection on GraphQL type objects themselves it should be avoided. Think of the GraphQL types as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"System.Type\"), \"s. Dependency injection is best used on the runtime types, that are passed through the execution engine.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GraphQL Type\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType : ObjectType<Query>\\n{\\n    // code omitted for brevity\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Runtime Type\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    // code omitted for brevity\\n}\\n\")), mdx(\"p\", null, \"Root runtime types and extension runtime types do not need to be registered with the dependency injection. Hot Chocolate will use the dependency injection and handle them as singletons by keeping the instance for the lifetime of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IRequestExecutor\"), \".\"), mdx(\"p\", null, \"Lets say we have a singleton service \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IUserRepository\"), \" and our class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    public Query(IUserRepository repository)\\n    {\\n\\n    }\\n\\n    // code omitted for brevity\\n}\\n\")), mdx(\"p\", null, \"With this configuration we can just do the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services\\n    .AddSingleton<IUserRepository, UserRepository>()\\n    .AddGraphQLServer()\\n    .AddQueryType<Query>()\\n\")), mdx(\"p\", null, \"But if we had a scoped user repository and used constructor injection on our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" we would need to register our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" class with the dependency injection and Hot Chocolate would resolve it automatically from there.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services\\n    .AddScoped<IUserRepository, UserRepository>()\\n    .AddScoped<Query>()\\n    .AddGraphQLServer()\\n    .AddQueryType<Query>()\\n\")), mdx(\"p\", null, \"The same behavior is true for type extensions.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[ExtendObjectType(OperationTypes.Query)]\\npublic class UserQueries\\n{\\n    public UserQueries(IUserRepository repository)\\n    {\\n\\n    }\\n\\n    // code omitted for brevity\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services\\n    .AddScoped<IUserRepository, UserRepository>()\\n    .AddScoped<UserQueries>()\\n    .AddGraphQLServer()\\n    .AddQueryType()\\n    .AddTypeExtension<UserQueries>()\\n\")), mdx(\"h1\", null, \"Method-Level Dependency Injection\"), mdx(\"p\", null, \"Hot Chocolate also allows for method-level dependency injection. This allows you to create side-effect free resolvers regarding the dependency injection. We in general advise to use method-level dependency injection on resolvers for better execution performance and simpler maintenance.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public async Task<User> GetUserAsync([Service] IUserRepository repository)\\n{\\n    // The user repository can just be used by this resolver,\\n    // it does not matter if it is transient, scoped or singleton.\\n}\\n\")), mdx(\"p\", null, \"In this case you can keep the simpler configuration and let Hot Chocolate take care of the lifetime.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services\\n    .AddSingleton<IUserRepository, UserRepository>()\\n    .AddGraphQLServer()\\n    .AddQueryType<Query>()\\n\")), mdx(\"p\", null, \"This also benefits the execution engine since it knows which services are used and how to optimize execution.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note: For method-level dependency injection we also allow to reuse the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FromServicesAttribute\"), \" from ASP.NET core.\")), mdx(\"h1\", null, \"Custom Dependency Injection Container\"), mdx(\"p\", null, \"In order to override the default dependency injection container you need to override the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DefaultHttpRequestInterceptor\"), \" and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DefaultSocketSessionInterceptor\"), \".\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Inherit from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"DefaultHttpRequestInterceptor\"), \" and override \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"OnCreateAsync\"), \".\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class CustomHttpRequestInterceptor : DefaultHttpRequestInterceptor\\n{\\n    public async override ValueTask OnCreateAsync(\\n        HttpContext context,\\n        IRequestExecutor requestExecutor,\\n        IQueryRequestBuilder requestBuilder,\\n        CancellationToken cancellationToken)\\n    {\\n        await base.OnCreateAsync(context, requestExecutor, requestBuilder, cancellationToken);\\n        requestBuilder.SetServices(CUSTOM_SERVICE_PROVIDER);\\n    }\\n}\\n\")), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Register \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"CustomHttpRequestInterceptor\"), \" with the root \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ServiceCollection\"), \".\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddHttpRequestInterceptor<CustomHttpRequestInterceptor>();\\n\")), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Next, inherit from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"DefaultSocketSessionInterceptor\"), \" and override \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"OnRequestAsync\"), \".\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class CustomSocketSessionInterceptor : DefaultSocketSessionInterceptor\\n{\\n    public async override ValueTask OnRequestAsync(\\n        ISocketConnection connection,\\n        IQueryRequestBuilder requestBuilder,\\n        CancellationToken cancellationToken)\\n    {\\n        await await OnRequestAsync(connection, requestBuilder, cancellationToken);\\n        requestBuilder.SetServices(CUSTOM_SERVICE_PROVIDER);\\n    }\\n}\\n\")), mdx(\"ol\", {\n    \"start\": 4\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Last, register your \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"CustomSocketSessionInterceptor\"), \" with the root \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ServiceCollection\"), \".\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddSocketSessionInterceptor<CustomSocketSessionInterceptor>();\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#method-level-dependency-injection","title":"Method-Level Dependency Injection"},{"url":"#custom-dependency-injection-container","title":"Custom Dependency Injection Container"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11.1 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"descriptions","title":"Schema Documentation"},{"path":"operations","title":"Operations"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"extending-types","title":"Extending types"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"distributed-schema","title":"Distributed Schemas","items":[{"path":"index","title":"Overview"},{"path":"schema-stitching","title":"Schema Stitching"},{"path":"schema-federations","title":"Schema Federations"},{"path":"schema-configuration","title":"Schema Configuration"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"dependency-injection","title":"Dependency Injection"},{"path":"executable","title":"Executable"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/api-reference/dependency-injection.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}