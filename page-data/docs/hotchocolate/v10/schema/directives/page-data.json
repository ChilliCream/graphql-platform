{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/v10/schema/directives","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/v10/schema/directives/"},"frontmatter":{"title":"Directives"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Directives\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Introduction\"), mdx(\"p\", null, \"Directives provide a way in GraphQL to add annotations to the type system or query elements. These annotations can be used to provide meta data for code generators or even to change the execution behavior of the query engine on a GraphQL server.\"), mdx(\"p\", null, \"You can specify a directive by inheriting from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DirectiveType\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class MyDirective\\n    : DirectiveType\\n{\\n    protected override void Configure(IDirectiveTypeDescriptor descriptor)\\n    {\\n        descriptor.Name(\\\"my\\\");\\n        descriptor.Location(DirectiveLocation.Field);\\n    }\\n}\\n\")), mdx(\"p\", null, \"In order to use a directive it has to be registered with the schema.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"SchemaBuilder.New()\\n    .AddDirectiveType<MyDirective>()\\n    .Create();\\n\")), mdx(\"p\", null, \"GraphQL specifies three directives in the spec (skip, include and deprecated) which are always registered with your schema.\"), mdx(\"p\", null, \"The skip and include directives can be used in queries to in- or exclude fields from your query.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query foo($hideField: Boolean = false) {\\n  hello @skip(if: $hideField)\\n}\\n\")), mdx(\"h1\", null, \"Repeatable\"), mdx(\"p\", null, \"Directives are by default unique, that means that you can annotate a directive just once to an object. If you want to add a specific directive type multiple times you have to specify the directive as repeatable.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class MyDirective\\n    : DirectiveType\\n{\\n    protected override void Configure(IDirectiveTypeDescriptor descriptor)\\n    {\\n        descriptor.Name(\\\"my\\\");\\n        descriptor.Location(DirectiveLocation.Field);\\n        descriptor.Repeatable();\\n    }\\n}\\n\")), mdx(\"h1\", null, \"Typed Arguments\"), mdx(\"p\", null, \"Directive can have arguments that can be used to make them more flexible. So, if we had a directive like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class MyDirective\\n    : DirectiveType\\n{\\n    protected override void Configure(IDirectiveTypeDescriptor descriptor)\\n    {\\n        descriptor.Name(\\\"my\\\");\\n        descriptor.Argument(\\\"name\\\").Type<NonNullType<StringType>>();\\n        descriptor.Location(DirectiveLocation.Object);\\n    }\\n}\\n\")), mdx(\"p\", null, \"We could associate the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MyDirective\"), \" with an object like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class FooType\\n    : ObjectType\\n{\\n    protected override void Configure(IObjectTypeDescriptor descriptor)\\n    {\\n        descriptor.Name(\\\"Foo\\\");\\n        descriptor.Directive(\\\"my\\\", new StringValue(\\\"bar\\\"));\\n        ...\\n    }\\n}\\n\")), mdx(\"p\", null, \"Adding directives just with their name is not type safe and could lead to runtime errors which can be avoided by using our generic variant of the directive type. The generic directive type declares the .NET type that represents the directive instance.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class MyDirectiveType\\n    : DirectiveType<MyDirective>\\n{\\n    protected override void Configure(IDirectiveTypeDescriptor descriptor)\\n    {\\n        descriptor.Name(\\\"my\\\");\\n        ...\\n    }\\n}\\n\\npublic class MyDirective\\n{\\n    public string Name { get; set; }\\n}\\n\")), mdx(\"p\", null, \"The generic directive type works similar to the generic input object type. The directive descriptor will automatically try to discover any properties and expose those as arguments.\"), mdx(\"p\", null, \"So, with our new directive in place we could now add it to our object type like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class FooType\\n    : ObjectType\\n{\\n    protected override void Configure(IObjectTypeDescriptor descriptor)\\n    {\\n        descriptor.Name(\\\"Foo\\\");\\n        descriptor.Directive(new MyDirective { Name = \\\"bar\\\" });\\n        ...\\n    }\\n}\\n\")), mdx(\"p\", null, \"Since, the directive instance that we have added to our type is now a strong .NET type we do not have to fear changes to the directive structure or its name anymore.\"), mdx(\"h1\", null, \"Middleware\"), mdx(\"p\", null, \"What makes directive with Hot Chocolate very useful is the ability to associate a middleware with it. A middleware can alternate the result or even produce the result of a field. A directive middleware is only added to a field middleware pipeline when the directive was annotated to the object definition, the field definition or the field.\"), mdx(\"p\", null, \"Moreover, of the directive is repeatable the middleware will be added multiple times to the middleware allowing to build a real pipeline with it.\"), mdx(\"p\", null, \"In order to add a middleware to a directive you could declare it with the descriptor as a delegate.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class MyDirectiveType\\n    : DirectiveType<MyDirective>\\n{\\n    protected override void Configure(IDirectiveTypeDescriptor descriptor)\\n    {\\n        descriptor.Name(\\\"my\\\");\\n        descriptor.Location(DirectiveLocation.Object);\\n        descriptor.Use(next => context =>\\n        {\\n            context.Result = \\\"Bar\\\";\\n            return next.Invoke(context);\\n        })\\n    }\\n}\\n\\npublic class MyDirective\\n{\\n    public string Name { get; set; }\\n}\\n\")), mdx(\"p\", null, \"Directives with middleware or executable directives can be put on object types and on their field definitions or on the field selection in a query. Executable directives on an object type will replace the field resolver of every field of the annotated object type.\"), mdx(\"h2\", null, \"Order\"), mdx(\"p\", null, \"In GraphQL the directive order is significant and with our middleware we use the order of directives to create a resolver pipeline through which the result flows.\"), mdx(\"p\", null, \"The resolver pipeline consists of a sequence of directive delegates, called one after the other.\"), mdx(\"p\", null, \"Each delegate can perform operations before and after the next delegate. A delegate can also decide to not pass a resolver request to the next delegate, which is called short-circuiting the resolver pipeline. Short-circuiting is often desirable because it avoids unnecessary work.\"), mdx(\"p\", null, \"The order of middleware pipeline is defined by the order of the directives. Since, executable directives will flow from the object type to its field definitions the directives of the type would be called first in the order that they were annotated.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  foo: Bar\\n}\\n\\ntype Bar @a @b {\\n  baz: String @c @d\\n}\\n\")), mdx(\"p\", null, \"So, the directives in the above example would be called in the following order \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a, b, c, d\"), \".\"), mdx(\"p\", null, \"If there were more directives in the query, they would be appended to the directives from the type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  foo {\\n    baz @e @f\\n  }\\n}\\n\")), mdx(\"p\", null, \"So, now the order would be like the following: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a, b, c, d, e, f\"), \".\"), mdx(\"p\", null, \"Every middleware can execute the original resolver function by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ResolveAsync()\"), \" on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IDirectiveContext\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#introduction","title":"Introduction"},{"url":"#repeatable","title":"Repeatable"},{"url":"#typed-arguments","title":"Typed Arguments"},{"url":"#middleware","title":"Middleware","items":[{"url":"#order","title":"Order"}]}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/v10/schema/directives.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}