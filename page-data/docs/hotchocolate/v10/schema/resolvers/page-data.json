{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/v10/schema/resolvers","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/v10/schema/resolvers/"},"frontmatter":{"title":"Resolvers"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Resolvers\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In GraphQL resolvers describe the logic that fetches data for a specific field.\"), mdx(\"p\", null, \"Field resolvers run independently of each other which allows the execution engine to parallelize their execution.\"), mdx(\"p\", null, \"This independent approach to fetch data allows us to build powerful schemas that consists of multiple data sources in a very simple way.\"), mdx(\"p\", null, \"Since we have two major approaches with Hot Chocolate to define a schema, we also have two approaches to declaring our resolvers. We will start by looking at how we can declare resolvers with the schema-first approach and then look at how this is done in the code-first world.\"), mdx(\"p\", null, \"It is important to know that we can mix both approaches. Moreover, resolvers are integrated as a component into the field-middleware-pipeline. A field-middleware is more complex but can also open up more scenarios. One could for instance write a middleware that resolves the data for multiple fields of a certain well-defined data source.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"More about what a field-middleware can do can be found \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/hotchocolate/v10/execution-engine\"\n  }), \"here\"), \".\")), mdx(\"h1\", null, \"Schema-First\"), mdx(\"p\", null, \"With Hot Chocolate we have multiple approaches to write resolvers depending on how you declare your schema.\"), mdx(\"p\", null, \"With the schema-first approach the simplest way to declare a resolver is binding a delegate that resolves the data to a field in your schema like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"c.BindResolver(ctx =>\\n{\\n    // my resolver code goes here ...\\n}).To(\\\"Query\\\", \\\"foo\\\");\\n\")), mdx(\"p\", null, \"Furthermore, we could bind a class as a resolver type. Each of the members of the resolver type can be bound to fields in the schema.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddGraphQL(so =>\\n    SchemaBuilder.New()\\n        .AddDocumentFromFile(\\\"schema.graphql\\\")\\n        .BindComplexType<Query>(b => b\\n            .To(\\\"Query\\\")\\n            .Field(t => t.GetGreetings())\\n            .Name(\\\"greetings\\\"))\\n        .Create());\\n\")), mdx(\"p\", null, \"Since, the class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" is used as our resolver type, the query engine will automatically create an instance of this type as singleton. The lifetime of the resolver object is basically bound to the lifetime of the query executor.\"), mdx(\"p\", null, \"We can also take charge of the lifetime management by registering the resolver type with the dependency injection. In this case the query engine will retrieve the type from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IServiceProvider\"), \" and not perform any lifetime management.\"), mdx(\"p\", null, \"Sometimes, we do not want to explicitly declare resolvers since we have already modeled our entities very well and just want to map those to our schema. In this case we can just bind our type like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddGraphQL(so =>\\n    SchemaBuilder.New()\\n        .AddDocumentFromFile(\\\"schema.graphql\\\")\\n        .BindComplexType<Query>(b => b.To(\\\"Query\\\"))\\n        .Create());\\n\")), mdx(\"p\", null, \"Entities are handled differently than resolver types.\"), mdx(\"p\", null, \"First of all you are able to pass in an entity object on which the resolvers are executed. In this case the query engine will do nothing and operate on the passed in entity.\"), mdx(\"p\", null, \"If no initial root value was passed into the query engine, the query engine will create a new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" object by itself. The instance will be disposed (if disposable) after the request was completed.\"), mdx(\"p\", null, \"Like with the resolver type we can take charge of the lifetime by registering the root types as services with our dependency injection.\"), mdx(\"p\", null, \"In the case that we have not specified any resolvers for our bound entity, Hot Chocolate will generate an in-memory assembly that contains the inferred resolvers.\"), mdx(\"p\", null, \"Moreover, we can combine our approach in order to provide specific resolver logic for our entity or in order to extend on our entity. In many cases our entity may just represent part of the data structure that we want to expose in our schema. In this case we can just provide resolver logic to fill the gaps.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddGraphQL(so =>\\n    SchemaBuilder.New()\\n        .AddDocumentFromFile(\\\"schema.graphql\\\")\\n        .BindComplexType<Query>(b => b.To(\\\"Query\\\"))\\n        .BindResolver<QueryResolver>(b => b\\n            .To(\\\"Query\\\")\\n            .Resolve(\\\"greetings\\\")\\n            .With(t => t.GetGreetings(default)))\\n        .Create());\\n\")), mdx(\"p\", null, \"In the above case the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GetGreetings\"), \" method has an argument \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" which is our bound entity. Resolver methods can specify the original field arguments as specified by the field definition as well as context arguments.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public string GetGreetings([Parent]Query query) => query.Greetings;\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ParentAttribute\"), \" signals the query engine that this argument shall be the instance of the declaring type of our field.\"), mdx(\"p\", null, \"We also could let the query engine inject us the resolver context which provides us with all the context data for our resolver.\"), mdx(\"p\", null, \"For example we could access all the previous resolved object in our path by accessing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IResolverContext.Source\"), \". Or, we could access scoped context data that were passed down by one of the previous resolvers in the path.\"), mdx(\"p\", null, \"In order to keep our resolver clean and easy to test we can also just let the query engine inject the parts of the resolver context that we really need for our resolver like the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObjectType\"), \" to which our current field belongs etc.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public string GetGreetings(ObjectType type) => type.Name;\\n\")), mdx(\"h1\", null, \"Code-First\"), mdx(\"p\", null, \"Code-first is the second approach with which we can be describe a GraphQL schema. In Code-first, field definition and resolver logic are more closely bound together.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType\\n    : ObjectType\\n{\\n    protected override void Configure(IObjectTypeDescriptor descriptor)\\n    {\\n        descriptor.Name(\\\"Query\\\");\\n        descriptor.Field(\\\"greetings\\\").Resolver(ctx => \\\"foo\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"The above example declares a schema type named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" with one field called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"greetings\"), \" of the type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \" that always returns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \". Like with the schema-first approach we can create types that are not explicitly bound to a specific .NET type like in the above example.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class PersonType\\n    : ObjectType<Person>\\n{\\n// Types inferred\\n}\\n\")), mdx(\"p\", null, \"If we bind our type to a specific entity type using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObjectType<T>\"), \", then we will by default infer the possible type structure and its resolvers from the .NET type.\"), mdx(\"p\", null, \"We can always overwrite the defaults or define everything explicitly.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class PersonType\\n    : ObjectType<Person>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Person> descriptor)\\n    {\\n        descriptor.Name(\\\"Person123\\\");\\n        descriptor.Field(t => t.Name).Type<NonNullType<StringType>>();\\n        descriptor.Field(t => t.FriendId)\\n            .Name(\\\"friend\\\")\\n            .Resolver(ctx => ctx.Service<IRepository>().GetPerson(ctx.Parent<Person>().FriendId));\\n    }\\n}\\n\")), mdx(\"h1\", null, \"Resolver Types\"), mdx(\"p\", null, \"Since, a lot of resolver logic, like the one in the above example, can be difficult to test and difficult to read, we also allow to create resolver types with the code-first approach.\"), mdx(\"p\", null, \"We can explicitly include resolvers from a resolver type the same way we are specifying our fields.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor.Field<PersonResolvers>(t => t.GetFriend(defaults)).Type<PersonType>();\\n\")), mdx(\"p\", null, \"The one difference is that we basically specify from which type we are including the resolver.\"), mdx(\"p\", null, \"Furthermore, we can also include all fields of a resolver type implicitly like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor.Include<PersonResolvers>();\\n\")), mdx(\"p\", null, \"We can also reverse the relationship between the type and its resolvers by annotating the resolver type with the entity or schema type name for which the resolver type provides resolvers.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[GraphQLResolverOf(typeof(Person))]\\n[GraphQLResolverOf(\\\"Query\\\")]\\npublic class SomeResolvers\\n{\\n    public Person GetFriend([Parent]Person person)\\n    {\\n        // resolver code\\n    }\\n\\n    [GraphQLDescription(\\\"This field does ...\\\")]\\n    public string GetGreetings([Parent]Query person, string name)\\n    {\\n        // resolver code\\n    }\\n}\\n\")), mdx(\"p\", null, \"The above example class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SomeResolvers\"), \" provides resolvers for multiple types. The types can be declared with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GraphQLResolverOfAttribute\"), \" either by providing the .NET entity type or by providing the schema type name. This resolver can be registered with the schema builder via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BindResolver<SomeResolvers>()\"), \" as shown here:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddGraphQL(so =>\\n    SchemaBuilder.New()\\n        // ...\\n        .BindResolver<SomeResolvers>()\\n        // ...\\n        .Create());\\n\")), mdx(\"p\", null, \"The schema builder will associate the various resolver methods with the correct schema fields and types by analysing the method parameters. We are providing a couple of attributes that can be used to give the resolver method more context like the return type or the description and so on.\"), mdx(\"h1\", null, \"Resolver Dependency Injection\"), mdx(\"p\", null, \"Hot Chocolate supports resolver parameter dependency injection. Basically we are able to inject things that we would usually get from the resolver context itself. This makes it clear what demands the resolver has.\"), mdx(\"p\", null, \"Let us have a look at an example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Person GetFriend([Parent]Person person, IObjectField field)\\n{\\n    // resolver code\\n}\\n\")), mdx(\"p\", null, \"The above resolver is injected with the previously resolved (parent) result and the field definition of the current field.\"), mdx(\"p\", null, \"Any property of the resolver context can be explicitly injected as argument.\"), mdx(\"p\", null, \"The following resolver context properties can be injected without any attributes:\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Member\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Type\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Description\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Schema\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"ISchema\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The GraphQL schema.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"ObjectType\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"ObjectType\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The object type on which the field resolver is being executed.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Field\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"ObjectField\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The field on which the field resolver is being executed.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"QueryDocument\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"DocumentNode\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The query that is being executed.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Operation\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"OperationDefinitionNode\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The operation from the query that is being executed.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"FieldSelection\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"FieldNode\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The field selection for which a field resolver is being executed.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Path\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Path\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The current execution path.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Argument<T>(string name)\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"T\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Gets a specific field argument.\")))), mdx(\"p\", null, \"The following resolver context data can be accessed by annotating the method argument with an attribute.\"), mdx(\"p\", null, \"##\\xA0Parent\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Person GetFriend([Parent]Person person)\\n{\\n    // resolver code\\n}\\n\")), mdx(\"h2\", null, \"Services\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Person GetFriend([Service]IPersonRepository repository)\\n{\\n    // resolver code\\n}\\n\")), mdx(\"p\", null, \"##\\xA0DataLoader\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Person GetFriend([DataLoader]IPersonDataLoader dataLoader)\\n{\\n    // resolver code\\n}\\n\")), mdx(\"p\", null, \"Or\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Person GetFriend([DataLoader(\\\"ById\\\")]IPersonDataLoader dataLoader)\\n{\\n    // resolver code\\n}\\n\")), mdx(\"h2\", null, \"State\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Person GetFriend([State(\\\"foo\\\")]Bar bar)\\n{\\n    // resolver code\\n}\\n\")), mdx(\"h1\", null, \"Resolver Context Overview\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Member\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Type\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Description\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Schema\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"ISchema\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The GraphQL schema.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"ObjectType\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"ObjectType\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The object type on which the field resolver is being executed.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Field\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"ObjectField\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The field on which the field resolver is being executed.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"QueryDocument\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"DocumentNode\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The query that is being executed.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Operation\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"OperationDefinitionNode\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The operation from the query that is being executed.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"FieldSelection\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"FieldNode\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The field selection for which a field resolver is being executed.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Path\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Path\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The current execution path.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Argument<T>(string name)\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"T\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Gets a specific field argument.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Source\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"ImmutableStack<object>\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"The source stack contains all previous resolver results of the current execution path\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Parent<T>()\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"T\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Gets the previous (parent) resolved result.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Service<T>()\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"T\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Gets as specific service from the dependency injection container.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"CustomContext<T>()\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"T\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Gets a specific custom context object that can be used to build up a state.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"DataLoader<T>(string key)\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"T\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Gets a specific DataLoader.\")))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#schema-first","title":"Schema-First"},{"url":"#code-first","title":"Code-First"},{"url":"#resolver-types","title":"Resolver Types"},{"url":"#resolver-dependency-injection","title":"Resolver Dependency Injection","items":[{"url":"#services","title":"Services"},{"url":"#state","title":"State"}]},{"url":"#resolver-context-overview","title":"Resolver Context Overview"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"state-management","title":"State Management","items":null},{"path":"persisted-queries","title":"Persisted Queries","items":null},{"path":"configuration","title":"Configuration","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/v10/schema/resolvers.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}