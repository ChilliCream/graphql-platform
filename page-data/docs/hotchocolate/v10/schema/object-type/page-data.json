{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/v10/schema/object-type","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/v10/schema/object-type/"},"frontmatter":{"title":"Object Type"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Object Type\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The object type is the most prominent output type in GraphQL and represents a kind of object we can fetch from our schema. The GraphQL schema representation of an object looks like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Starship {\\n  id: ID!\\n  name: String!\\n  length(unit: LengthUnit = METER): Float\\n}\\n\")), mdx(\"p\", null, \"An object in GraphQL consists of a collection of fields. Object fields in GraphQL can have arguments, so we could compare it to methods in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"C#\"), \". Each field has a distinct type. All field types have to be output types (scalars, enums, objects, unions or interfaces). The arguments of a field on the other hand have to be input types scalars, enums and input objects).\"), mdx(\"p\", null, \"With Hot Chocolate we can define an object by using the GraphQL SDL syntax or by using C#. Each field of an object will get a resolver assigned that knows how to fetch the data for that field.\"), mdx(\"p\", null, \"A single GraphQL object might be the composition of data that comes from several data sources.\"), mdx(\"p\", null, \"If we take the following object for instance:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  sayHello: String!\\n}\\n\")), mdx(\"p\", null, \"We could define this like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"SchemaBuilder.New()\\n  .AddDocumentFromString(@\\\"\\n      type Query {\\n        sayHello: String!\\n      }\\\")\\n  .AddResolver(context => \\\"Hello!\\\")\\n  .Create();\\n\")), mdx(\"p\", null, \"With C# we could define it like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    public string SayHello() => \\\"Hello!\\\";\\n}\\n\\nSchemaBuilder.New()\\n  .AddQueryType<Query>()\\n  .Create();\\n\")), mdx(\"p\", null, \"GraphQL has a concept of nun-null types. Basically any type can be a non-nullable type, in the SDL we decorate non-nullable types with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bang\"), \" token \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"!\"), \". In order to describe this in C# we can use attributes, use C# 8 and nullable reference types or use the underlying schema types to describe our GraphQL type explicitly.\"), mdx(\"p\", null, \"This is how it would look like with our attributes:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [GraphQLNonNullType]\\n    public string SayHello() => \\\"Hello!\\\";\\n}\\n\\nSchemaBuilder.New()\\n  .AddQueryType<Query>()\\n  .Create();\\n\")), mdx(\"p\", null, \"With C# 8.0 we can enable nullable reference type either in our project:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-xml\"\n  }), \"<PropertyGroup>\\n  <Nullable>enable</Nullable>\\n</PropertyGroup>\\n\")), mdx(\"p\", null, \"Or we could use pre-processor directives to opt-in on a by file base:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"#nullable enable\\n\\npublic class Query\\n{\\n    public string SayHello() => \\\"Hello!\\\";\\n}\\n\\nSchemaBuilder.New()\\n  .AddQueryType<Query>()\\n  .Create();\\n\")), mdx(\"p\", null, \"With schema types the same thing would look like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    public string SayHello() => \\\"Hello!\\\";\\n}\\n\\npublic class QueryType\\n    : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(t => t.SayHello()).Type<NonNullType<StringType>>();\\n    }\\n}\\n\\nSchemaBuilder.New()\\n  .AddQueryType<QueryType>()\\n  .Create();\\n\")), mdx(\"h1\", null, \"Resolvers\"), mdx(\"p\", null, \"Schema types will also allow us to add fields that are not on our current model.\\nLet\", \"`\", \"s say we have the following C# model:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Person\\n{\\n    public int Id { get; set; }\\n    public string Name { get; set; }\\n}\\n\")), mdx(\"p\", null, \"And we want to expose the following object to our schema users:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Person {\\n  id: Int!\\n  name: String!\\n  friends: [Person]\\n}\\n\")), mdx(\"p\", null, \"Then we could do something like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class PersonType\\n    : ObjectType<Person>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Person> descriptor)\\n    {\\n        descriptor.Field(t => t.Name).Type<NonNullType<StringType>>();\\n        descriptor.Field(\\\"friends\\\")\\n            .Type<ListType<NonNullType<PersonType>>>()\\n            .Resolver(context =>\\n                context.Service<IPersonRepository>().GetFriends(\\n                    context.Parent<Person>().Id));\\n    }\\n}\\n\")), mdx(\"p\", null, \"Let\", \"`\", \"s have a look at the above example, first we have our name field there, since we need to declare it non-nullable.\\nBut we do not have the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" field there. Hot Chocolate will always try to infer the usage of the provided type if it is not overridden by the user. We always can opt out of this behavior and tell Hot Chocolate that we do want to declare everything explicitly.\"), mdx(\"p\", null, \"In the case of value types Hot Chocolate can infer the non-nullability correctly in any C# version and we do not have to specify anything extra.\"), mdx(\"p\", null, \"The second thing that is important in this example is that we can introduce fields that are not on our model and that might even come from a completely different data source. In these cases, we have to provide explicit resolvers since we cannot infer the resolver from the C# type.\"), mdx(\"p\", null, \"We also can use schema types if we have no .NET backing type at all. In these cases, we have to write explicit resolvers for each of the fields:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType\\n    : ObjectType\\n{\\n    protected override void Configure(IObjectTypeDescriptor descriptor)\\n    {\\n        descriptor.Field(\\\"sayHello\\\")\\n            .Type<NonNullType<StringType>>()\\n            .Resolver(\\\"Hello!\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"We can also turn that around and write our resolver logic in our C# objects since we support method argument injection. We could also create our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" type in C# like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Person\\n{\\n    public int Id { get; set; }\\n    public string Name { get; set; }\\n\\n    public IEnumerable<Person> GetFriends([Service]IPersonRepository repository) =>\\n        repository.GetFriends(Id);\\n}\\n\")), mdx(\"p\", null, \"Since in many cases we do not want to put resolver code in our business objects we can also split our type and still move the resolver code to a C# class:\"), mdx(\"p\", null, \"Pure Code-First:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Person\\n{\\n    public int Id { get; set; }\\n    public string Name { get; set; }\\n}\\n\\n[ExtendObjectType(Name = \\\"Person\\\")]\\npublic class PersonResolvers\\n{\\n    public IEnumerable<Person> GetFriends(Person person, [Service]IPersonRepository repository) =>\\n        repository.GetFriends(person.Id);\\n}\\n\")), mdx(\"p\", null, \"Code-First:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Person\\n{\\n    public int Id { get; set; }\\n    public string Name { get; set; }\\n}\\n\\npublic class PersonResolvers\\n{\\n    public IEnumerable<Person> GetFriends([Parent]Person person, [Service]IPersonRepository repository) =>\\n        repository.GetFriends(person.Id);\\n}\\n\\npublic class PersonType\\n    : ObjectType<Person>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Person> descriptor)\\n    {\\n        descriptor.Field(t => t.Name).Type<NonNullType<StringType>>();\\n        descriptor.Field<PersonResolvers>(t => t.GetFriends(default, default))\\n            .Type<ListType<NonNullType<PersonType>>>();\\n    }\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"More about resolvers can be read \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/hotchocolate/v10/schema/resolvers\"\n  }), \"here\"), \".\")), mdx(\"h1\", null, \"Extension\"), mdx(\"p\", null, \"The GraphQL SDL supports extending object types, this means that we can add fields to an existing object type without changing the code of our initial type definition.\"), mdx(\"p\", null, \"Extending types is useful for schema stitching but also when we want to add just something to an exist type or if we just want to split large type definitions. The latter is often the case with the query type definition.\"), mdx(\"p\", null, \"Hot Chocolate supports extending types with SDL-first, pure code-first and code-first. Let\", \"`\", \"s have a look at how we can extend our person object:\"), mdx(\"p\", null, \"SDL-First:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"extend type Person {\\n  address: String!\\n}\\n\")), mdx(\"p\", null, \"Pure Code-First:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[ExtendObjectType(Name = \\\"Person\\\")]\\npublic class PersonResolvers\\n{\\n    public IEnumerable<Person> GetFriends([Parent]Person person, [Service]IPersonRepository repository) =>\\n        repository.GetFriends(person.Id);\\n}\\n\\nSchemaBuilder.New()\\n  ...\\n  .AddType<PersonType>()\\n  .AddType<PersonResolvers>()\\n  .Create();\\n\")), mdx(\"p\", null, \"Code-First\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class PersonTypeExtension\\n    : ObjectTypeExtension\\n{\\n    protected override void Configure(IObjectTypeDescriptor descriptor)\\n    {\\n        descriptor.Name(\\\"Person\\\");\\n        descriptor.Field(\\\"address\\\")\\n            .Type<NonNullType<StringType>>()\\n            .Resolver(/\\\"Resolver Logic\\\"/);\\n    }\\n}\\n\\nSchemaBuilder.New()\\n  ..\\n  .AddType<PersonType>()\\n  .AddType<PersonTypeExtension>()\\n  .Create();\\n\")), mdx(\"p\", null, \"Type extensions basically work like usual types and are also added like usual types.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#resolvers","title":"Resolvers"},{"url":"#extension","title":"Extension"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11.1 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"descriptions","title":"Schema Documentation"},{"path":"operations","title":"Operations"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"extending-types","title":"Extending types"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"distributed-schema","title":"Distributed Schemas","items":[{"path":"index","title":"Overview"},{"path":"schema-stitching","title":"Schema Stitching"},{"path":"schema-federations","title":"Schema Federations"},{"path":"schema-configuration","title":"Schema Configuration"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"},{"path":"mongodb","title":"MongoDB"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"dependency-injection","title":"Dependency Injection"},{"path":"executable","title":"Executable"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/v10/schema/object-type.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}