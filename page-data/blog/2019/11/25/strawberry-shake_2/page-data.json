{"componentChunkName":"component---src-templates-blog-article-template-tsx","path":"/blog/2019/11/25/strawberry-shake_2","result":{"data":{"mdx":{"excerpt":"We are busy, busy, busy working on version 11 of Hot Chocolate and  Strawberry Shake . In this post I want to explore the client side ofâ€¦","frontmatter":{"featuredImage":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACJElEQVQoz32QSW/TUBRG/SuRWPAPWPIXWMCWBQuGBYMKG1SJQSAm0YEOtE1TpxlIYjeO48QZPCS2k3g6XBOCqkrwrKNr+d3z3fescGXl65rn/G/9a18pEvLiyVdNa4qVJAmO4+B7Hp7r4hVVyLLsb+ia7A/KWr4ctK7LOMY0TQl1GboTRuMxVr9PkqakWU4iwYnUOM1YJhkLqcrV41+9iuM6GO02o/M2vu+uBokYS9sizYmWKaEEB8JskaAUxywiomDJQj4U79MgpNuzWMp01/EoP3+LeucJ23fvYVk2bjin3tLpjRxmIjijEGcYMoklMP49LefHZo3arkGUJlyYFo22TrWt4dge2suP3H5wE/XxJqeHJ3QnHmpT40x6dN3G/mBgvdboDwKUSI46Hodsb5Qpf9Jo6AY17QLDHtPomNheyLf7j3h44zo7z15wXK1zoNaodweUpbfe7NN7J/1vNC66Poor15zIdfsSag0D7Nmc00abUr2F2upgzhOar76gX7tFaeM9qjWgao74elTmuGmgBzFNCfopNLwIxZawQUEU0w+XmNMFhj+nI5u6E9IRobSvsvX0HXuf96jYLi1X/uEkpDYOOB/OqEg9E8qDKcpKnqO7EZrQFlpORFPCGiLVpbE6CVDHUyqTiIrcomxPORW5JBz3pxxZPoc9n4Oeh3JZLCZWR4FIM1ThzJ6tRJFO1qJViD77In83PXa7LjvCtuGyJfwCTPI1bV6DUNQAAAAASUVORK5CYII=","aspectRatio":1.9047619047619047,"src":"/static/edfb5cf97791063a5ee862e3cf5cb76e/0514f/strawberry-shake-banner.png","srcSet":"/static/edfb5cf97791063a5ee862e3cf5cb76e/3cf40/strawberry-shake-banner.png 200w,\n/static/edfb5cf97791063a5ee862e3cf5cb76e/bc001/strawberry-shake-banner.png 400w,\n/static/edfb5cf97791063a5ee862e3cf5cb76e/0514f/strawberry-shake-banner.png 800w,\n/static/edfb5cf97791063a5ee862e3cf5cb76e/43fe9/strawberry-shake-banner.png 1200w","sizes":"(max-width: 800px) 100vw, 800px"}}},"path":"/blog/2019/11/25/strawberry-shake_2","title":"Building a real-time .NET GraphQL Client API","tags":["strawberry-shake","graphql","dotnet","aspnetcore"],"author":"Michael Staib","authorImageUrl":"https://avatars1.githubusercontent.com/u/9714350?s=100&v=4","authorUrl":"https://github.com/michaelstaib","date":"November 25, 2019"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"path\": \"/blog/2019/11/25/strawberry-shake_2\",\n  \"date\": \"2019-11-25\",\n  \"title\": \"Building a real-time .NET GraphQL Client API\",\n  \"featuredImage\": \"shared/strawberry-shake-banner.png\",\n  \"tags\": [\"strawberry-shake\", \"graphql\", \"dotnet\", \"aspnetcore\"],\n  \"author\": \"Michael Staib\",\n  \"authorUrl\": \"https://github.com/michaelstaib\",\n  \"authorImageUrl\": \"https://avatars1.githubusercontent.com/u/9714350?s=100&v=4\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"We are busy, busy, busy working on version 11 of Hot Chocolate and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \".\"), mdx(\"p\", null, \"In this post I want to explore the client side of GraphQL on .NET more with a special emphasis on subscriptions.\"), mdx(\"p\", null, \"Since, with the new version of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" our initial blog has become kind of invalid I also will walk you trough the basics again before heading into subscriptions and what lies beyond.\"), mdx(\"h2\", null, \"Getting Started\"), mdx(\"p\", null, \"Let us have a look at how we want to tackle things with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \". For this little walk-through I will use our \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/hotchocolate/tree/master/examples/AspNetCore.StarWars\"\n  }), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"Star Wars\"), \" server example\"), \".\"), mdx(\"p\", null, \"If you want to follow along then install the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://dotnet.microsoft.com/download/dotnet-core/3.0\"\n  }), \".NET Core 3 SDK\"), \" . We are also supporting other .NET variants but for this example you will need the .NET Core 3 SDK.\"), mdx(\"p\", null, \"Before we can start let us clone the Hot Chocolate repository and start our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Star Wars\"), \" server.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"git clone https://github.com/ChilliCream/hotchocolate.git\\ncd hotchocolate\\ndotnet run --project examples/AspNetCore.StarWars/\\n\")), mdx(\"p\", null, \"Now that we have our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Star Wars\"), \" server running, lets create a folder for our client and install the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" CLI tools.\\nThe \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" CLI tools are optional but make initializing the client project much easier.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"mkdir berry\\ndotnet new tool-manifest\\ndotnet tool install StrawberryShake.Tools --version 11.0.0-preview.58 --local\\n\")), mdx(\"p\", null, \"In our example we are using the new .NET CLI local tools. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dotnet new tool-manifest\"), \" creates the tools manifest which basically is like a packages.config and holds the information of which tools in which version we are using in our directory.\"), mdx(\"p\", null, \"This is the great thing about local tools if you think about it, you can install tools to your repository and have always the right set of tools available to you in the moment you clone that repository.\"), mdx(\"p\", null, \"The next command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dotnet tool install StrawberryShake.Tools --version 11.0.0-preview.58 --local\"), \" installs our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" tools. Once we have a final release of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" you do not need to speciefy the version anymore.\"), mdx(\"p\", null, \"Next we need a little project. Let\\u2019s create a new console application so that we can easily run and debug what we are doing.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"dotnet new console -n BerryClient\\ncd BerryClient\\ndotnet add package StrawberryShake --version 11.0.0-preview.58\\ndotnet add package Microsoft.Extensions.Http --version 3.0.0\\ndotnet add package Microsoft.Extensions.DependencyInjection --version 3.0.0\\n\")), mdx(\"p\", null, \"OK, now that we have a project setup lets initialize the project by creating a local schema. Like with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Relay\"), \" we are holding a local schema file that can be extended with local types and fields. Our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GraphQL\"), \" compiler will use this schema information to validate the queries we write. This makes \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GraphQL\"), \" query documents a part of the compilation process and with that a first-class citizen of our C# library.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"For the next step ensure that the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Star Wars\"), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GraphQL\"), \" server is running since we will fetch the schema from the server.\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If you want to check out what commands are available with the tools just run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dotnet graphql\"), \" and the CLI tools will output the available commands.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"dotnet graphql init http://localhost:5000/graphql -n StarWars -p ./StarWars\\n\")), mdx(\"p\", null, \"The init command will download the schema as GraphQL SDL and create a config to re-fetch the schema. Also, the config contains the client name. The client name defines how the client class and interface shall be named.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note: You can pass in the token and scheme if your endpoint is authenticated. There is also an update command to update the local schema.\")), mdx(\"p\", null, \"The configuration will look like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"Schemas\\\": [\\n    {\\n      \\\"Name\\\": \\\"StarWars\\\",\\n      \\\"Type\\\": \\\"http\\\",\\n      \\\"File\\\": \\\"StarWars.graphql\\\",\\n      \\\"Url\\\": \\\"http://localhost:5000/graphql\\\"\\n    }\\n  ],\\n  \\\"ClientName\\\": \\\"StarWarsClient\\\"\\n}\\n\")), mdx(\"p\", null, \"OK, now let\\u2019s get started by creating our first client API. For this open your editor of choice. I can recommend using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"VSCode\"), \" for this at the moment since you will get GraphQL highlighting. As we move forward, we will refine the tooling and provide proper IntelliSense.\"), mdx(\"p\", null, \"Now let us create a new file in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StarWars\"), \" folder called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Queries.graphql\"), \" and add the following query:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The file does not necessarily have to be called queries. You can call it however you want. The GraphQL compiler will figure out what files contain queries and what files contain schema definitions.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query getFoo {\\n  foo\\n}\\n\")), mdx(\"p\", null, \"Now build your project.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"dotnet build\\n\")), mdx(\"p\", null, \"When we now compile, we get an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"MSBuild\"), \" error on which we can click in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"VSCode\"), \" and we are pointed to the place in our query file from which the error stems from. The error tells us that there is no field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"/Users/michael/Local/play/berry/BerryClient/StarWars/Queries.graphql(2,3): error GQL: The field `foo` does not exist on the type `Query`. [/Users/michael/Local/play/berry/BerryClient/BerryClient.csproj]\\n\")), mdx(\"p\", null, \"Your GraphQL query document is not just a string, it properly compiles and is fully typed. Let's change our query and compile again:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query getFoo {\\n  hero {\\n    name\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"dotnet build\\n\")), mdx(\"p\", null, \"Now our project changes and we get a new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Generated\"), \" folder that has all the types that we need to communicate with our backend.\"), mdx(\"p\", null, \"Let us have a closer look at our client interface for a minute.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public interface IStarWarsClient\\n{\\n    Task<IOperationResult<IGetFoo>> GetFooAsync(\\n        CancellationToken cancellationToken = default);\\n}\\n\")), mdx(\"p\", null, \"The named operation \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getFoo\"), \" has become the method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GetFooAsync\"), \" in our generated client. This is nice since we kind of control from our GraphQL document the shape of our C# API. But there is more to that. A query document can hold multiple named operations. In essence the query document describes the interface between the client and the server.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query function_a {\\n  ...\\n}\\n\\nquery function_b {\\n  ...\\n}\\n\\nquery function_c {\\n  ...\\n}\\n\")), mdx(\"p\", null, \"Since, with GraphQL you essentially design your own service API by writing a query document you want to have control over the structure of your generated types. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" uses fragments to help you describe clean and reusable code components.\"), mdx(\"p\", null, \"Let us redesign our query with fragments and make it a bit more complex.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query getHero {\\n  hero {\\n    ...SomeDroid\\n    ...SomeHuman\\n  }\\n}\\n\\nfragment SomeHuman on Human {\\n  ...HasName\\n  homePlanet\\n}\\n\\nfragment SomeDroid on Droid {\\n  ...HasName\\n  primaryFunction\\n}\\n\\nfragment HasName on Character {\\n  name\\n}\\n\")), mdx(\"p\", null, \"The fragments will yield in the following type structure:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public interface ISomeHuman\\n    : IHasName\\n{\\n    string HomePlanet { get; }\\n}\\n\\npublic interface ISomeDroid\\n    : IHasName\\n{\\n    string PrimaryFunction { get; }\\n}\\n\\npublic interface IHasName\\n{\\n    string Name { get; }\\n}\\n\")), mdx(\"p\", null, \"Let us reflect on that, fragments not only let us re-use type selections in our query document but also let us create and mold our C# API into a clean type structure. This puts us as the consumer of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" in the driver seat.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"We\"), \" decide what data we \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"need\"), \" and how they are \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"shaped\"), \".\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"We are currently looking into how we can aggregate data and flatten the type structure. We initially thought about introducing some directives to flatten the type structure. But as we thought further on that and we really felt we want to have something like \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/APIs-guru/graphql-lodash\"\n  }), \"lodash\"), \". We are still discussing on what we want to do here. So stay tuned.\")), mdx(\"p\", null, \"Let's make one more tweak to our query and then we get this example running.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query getHero($episode: Episode) {\\n  hero(episode: $episode) {\\n    ...SomeDroid\\n    ...SomeHuman\\n  }\\n}\\n\\nfragment SomeHuman on Human {\\n  ...HasName\\n  homePlanet\\n}\\n\\nfragment SomeDroid on Droid {\\n  ...HasName\\n  primaryFunction\\n}\\n\\nfragment HasName on Character {\\n  name\\n}\\n\")), mdx(\"p\", null, \"By defining a variable with our operation we now can pass in arguments. This makes our operation re-usable and a good interface with the server. GraphQL servers can pre-compile and optimize those parametrized query documents.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public interface IStarWarsClient\\n{\\n    Task<IOperationResult<IGetHero>> GetHeroAsync(\\n        Optional<Episode> episode = default,\\n        CancellationToken cancellationToken = default);\\n}\\n\")), mdx(\"p\", null, \"OK, let's get it running and then go into more details.\"), mdx(\"p\", null, \"By default the generator will also generate dependency injection code for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Microsoft.Extensions.DependencyInjection\"), \".\"), mdx(\"p\", null, \"In order to get our client up and running we just have to set up a dependency injection container.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note: You can shut off dependency injection generation with a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"MSBuild\"), \" property. The client can also be instantiated with a builder or by using a different dependency injection container.\")), mdx(\"p\", null, \"Replace your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Program\"), \" class with the following code.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"class Program\\n{\\n    static async Task Main(string[] args)\\n    {\\n        var serviceCollection = new ServiceCollection();\\n        serviceCollection.AddHttpClient(\\n            \\\"StarWarsClient\\\",\\n            c => c.BaseAddress = new Uri(\\\"http://localhost:5000/graphql\\\"));\\n        serviceCollection.AddStarWarsClient();\\n\\n        IServiceProvider services = serviceCollection.BuildServiceProvider();\\n        IStarWarsClient client = services.GetRequiredService<IStarWarsClient>();\\n\\n        IOperationResult<IGetHero> result = await client.GetHeroAsync(Episode.Newhope);\\n        Console.WriteLine(((ISomeDroid)result.Data.Hero).Name);\\n\\n        result = await client.GetHeroAsync(Episode.Empire);\\n        Console.WriteLine(((ISomeHuman)result.Data.Hero).Name);\\n    }\\n}\\n\")), mdx(\"p\", null, \"Run the console and it will output the following;\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"R2-D2\\nLuke Skywalker\\n\")), mdx(\"p\", null, \"That is quite awesome. The client is easy to setup and easy to use. We just had to initialize our project and write a GraphQL query document and everything was generated so that we can focus on using our GraphQL endpoint instead of writing a bunch of code that we do not want to actually write. Moreover, we only get the types from the schema that we actually use in our query documents, that means we are not burdened with all the schema types and fields and so on that we do not need and do not want.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" let`s you take all the power of GraphQL and package it up into a fully typed client that works well with .NET. It does not limit you by introducing a new programming model like Linq or some other .NET API, instead \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" makes \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GraphQL a first class citizen in the .NET world\"), \".\"), mdx(\"p\", null, \"OK, now let us have a look at the result object since we also carefully discussed how we expose results to the consumer.\"), mdx(\"p\", null, \"The result of an operation can be a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IOperationResult<T>\"), \" or a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IResponseStream<T>\"), \".\"), mdx(\"p\", null, \"The operation result represents a single result and we expose the GraphQL result structure as specified in the GraphQL spec.\"), mdx(\"p\", null, \"This means that we give you a chance to take advantage of partial results in case of errors. However, we also make it easy to raise an exception in case of any error with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"EnsureNoErrors\"), \" method on the result object. This is kind of like with responses from a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HttpClient\"), \".\"), mdx(\"p\", null, \"Also, we allow you to have full access to provider specific data that is included in a dictionary called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Extensions\"), \". This for instances is used in cases like active persisted queries or other provider specific extensions.\"), mdx(\"h2\", null, \"Renaming Type Elements\"), mdx(\"p\", null, \"Did you notice the enum type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Episode.Newhope\"), \" in the upper example. This really is not nice to see as a C# developer :). Since the generator is built on top of the stitching API we easily can amend things like that in order to make our client API nice to use.\"), mdx(\"p\", null, \"So, before we go into subscriptions let`s fix that :)\"), mdx(\"p\", null, \"First, add another GraphQL file and call it \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StarWars.Extensions.graphql\"), \". Again, the name does not really matter, you could call it \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.graphql\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" would also handle it correctly.\"), mdx(\"p\", null, \"GraphQL allows to extend types with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"extend\"), \" keyword in the GraphQL SDL. In the example below we extend the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Episode\"), \" enum and add a directive (annotation) called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@name\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@name\"), \" directive allows us to provide the generator with a name for a type element that we actually want to use in our C# client API.\"), mdx(\"p\", null, \"Now add the following type extension to the GraphQL file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StarWars.Extensions.graphql\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"extend enum Episode {\\n  NEWHOPE @name(value: \\\"NewHope\\\")\\n}\\n\")), mdx(\"p\", null, \"Rebuild your project and voila ... \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Episode.NewHope\"), \" is now correctly cased.\"), mdx(\"p\", null, \"The nice thing is that we are just describing what we want to change in this schema extension file, so every time you update the server schema, we will preserve this file and reapply the type extensions to the newly downloaded schema.\"), mdx(\"p\", null, \"##\\xA0Subscriptions\"), mdx(\"p\", null, \"OK, OK, most of this was already in place, so let us have a look at something more challenging like subscriptions.\"), mdx(\"p\", null, \"Subscriptions will need a state-full connection to a server through a WebSocket. There are other ways to do this like SignalR (which essentially is a socket abstraction) or gRPC or even over a standard TCP socket.\"), mdx(\"p\", null, \"While we are in the works to get SignalR and gRPC in let us have a look at how we can do it through WebSockets.\"), mdx(\"p\", null, \"When we started on this we found that WebSockets should be as easy as setting up the HttpClient nowadays. So, we have introduced a new interface called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IWebSocketClientFactory\"), \". But just having a factory is not enough since we want to maybe pool socket connections and reuse those with multiple subscriptions.\"), mdx(\"p\", null, \"With the solution that we are introducing with version 11.0.0-preview.58 we are making WebSockets super simple to setup, and we will do all the hard parts like reusing the connection and things like that without you ever noticing it.\"), mdx(\"p\", null, \"Let us have a look at how we can get subscriptions to work.\"), mdx(\"p\", null, \"The first thing we have to do is going back to our query document. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Star Wars\"), \" server has one subscription that is raised whenever a review is written. So, let\\u2019s use it and add it to our query file.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query getHero($episode: Episode!) {\\n  hero(episode: $episode) {\\n    ...SomeDroid\\n    ...SomeHuman\\n  }\\n}\\n\\nsubscription onReviewCreated(episode: $episode) {\\n  onReview(episode: $episode) {\\n    commentary\\n    stars\\n  }\\n}\\n\\nfragment SomeHuman on Human {\\n  ...HasName\\n  homePlanet\\n}\\n\\nfragment SomeDroid on Droid {\\n  ...HasName\\n  primaryFunction\\n}\\n\\nfragment HasName on Character {\\n  name\\n}\\n\")), mdx(\"p\", null, \"Now, lets rebuild our project and then look at the client interface.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public interface IStarWarsClient\\n{\\n    Task<IOperationResult<IGetHero>> GetHeroAsync(\\n        Optional<Episode> episode = default,\\n        CancellationToken cancellationToken = default);\\n\\n    Task<IResponseStream<IOnReviewCreated>> OnReviewCreatedAsync(\\n        Optional<Episode> episode = default,\\n        CancellationToken cancellationToken = default);\\n}\\n\")), mdx(\"p\", null, \"Our client has now a new method that returns a response stream. A response stream is essentially an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IAsyncEnumerable\"), \" that will loop over the subscription event stream until the stream completes or the client disposes the stream.\"), mdx(\"p\", null, \"Now let us put everything together. First we need to configure the WebSocket client connection.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddWebSocketClient(\\n    \\\"StarWarsClient\\\",\\n    c => c.Uri = new Uri(\\\"ws://localhost:5000/graphql\\\"));\\n\")), mdx(\"p\", null, \"This kind of looks exactly the way we would configure an HttpClient and it hides all the complex logic about connecting and pooling WebSocket connections. It also lets you easily intercept the connect process to include authentication logic.\"), mdx(\"p\", null, \"The next thing we need to do to consume data from subscriptions is to read from our event stream.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"class Program\\n{\\n    static async Task Main(string[] args)\\n    {\\n        var serviceCollection = new ServiceCollection();\\n        serviceCollection.AddHttpClient(\\n            \\\"StarWarsClient\\\",\\n            c => c.BaseAddress = new Uri(\\\"http://localhost:5000/graphql\\\"));\\n        serviceCollection.AddStarWarsClient();\\n\\n        IServiceProvider services = serviceCollection.BuildServiceProvider();\\n        IStarWarsClient client = services.GetRequiredService<IStarWarsClient>();\\n\\n        var stream = await client.OnReviewCreatedAsync(Episode.NewHope);\\n\\n        await foreach (var result in stream)\\n        {\\n            result.EnsureNoErrors();\\n            Console.WriteLine(result.Data!.OnReview.Commentary);\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"If you look at the code above it looks so easy how you can use subscription with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \", it almost looks no different from fetching a simple query with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HttpClient\"), \". This is exactly what we want the experience to be, simple but when you want to get into the pluming then we will allow you to easily intercept and extend the whole pipeline.\"), mdx(\"p\", null, \"So, in order to try subscriptions out in your example open a tool like playground and the fire the following query against the local GraphQL Server while your console app is running.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"mutation {\\n  createReview(\\n    episode: NEWHOPE\\n    review: { commentary: \\\"Awesome movie.\\\", stars: 5 }\\n  ) {\\n    commentary\\n    stars\\n  }\\n}\\n\")), mdx(\"p\", null, \"As soon as you trigger the above mutation the client will print the commentary to the console, it is kind of like magic :)\"), mdx(\"h2\", null, \"Custom Scalars\"), mdx(\"p\", null, \"The mean thing with all these examples that I posted in this blog is that I am only using the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Star Wars\"), \" example. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Star Wars\"), \" uses no custom scalars and is super simple to use. That is the reason why I like to use it for demos, because people get easily on board with it. But it also is frustrating when you want to go deeper. This is especially true with custom scalars.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" supports an array of built-in scalars that go beyond the GraphQL spec. But still if you download the GitHub schema for instance you will get a ton of custom scalars.\"), mdx(\"p\", null, \"With the current version we have made dealing with custom scalars a lot easier. First, if we do not know a scalar, then we will treat it as a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \". While this is not always what you want, it lets you get started quickly and then change things when you really need them to change.\"), mdx(\"p\", null, \"Let us have a look at how we can bring in a custom scalar. For this example, let us assume we have a scalar called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ByteArray\"), \". This scalar serializes a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"System.Byte[]\"), \" to a base64 string. This is easy enough. So on the client side we want the generator to generate models that expose \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"System.Byte[]\"), \" as property type. But in the communication between server and client the type shall be serialized as base64 string.\"), mdx(\"p\", null, \"So, in order to give the generator a hint about these things we need to extend our schema. We would need to create a GraphQL file that holds our schema extensions (basically like with the enum example, where we renamed the enum value). The same way we can extend enums we can extend other types. In this case we want to annotate a scalar type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"extend scalar ByteArray\\n  @runtimeType(name: \\\"System.Byte[]\\\")\\n  @serializationType(name: \\\"System.String\\\")\\n\")), mdx(\"p\", null, \"The above example declares that for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ByteArray\"), \" scalar the runtime type (the type that is used in the C# models) shall be a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"System.Byte[]\"), \" and that the serialization type (the type which client and server use to send the data) shall be a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"System.String\"), \". For the generator that is enough to generate everything accordingly.\"), mdx(\"p\", null, \"We still have to implement an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IValueSerializer\"), \" to specify the logic how the type shall actually serialize and deserialize.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class ByteArrayValueSerializer\\n    : ValueSerializerBase<byte[], string>\\n{\\n    public override string Name => \\\"ByteArray\\\";\\n\\n    public override ValueKind Kind => ValueKind.String;\\n\\n    public override object? Serialize(object? value)\\n    {\\n        if (value is null)\\n        {\\n            return null;\\n        }\\n\\n        if (value is byte[] b)\\n        {\\n            return Convert.ToBase64String(b);\\n        }\\n\\n        throw new ArgumentException(\\n            \\\"The specified value is of an invalid type. \\\" +\\n            $\\\"{ClrType.FullName} was expeceted.\\\");\\n    }\\n\\n    public override object? Deserialize(object? serialized)\\n    {\\n        if (serialized is null)\\n        {\\n            return null;\\n        }\\n\\n        if (serialized is string s)\\n        {\\n            return Convert.FromBase64String(s);\\n        }\\n\\n        throw new ArgumentException(\\n            \\\"The specified value is of an invalid type. \\\" +\\n            $\\\"{SerializationType.FullName} was expeceted.\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"The serializer can be added as a singleton and will be automatically integrated by the generated client.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddSingleton<IValueSerializer, ByteArrayValueSerializer>();\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"We are refining how those serializers are registered. This is important for cases where one wants to have multiple clients with different kinds of serializers. I know this is rare but still this should work. The coming versions of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" will fine tune this.\")), mdx(\"h2\", null, \"Digging Deeper\"), mdx(\"p\", null, \"Apart from being able to add custom scalars we might want to dig deeper and allow new scenarios with our client like persisted queries. It is needles to say that we will add persisted query support out of the box. But it is also a good example to use to show how we can enable advance server / client protocols with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \".\"), mdx(\"p\", null, \"The way we built-in things like that is by providing a operation middleware. This basically works like the query middleware in the server on the request level.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" allows us to swap out the default operation execution pipeline and add our own custom operation execution pipeline.\"), mdx(\"p\", null, \"In order to setup a custom operation execution pipeline you can use for instance the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HttpPipelineBuilder\"), \". Each transport has it`s own transport specific pipeline since the protocol between socket communication and stateless communication is quite different.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"serviceCollection.AddSingleton<OperationDelegate>(\\n    sp => HttpPipelineBuilder.New()\\n        .Use<CreateStandardRequestMiddleware>()\\n        .Use<CustomMiddleware>()\\n        .Use<SendHttpRequestMiddleware>()\\n        .Use<ParseSingleResultMiddleware>()\\n        .Build(sp));\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class CustomMiddleware\\n{\\n    private readonly OperationDelegate _next;\\n    private readonly IOperationSerializer _service;\\n\\n    public CustomMiddleware(\\n        OperationDelegate next,\\n        ISomeCustomService service)\\n    {\\n        _next = next ?? throw new ArgumentNullException(nameof(next));\\n        _service = service ?? throw new ArgumentNullException(nameof(service));\\n    }\\n\\n    public async Task InvokeAsync(IHttpOperationContext context)\\n    {\\n        // the custom middleware code\\n        await _next(context);\\n    }\\n}\\n\")), mdx(\"h2\", null, \"Generation Options\"), mdx(\"p\", null, \"By default \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" generates dependency injection code for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Microsoft.Extensions.DependencyInjection\"), \" this can be switched of by adding the following \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MSBuild\"), \" property \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<GraphQLEnableDI>false</GraphQLEnableDI>\"), \".\"), mdx(\"p\", null, \"The generator will automatically detect if you are using C# 8.0 with nullable reference types or if you are using an older version of C#.\"), mdx(\"p\", null, \"You can use the following \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MSBuild\"), \" properties to control this.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-xml\"\n  }), \"<PropertyGroup>\\n  <LangVersion>8.0</LangVersion>\\n  <Nullable>enable</Nullable>\\n</PropertyGroup>\\n\")), mdx(\"p\", null, \"We also by default take the root namespace from the project for generating files. You can however override this by providing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<BerryNamespace />\"), \" property. However, we will change this to an item group soon in order to also enable multiple clients in a single project to use different namespaces.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-xml\"\n  }), \"<PropertyGroup>\\n  <BerryNamespace>$(RootNamespace)</BerryNamespace>\\n</PropertyGroup>\\n\")), mdx(\"h2\", null, \"Dependency Injection\"), mdx(\"p\", null, \"The client API can be used with other dependency injection container and also without dependency injection at all.\"), mdx(\"p\", null, \"We initially had a limited builder API for this but decided to give it a do over. So, at the moment you could look at the generated dependency injection code and build your own integration.\"), mdx(\"p\", null, \"We will allow with future build to add custom generators that can provide additional code for custom use cases. The way that would work is that such a generator would sit in a NuGet package that is being added to the project. The custom generator would register its generators to an item group and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" would pick those up and integrate them. These custom generators however are somewhere in the version 12 timeframe.\"), mdx(\"h2\", null, \"Roadmap\"), mdx(\"p\", null, \"What are our next steps on \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" and when are we planning to release it?\"), mdx(\"p\", null, \"We have some more ground to cover before we have this version complete.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"MSBuild Integration\\nWe are working on making the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"MSBuild\"), \" integration better. There are still instances with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"VSCode\"), \" where you have to compile twice. This is OK for a preview,but we are on it and think that in the next view preview builds we will have this fixed. With \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Visual Studio for Windows\"), \" you can already enjoy design time code generation. This means that when you save a GraphQL file the generator will update the C# files.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Tooling\\nWe are heavy at work on \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Bananacake Pop\"), \" which is our GraphQL IDE that will help you write and analyze GraphQL queries.\\nWe plan to use what we have done for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Bananacake Pop\"), \" to create a nice integration with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"VSCode\"), \". We want to have a rich integration with which you can work on huge schemas.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Beyond \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"VSCode\"), \" we are looking at writing a nice integration with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Visual Studio for Windows\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Visual Studio for macOS\"), \" that will make \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GraphQL\"), \" a first-class citizen in Microsoft IDEs.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"We hope to deliver all of this in the version 11 timeframe.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Persisted Query Support\\nPersisted queries are one of our very next features that we will add to the client. We want to allow the same flows that we support on the server side.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Batching Support\\nBatching support with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@export\"), \" directive is as well planned for the initial release of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \".\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Code Generation\\nThe current code generation produces quite nice code, but it can produce issues where the types from your own project collide with the generated code. With the next view builds we will add an option to use full type names in those cases.\\nAlso, we will add the code generation attribute to the generated files. So there are refinements going on in this area.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Defer / Stream\\nWe are planning to add support for defer and stream to the client. This feature depends on our server implementation so we will have to see how far we are on execution plans before we can start on it for the client.\"))), mdx(\"p\", null, \"I hope you enjoy what we are building. We are tying to bring GraphQL on .NET to the next level. While we still are miles away from what the JavaScript world has to offer we hope to close these gaps over the next year and even pull ahead in some areas. We love GraphQL and are passionate about it. We strongly believe that with our newest member \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" we really can make things like \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Xamarin\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Blazor\"), \" so much better. We have planned a lot more and hope to bring data fetching in .NET to a whole new level over the next year. Ideally you just want to decalre in your .NET component the data that you need and all the client logic is infered from that, kind of the way relay works in JavaScript.\"), mdx(\"p\", null, \"If you want to get into contact with us head over to our slack channel and join our community.\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"readingTime":{"text":"21 min read"}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","author":"Chilli_Cream"}}},"pageContext":{}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}