{"componentChunkName":"component---src-templates-blog-article-template-tsx","path":"/blog/2019/03/19/logging-with-hotchocolate","result":{"data":{"mdx":{"excerpt":"One common question that comes up on our slack channel is if Hot Chocolate supports some kind of logging infrastructure. My personal opinionâ€¦","frontmatter":{"featuredImage":null,"path":"/blog/2019/03/19/logging-with-hotchocolate","title":"GraphQL - Tracing with Hot Chocolate","tags":["hotchocolate","graphql","dotnet","aspnetcore","tracing"],"author":"Michael Staib","authorImageUrl":"https://avatars1.githubusercontent.com/u/9714350?s=100&v=4","authorUrl":"https://github.com/michaelstaib","date":"March 19, 2019"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"path\": \"/blog/2019/03/19/logging-with-hotchocolate\",\n  \"date\": \"2019-03-19\",\n  \"title\": \"GraphQL - Tracing with Hot Chocolate\",\n  \"tags\": [\"hotchocolate\", \"graphql\", \"dotnet\", \"aspnetcore\", \"tracing\"],\n  \"author\": \"Michael Staib\",\n  \"authorUrl\": \"https://github.com/michaelstaib\",\n  \"authorImageUrl\": \"https://avatars1.githubusercontent.com/u/9714350?s=100&v=4\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"One common question that comes up on our slack channel is if Hot Chocolate supports some kind of logging infrastructure. My personal opinion here is that logging/tracing is often very project specific and an API should not force one specific logging solution onto its users.\"), mdx(\"p\", null, \"Instead we have opted to provide diagnostic events through Microsoft`s diagnostic source which does not force us to serialize any payloads. This in turn gives you the ability to pick and choose the information that best fits your need for your tracing/logging solution.\"), mdx(\"p\", null, \"This post will walk you through on how to add a logger of your choice to Hot Chocolate and get exactly the right amount of information for your project.\"), mdx(\"p\", null, \"In this blog we will use the ASP.Net core logging API to show how a logger can be attached to our diagnostic events.\"), mdx(\"h2\", null, \"Setup\"), mdx(\"p\", null, \"But before we can get started let us first setup a web project with Hot Chocolate:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"mkdir logging\\ncd logging\\ndotnet new web\\ndotnet add package HotChocolate.AspNetCore:9.0.0-preview.5\\ndotnet add package HotChocolate.AspNetCore.Playground:9.0.0-preview.5\\n\")), mdx(\"h2\", null, \"Configure the Logger\"), mdx(\"p\", null, \"After our project is setup let us start with setting up the ASP.net core logging infrastructure. This is fairly easy with ASP.net core. Head over to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Program.cs\"), \" and replace the builder configuration with the following one.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public static IWebHostBuilder CreateWebHostBuilder(string[] args) =>\\n    WebHost.CreateDefaultBuilder(args)\\n        .ConfigureLogging((hostingContext, logging) =>\\n        {\\n            logging.ClearProviders();\\n            logging.AddConsole();\\n        })\\n        .UseStartup<Startup>();\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConfigureLogging\"), \" configures the various logging providers that are then available throughout our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WebHost\"), \". In our simple example we clear all the providers and then add only the console logger.\"), mdx(\"p\", null, \"Next head over to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Startup.cs\"), \" and register the logger with the dependency injection by adding the following line to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConfigureServices\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddLogging();\\n\")), mdx(\"p\", null, \"Perfect, now we have setup all the basics and can get started.\"), mdx(\"h2\", null, \"Diagnostic Observer\"), mdx(\"p\", null, \"The Hot Chocolate server provides diagnostic events through a diagnostic source. We can subscribe to these events by providing a diagnostic observer. A diagnostic observer is basically any class that implements our marker interface \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IDiagnosticObserver\"), \".\"), mdx(\"p\", null, \"Into this class we can add public methods that are subscribed to the actual diagnostic listener. The methods that shall subscribe to an event have to be annotated to with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DiagnosticNameAttribute\"), \".\"), mdx(\"p\", null, \"We have listed the various available events and their payloads in our documentation that can be found \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://hotchocolate.io/docs/next/instrumentation\"\n  }), \"here\"), \".\"), mdx(\"p\", null, \"Let us say that in our case we want to write a message to the console whenever a request begins. Moreover, if the request is a query or mutation then we also want to write the result to the console.\"), mdx(\"p\", null, \"Before we add the actual event methods, let us create a class called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DiagnosticObserver\"), \". In order to write events to the logger we need to inject a concrete logger to our class. So, our class could look like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class DiagnosticObserver\\n    : IDiagnosticObserver\\n{\\n    private readonly ILogger _logger;\\n\\n    public DiagnosticObserver(ILogger<DiagnosticObserver> logger)\\n    {\\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\\n    }\\n}\\n\")), mdx(\"p\", null, \"Next, let us add our two event methods.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class DiagnosticObserver\\n        : IDiagnosticObserver\\n{\\n    private readonly ILogger _logger;\\n\\n    public DiagnosticObserver(ILogger<DiagnosticObserver> logger)\\n    {\\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\\n    }\\n\\n    [DiagnosticName(\\\"HotChocolate.Execution.Query\\\")]\\n    public void OnQuery(IQueryContext context)\\n    {\\n        // This method is used as marker to enable begin and end events\\n        // in the case that you want to explicitly track the start and the\\n        // end of this event.\\n    }\\n\\n    [DiagnosticName(\\\"HotChocolate.Execution.Query.Start\\\")]\\n    public void BeginQueryExecute(IQueryContext context)\\n    {\\n        _logger.LogInformation(context.Request.Query);\\n    }\\n\\n    [DiagnosticName(\\\"HotChocolate.Execution.Query.Stop\\\")]\\n    public void EndQueryExecute(IQueryContext context)\\n    {\\n        if(context.Result is IReadOnlyQueryResult result)\\n        {\\n            using (var stream = new MemoryStream())\\n            {\\n                var resultSerializer = new JsonQueryResultSerializer();\\n                resultSerializer.SerializeAsync(\\n                    result, stream).Wait();\\n                _logger.LogInformation(\\n                    Encoding.UTF8.GetString(stream.ToArray()));\\n            }\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"In order to enable start/stop events we have to add a third method that represents the subscription to the event.\"), mdx(\"p\", null, \"This is only needed when subscribing to activities that consist of a start event and a stop event. These start and stop events allow for measuring performance.\"), mdx(\"p\", null, \"Apart from our standard payloads that are described in our documentation we can also inject the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Activity\"), \" instance to your start/stop event and use the high precision time measurement that the diagnostics APIs provide.\"), mdx(\"p\", null, \"The events always provide you with the full context objects that are available in the query and field middleware pipeline. You basically have full access to all the data that you would have access to in a middleware and by this you are able to pick the information you need for your tracing/logging solution and create the logging messages in a structure that fits your needs.\"), mdx(\"p\", null, \"Moreover, you also can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ContextData\"), \" dictionary on the context objects to share information between your subscription events like a request identifier.\"), mdx(\"p\", null, \"After we have implemented our observer, we have to register it as a service.\"), mdx(\"p\", null, \"Add the following line to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConfigureServices\"), \" method in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Startup.cs\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddDiagnosticObserver<DiagnosticObserver>();\\n\")), mdx(\"p\", null, \"With that our logger is ready to receive events. We now just need a GraphQL API that produces events.\"), mdx(\"p\", null, \"For this we add a simple query type:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    public string Hello() => \\\"world\\\";\\n}\\n\")), mdx(\"p\", null, \"Next we register the query type with our schema by adding the following line to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConfigureServices\"), \" method in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Startup.cs\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddGraphQL(c =>\\n{\\n    c.RegisterQueryType<Query>();\\n});\\n\")), mdx(\"p\", null, \"Last but not least we have to add our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GraphQL\"), \" middleware and in order to write some queries our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Playground\"), \" middleware.\"), mdx(\"p\", null, \"Replace the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configure\"), \" method in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Startup.cs\"), \" with the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void Configure(IApplicationBuilder app, IHostingEnvironment env)\\n{\\n    if (env.IsDevelopment())\\n    {\\n        app.UseDeveloperExceptionPage();\\n    }\\n\\n    app.UseGraphQL();\\n    app.UsePlayground();\\n\\n    app.Run(async (context) =>\\n    {\\n        await context.Response.WriteAsync(\\\"Hello World!\\\");\\n    });\\n}\\n\")), mdx(\"p\", null, \"You should now be able to start the GraphQL server.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"dotnet run\\n\")), mdx(\"p\", null, \"The server should be accessible through plaground under the following URL \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"http://127.0.0.1:5000/playground\"), \".\"), mdx(\"p\", null, \"Add the following query and execute it:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  hello\\n}\\n\")), mdx(\"p\", null, \"The query and the result should now be printed to your console.\"), mdx(\"p\", null, \"This is just a simple example of how to subscribe to our diagnostic events. Checkout our documentation for a list of all of the events available \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://hotchocolate.io/docs/next/instrumentation\"\n  }), \"here\"), \".\"), mdx(\"p\", null, \"We have added this example project to our example repo \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/hotchocolate-examples/tree/master/Instrumentation\"\n  }), \"here\"), \".\"), mdx(\"p\", null, \"Also, we have a more complex implementation of a Hot Chocolate ETW event source \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/thor-client/tree/master/src/Clients/HotChocolate\"\n  }), \"here\"), \".\"), mdx(\"p\", null, \"Another example is our \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/hotchocolate/blob/master/src/Core/Core/Execution/Instrumentation/ApolloTracingDiagnosticObserver.cs\"\n  }), \"Apollo Tracing implementation\"), \" that is also based on our instrumentation API.\"), mdx(\"p\", null, \"I hope this little field trip into our instrumentation API gives a little outlook of an often-overlooked feature that is coming with version 9. All of what I showed in this blog is available with preview 5 (9.0.0-preview.5) that we released today.\"), mdx(\"p\", null, \"We will add stitching related events with the next view preview builds.\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"readingTime":{"text":"6 min read"}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","author":"Chilli_Cream"}}},"pageContext":{}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}