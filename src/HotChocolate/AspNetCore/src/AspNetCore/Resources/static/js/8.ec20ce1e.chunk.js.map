{"version":3,"sources":["../../../node_modules/graphql/polyfills/find.mjs","../../../node_modules/node-libs-browser/node_modules/assert/assert.js","../../../node_modules/graphql/type/schema.mjs","../../../node_modules/vscode-languageserver-types/lib/esm/main.js","../../src/autocompleteUtils.ts","../../../node_modules/graphql/utilities/typeComparators.mjs","../../src/CharacterStream.ts","../../src/RuleHelpers.ts","../../src/Rules.ts","../../src/onlineParser.ts","../../src/types.ts","../../src/getAutocompleteSuggestions.ts","../../src/Range.ts","../../../node_modules/graphql/language/predicates.mjs","../../../node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs","../../../node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs","../../../node_modules/graphql/utilities/typeFromAST.mjs","../../../node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs","../../../node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs","../../../node_modules/graphql/validation/rules/KnownDirectivesRule.mjs","../../../node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs","../../../node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs","../../../node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs","../../../node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs","../../../node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs","../../../node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs","../../../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs","../../../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs","../../../node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs","../../../node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs","../../../node_modules/graphql/validation/specifiedRules.mjs","../../../node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs","../../../node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs","../../../node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs","../../../node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs","../../../node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs","../../../node_modules/graphql/validation/rules/ScalarLeafsRule.mjs","../../../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs","../../../node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs","../../../node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs","../../../node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs","../../../node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs","../../../node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs","../../../node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs","../../../node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs","../../../node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs","../../../node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs","../../../node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs","../../../node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs","../../../node_modules/graphql/polyfills/flatMap.mjs","../../../node_modules/graphql/utilities/assertValidName.mjs","../../../node_modules/graphql/type/validate.mjs","../../../node_modules/graphql/error/locatedError.mjs","../../../node_modules/graphql/utilities/TypeInfo.mjs","../../../node_modules/graphql/validation/ValidationContext.mjs","../../../node_modules/graphql/validation/validate.mjs","../../src/validateWithCustomRules.ts","../../../node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs","../../../node_modules/graphql/utilities/findDeprecatedUsages.mjs","../../src/getDiagnostics.ts","../../src/getOutline.ts","../../src/getHoverInformation.ts","../../src/GraphQLLanguageService.ts","../../src/client.ts","../../../node_modules/symbol-observable/es/ponyfill.js","../../../node_modules/node-libs-browser/node_modules/util/util.js","../../../node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js","../../../node_modules/node-libs-browser/node_modules/inherits/inherits_browser.js","../../../node_modules/whatwg-fetch/fetch.js","../../../node_modules/backo2/index.js","../../../node_modules/eventemitter3/index.js","../../../src/utils/is-string.ts","../../../src/utils/is-object.ts","../../../node_modules/graphql/utilities/getOperationAST.mjs","../../../node_modules/symbol-observable/es/index.js","../../../node_modules/webpack/buildin/harmony-module.js","../../src/protocol.ts","../../src/defaults.ts","../../src/message-types.ts","../../../../src/internal/operators/filter.ts","../../../node_modules/graphql/utilities/valueFromAST.mjs","../../../node_modules/graphql/utilities/buildClientSchema.mjs"],"names":["find","Array","prototype","list","predicate","call","_i2","length","value","objectAssign","require","compare","a","b","x","y","i","len","Math","min","isBuffer","global","Buffer","_isBuffer","util","hasOwn","Object","hasOwnProperty","pSlice","slice","functionsHaveNames","name","pToString","obj","toString","isView","arrbuf","ArrayBuffer","DataView","buffer","assert","module","exports","ok","regex","getName","func","isFunction","match","truncate","s","n","inspect","something","rawname","fail","actual","expected","message","operator","stackStartFunction","AssertionError","_deepEqual","strict","memos","isDate","getTime","isRegExp","source","multiline","lastIndex","ignoreCase","Float32Array","Float64Array","Uint8Array","actualIndex","indexOf","push","actualVisitedObjects","undefined","isPrimitive","getPrototypeOf","aIsArgs","isArguments","bIsArgs","key","ka","objectKeys","kb","sort","objEquiv","object","expectedException","test","e","Error","isPrototypeOf","_throws","shouldThrow","block","TypeError","error","_tryBlock","userProvidedMessage","isUnexpectedException","isError","options","this","generatedMessage","self","getMessage","captureStackTrace","err","stack","out","fn_name","idx","next_line","substring","inherits","equal","notEqual","deepEqual","deepStrictEqual","notDeepEqual","notDeepStrictEqual","strictEqual","notStrictEqual","throws","doesNotThrow","ifError","keys","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","assertSchema","schema","instanceOf","GraphQLSchema","isSchema","concat","config","_config$directives","__validationErrors","assumeValid","isObjectLike","devAssert","types","isArray","directives","description","extensions","toObjMap","astNode","extensionASTNodes","_queryType","query","_mutationType","mutation","_subscriptionType","subscription","_directives","specifiedDirectives","allReferencedTypes","Set","_config$types2","type","delete","collectReferencedTypes","_i4","_this$_directives2","directive","isDirective","_i6","_directive$args2","args","__Schema","_typeMap","create","_subTypeMap","_implementationsMap","_i8","_arrayFrom2","arrayFrom","namedType","typeName","isInterfaceType","_i10","_namedType$getInterfa2","getInterfaces","iface","implementations","objects","interfaces","isObjectType","_i12","_namedType$getInterfa4","_iface","_implementations","Constructor","protoProps","staticProps","_proto","getQueryType","getMutationType","getSubscriptionType","getTypeMap","getType","getPossibleTypes","abstractType","isUnionType","getTypes","getImplementations","interfaceType","isPossibleType","possibleType","isSubType","maybeSubType","map","_i14","_abstractType$getType2","_i16","_implementations$obje2","_i18","_implementations$inte2","getDirectives","getDirective","toConfig","_this$extensionASTNod","objectValues","SYMBOL_TO_STRING_TAG","get","typeSet","getNamedType","has","add","_i20","_namedType$getTypes2","_i22","_namedType$getInterfa6","_i24","_objectValues2","getFields","field","_i26","_field$args2","isInputObjectType","_i28","_objectValues4","Position","Range","Location","LocationLink","Color","ColorInformation","ColorPresentation","FoldingRangeKind","FoldingRange","DiagnosticRelatedInformation","DiagnosticSeverity","DiagnosticTag","Diagnostic","Command","TextEdit","TextDocumentEdit","CreateFile","RenameFile","DeleteFile","WorkspaceEdit","line","character","is","candidate","Is","objectLiteral","number","one","two","three","four","start","end","uri","range","defined","string","targetUri","targetRange","targetSelectionRange","originSelectionRange","red","green","blue","alpha","color","label","textEdit","additionalTextEdits","typedArray","startLine","endLine","startCharacter","endCharacter","kind","result","location","Warning","Information","Hint","Unnecessary","Deprecated","severity","code","relatedInformation","title","command","_i","arguments","replace","newText","insert","position","del","textDocument","edits","VersionedTextDocumentIdentifier","overwrite","ignoreIfExists","boolean","oldUri","newUri","recursive","ignoreIfNotExists","changes","documentChanges","every","change","TextDocumentIdentifier","TextDocumentItem","MarkupKind","MarkupContent","CompletionItemKind","InsertTextFormat","CompletionItemTag","CompletionItem","CompletionList","MarkedString","Hover","ParameterInformation","SignatureInformation","DocumentHighlightKind","DocumentHighlight","SymbolKind","SymbolTag","SymbolInformation","DocumentSymbol","CodeActionKind","CodeActionContext","CodeAction","CodeLens","FormattingOptions","DocumentLink","SelectionRange","TextEditChangeImpl","edit","all","clear","splice","WorkspaceChange","workspaceEdit","_this","_textEditChanges","_workspaceEdit","forEach","textEditChange","getTextEditChange","textDocumentEdit","createFile","checkDocumentChanges","renameFile","deleteFile","version","languageId","text","PlainText","Markdown","Text","Method","Function","Field","Variable","Class","Interface","Module","Property","Unit","Value","Enum","Keyword","Snippet","File","Reference","Folder","EnumMember","Constant","Struct","Event","Operator","TypeParameter","items","isIncomplete","fromPlainText","plainText","language","contents","documentation","parameters","Read","Write","Namespace","Package","String","Number","Boolean","Key","Null","containerName","detail","selectionRange","children","deprecated","Empty","QuickFix","Refactor","RefactorExtract","RefactorInline","RefactorRewrite","Source","SourceOrganizeImports","SourceFixAll","diagnostics","only","commandOrEdit","isPreferred","data","tabSize","insertSpaces","parent","TextDocument","content","FullTextDocument","lineCount","getText","positionAt","offsetAt","applyEdits","document","sortedEdits","mergeSort","p","left","right","leftIdx","rightIdx","ret","diff","lastModifiedOffset","startOffset","endOffset","_uri","_languageId","_version","_content","_lineOffsets","update","event","getLineOffsets","lineOffsets","isLineStart","ch","charAt","offset","max","low","high","mid","floor","lineOffset","nextLineOffset","check","isEqualType","typeA","typeB","isNonNullType","isListType","ofType","isTypeSubTypeOf","superType","isAbstractType","doTypesOverlap","some","isExecutableDefinitionNode","node","Kind","OPERATION_DEFINITION","FRAGMENT_DEFINITION","isTypeSystemDefinitionNode","SCHEMA_DEFINITION","isTypeDefinitionNode","DIRECTIVE_DEFINITION","SCALAR_TYPE_DEFINITION","OBJECT_TYPE_DEFINITION","INTERFACE_TYPE_DEFINITION","UNION_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","isTypeSystemExtensionNode","SCHEMA_EXTENSION","isTypeExtensionNode","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","ExecutableDefinitionsRule","context","Document","_node$definitions2","definitions","definition","defName","reportError","GraphQLError","KnownTypeNamesRule","getSchema","existingTypesMap","definedTypes","_context$getDocument$2","getDocument","def","typeNames","NamedType","_1","_2","ancestors","_ancestors$","definitionNode","isSDL","standardTypeNames","isStandardTypeName","suggestedTypes","suggestionList","didYouMean","specifiedScalarTypes","introspectionTypes","typeFromAST","typeNode","innerType","LIST_TYPE","GraphQLList","NON_NULL_TYPE","GraphQLNonNull","NAMED_TYPE","invariant","KnownFragmentNamesRule","FragmentSpread","fragmentName","getFragment","NoUnusedFragmentsRule","operationDefs","fragmentDefs","OperationDefinition","FragmentDefinition","leave","fragmentNameUsed","operation","_context$getRecursive2","getRecursivelyReferencedFragments","fragmentDef","fragName","KnownDirectivesRule","locationsMap","definedDirectives","locations","astDefinitions","Directive","_key","_parent","_path","candidateLocation","appliedTo","DirectiveLocation","QUERY","MUTATION","SUBSCRIPTION","getDirectiveLocationForOperation","FIELD","FRAGMENT_SPREAD","INLINE_FRAGMENT","VARIABLE_DEFINITION","SCHEMA","SCALAR","OBJECT","FIELD_DEFINITION","INTERFACE","UNION","ENUM","ENUM_VALUE_DEFINITION","ENUM_VALUE","INPUT_OBJECT","INPUT_VALUE_DEFINITION","INPUT_FIELD_DEFINITION","ARGUMENT_DEFINITION","getDirectiveLocationForASTPath","UniqueDirectivesPerLocationRule","uniqueDirectiveMap","isRepeatable","repeatable","schemaDirectives","typeDirectivesMap","enter","seenDirectives","_node$directives2","_directive","directiveName","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","apply","_objectSpread","_defineProperty","getOwnPropertyDescriptors","defineProperties","KnownArgumentNamesOnDirectivesRule","directiveArgs","arg","_def$arguments","argsNodes","directiveNode","knownArgs","_directiveNode$argume2","argNode","argName","suggestions","UniqueArgumentNamesRule","knownArgNames","Argument","isValidValueNode","locationType","getInputType","isLeafType","parseLiteral","_typeStr","print","_typeStr2","typeStr","ProvidedRequiredArgumentsOnDirectivesRule","requiredArgsMap","keyMap","isRequiredArgument","argNodes","isRequiredArgumentNode","requiredArgs","_directiveNode$argume","_argNodes","argNodeMap","_Object$keys2","argType","argTypeStr","isType","defaultValue","allowedVariableUsage","varType","varDefaultValue","locationDefaultValue","NULL","reasonMessage","reason","_ref","responseName","subReason","join","collectConflictsBetweenFieldsAndFragment","conflicts","cachedFieldsAndFragmentNames","comparedFragmentPairs","areMutuallyExclusive","fieldMap","fragment","_getReferencedFieldsA","getReferencedFieldsAndFragmentNames","fieldMap2","fragmentNames2","collectConflictsBetween","collectConflictsBetweenFragments","fragmentName1","fragmentName2","fragment1","fragment2","_getReferencedFieldsA2","fieldMap1","fragmentNames1","_getReferencedFieldsA3","j","parentFieldsAreMutuallyExclusive","_i7","fields2","fields1","conflict","findConflict","field1","field2","parentType1","node1","def1","parentType2","node2","def2","_node1$arguments","_node2$arguments","name1","name2","arguments1","arguments2","argument1","value1","value2","argument2","argument","sameArguments","type1","type2","doTypesConflict","selectionSet1","selectionSet","selectionSet2","_ref6","reduce","allFields","_ref7","_ref8","subfieldConflicts","_getFieldsAndFragment2","getFieldsAndFragmentNames","_getFieldsAndFragment3","_i3","_j","findConflictsBetweenSubSelectionSets","parentType","cached","nodeAndDefs","fragmentNames","_collectFieldsAndFragmentNames","_i9","_selectionSet$selecti2","selections","selection","fieldName","fieldDef","alias","typeCondition","inlineFragmentType","set","fragmentType","_defKindToExtKind","PairSet","_data","first","_pairSetAdd","UniqueInputFieldNamesRule","knownNameStack","knownNames","ObjectValue","pop","ObjectField","hasField","defKindToExtKind","specifiedRules","freeze","knownOperationNames","operationName","operationCount","InlineFragment","isCompositeType","VariableDefinition","isInputType","variableName","variable","_fieldName","getParentType","getFieldDef","suggestion","usageCount","_schema$getPossibleTy2","_possibleType$getInte2","_usageCount$possibleI","possibleInterface","usageCountDiff","localeCompare","getSuggestedTypeNames","possibleFieldNames","getSuggestedFieldNames","knownFragmentNames","fragType","parentTypeStr","fragTypeStr","frag","getFragmentType","visitedFrags","spreadPath","spreadPathIndexByName","detectCycleRecursive","spreadNodes","getFragmentSpreads","spreadNode","spreadName","cycleIndex","spreadFragment","cyclePath","viaPath","knownVariableNames","variableNameDefined","usages","getRecursiveVariableUsages","varName","variableDefs","variableNameUsed","_variableDefs2","variableDef","argDef","getArgument","knownArgsNames","ListValue","getNullableType","getParentInputType","fieldNodeMap","fields","isRequiredInputField","NullValue","EnumValue","IntValue","FloatValue","StringValue","BooleanValue","fieldNode","_fieldNode$arguments","_fieldDef$args2","varDefMap","_ref2","varDef","varTypeStr","Map","SelectionSet","_getFieldsAndFragment","_i5","_objectEntries2","objectEntries","_ref5","collectConflictsWithin","findConflictsWithinSelectionSet","_ref3","_ref2$","reasonMsg","_oldSchema$astNode","oldSchema","alreadyDefined","schemaDefinitionsCount","SchemaDefinition","definedOperationTypes","existingOperationTypes","checkOperationTypes","SchemaExtension","_node$operationTypes","operationTypesNodes","operationTypes","operationType","alreadyDefinedOperationType","knownTypeNames","ScalarTypeDefinition","checkTypeName","ObjectTypeDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","InputObjectTypeDefinition","existingTypeMap","knownValueNames","checkValueUniqueness","EnumTypeExtension","_node$values","valueNodes","values","valueNames","valueDef","valueName","existingType","isEnumType","getValue","knownFieldNames","checkFieldUniqueness","InputObjectTypeExtension","InterfaceTypeExtension","ObjectTypeExtension","_node$fields","fieldNodes","fieldNames","knownDirectiveNames","DirectiveDefinition","ScalarTypeExtension","checkExtension","UnionTypeExtension","expectedKind","defNode","isScalarType","typeToExtKind","kindStr","extensionKindToTypeName","allTypeNames","flatMapMethod","flatMap","fn","NAME_RX","isValidNameError","validateSchema","SchemaValidationContext","queryType","_getOperationTypeNode","getOperationTypeNode","_getOperationTypeNode2","mutationType","_getOperationTypeNode3","subscriptionType","validateRootTypes","_context$schema$getDi2","validateName","validateDirectives","validateInputObjectCircularRefs","visitedTypes","fieldPath","fieldPathIndexByTypeName","inputObj","_i30","fieldType","pathStr","fieldObj","createInputObjectCircularRefsValidator","typeMap","isNamedType","isIntrospectionType","validateFields","validateInterfaces","validateUnionMembers","validateEnumValues","validateInputFields","validateTypes","errors","getErrors","assertValidSchema","_errors","nodes","_nodes","addError","operationNodes","getAllSubNodes","originalError","path","positions","locatedError","getAllNodes","_field$astNode","isOutputType","_arg$astNode","ifaceTypeNames","_type$getInterfaces2","getAllImplementsInterfaceNodes","validateTypeImplementsAncestors","validateTypeImplementsInterface","typeFieldMap","ifaceField","typeField","_ifaceField$astNode","_typeField$astNode","_loop","_ifaceField$args2","_ifaceArg$astNode","_typeArg$astNode","ifaceArg","typeArg","_loop2","_typeField$args2","ifaceInterfaces","_iface$getInterfaces2","transitive","union","memberTypes","includedTypeNames","memberType","getUnionMemberTypeNodes","enumType","enumValues","getValues","enumValue","_field$astNode2","getter","item","_getter","ifaceNode","unionNode","TypeInfo","getFieldDefFn","initialType","_schema","_typeStack","_parentTypeStack","_inputTypeStack","_fieldDefStack","_defaultValueStack","_argument","_enumValue","_getFieldDef","getDefaultValue","getEnumValue","SELECTION_SET","DIRECTIVE","typeConditionAST","outputType","inputType","ARGUMENT","_this$getDirective","fieldOrDirective","LIST","listType","itemType","OBJECT_FIELD","inputFieldType","inputField","objectType","SchemaMetaFieldDef","TypeMetaFieldDef","TypeNameMetaFieldDef","visitWithTypeInfo","typeInfo","visitor","getVisitFn","isNode","_inheritsLoose","subClass","superClass","constructor","__proto__","ASTValidationContext","ast","onError","_ast","_fragments","_fragmentSpreads","_recursivelyReferencedFragments","_onError","fragments","frags","statement","spreads","setsToVisit","_set$selections2","collectedNames","nodesToVisit","_this$getFragmentSpre2","ValidationContext","_ASTValidationContext2","_this2","_typeInfo","_variableUsages","_recursiveVariableUsages","_proto3","getVariableUsages","newUsages","visit","_this$getRecursivelyR2","validate","documentAST","rules","maxErrors","abortObj","visitInParallel","rule","NoDeprecatedCustomRule","deprecationReason","findDeprecatedUsages","_global","window","NativeWebSocket","WebSocket","MozWebSocket","url","webSocketImpl","webSocketProtocols","connectionCallback","connectionParams","minTimeout","MIN_WS_TIMEOUT","timeout","WS_TIMEOUT","reconnect","reconnectionAttempts","Infinity","lazy","inactivityTimeout","wsOptionArguments","wsImpl","wsProtocols","GRAPHQL_WS","operations","nextOperationId","minWsTimeout","wsTimeout","unsentMessagesQueue","reconnecting","closedByUser","backoff","Backoff","jitter","eventEmitter","EventEmitter","middlewares","client","maxConnectTimeGenerator","createMaxConnectTimeGenerator","getConnectionParams","connect","CLOSED","readyState","close","isForced","clearInactivityTimeout","clearCheckConnectionInterval","clearMaxConnectTimeout","clearTryReconnectTimeout","unsubscribeAll","sendMessage","GQL_CONNECTION_TERMINATE","onopen","onclose","onerror","onmessage","emit","tryReconnect","request","opId","getObserver","bind","executeOperation","unsubscribe","subscribe","observerOrNext","onComplete","observer","complete","next","on","eventName","callback","handler","off","onConnected","onConnecting","onDisconnected","onReconnected","onReconnecting","subId","applyMiddlewares","Promise","resolve","reject","funcs","scope","f","shift","applyMiddleware","use","middleware","generateOperationId","then","processedOptions","checkOperationOptions","GQL_START","catch","formatErrors","v","minValue","maxValue","factor","checkConnectionIntervalId","clearInterval","maxConnectTimeoutId","clearTimeout","tryReconnectTimeoutId","inactivityTimeoutId","setInactivityTimeout","setTimeout","variables","getOperationAST","buildMessage","id","payload","sendMessageRaw","status","OPEN","serializedMessage","JSON","stringify","parse","send","CONNECTING","attempts","delay","duration","flushUnsentMessagesQueue","checkConnection","wasKeepAliveReceived","checkMaxConnectTimeout","GQL_CONNECTION_INIT","GQL_CONNECTION_ERROR","processReceivedData","receivedData","parsedMessage","GQL_DATA","GQL_COMPLETE","GQL_ERROR","GQL_CONNECTION_ACK","reset","parsedPayload","GQL_CONNECTION_KEEP_ALIVE","firstKA","setInterval","GQL_STOP","SubscriptionClient","symbolObservablePonyfill","root","Symbol","observable","descriptors","formatRegExp","format","isString","str","_","isNull","isObject","deprecate","msg","process","noDeprecation","warned","throwDeprecation","traceDeprecation","console","trace","debugEnviron","debugs","opts","ctx","seen","stylize","stylizeNoColor","depth","colors","isBoolean","showHidden","_extend","isUndefined","customInspect","stylizeWithColor","formatValue","styleType","style","styles","recurseTimes","primitive","simple","isNumber","formatPrimitive","visibleKeys","array","hash","val","arrayToHash","getOwnPropertyNames","formatError","RegExp","Date","output","base","braces","toUTCString","l","formatProperty","formatArray","prev","cur","numLinesEst","reduceToSingleString","desc","split","substr","ar","re","objectToString","d","o","pad","debuglog","NODE_DEBUG","toUpperCase","pid","isNullOrUndefined","isSymbol","months","timestamp","time","getHours","getMinutes","getSeconds","getDate","getMonth","prop","log","origin","kCustomPromisifiedSymbol","callbackifyOnRejected","cb","newReason","promisify","original","promiseResolve","promiseReject","promise","setPrototypeOf","custom","callbackify","callbackified","maybeCb","nextTick","rej","copy","fill","readUInt8","ctor","superCtor","super_","TempCtor","globalThis","support","Blob","viewClasses","isArrayBufferView","normalizeName","toLowerCase","normalizeValue","iteratorFor","iterator","done","Headers","headers","append","header","consumed","body","bodyUsed","fileReaderReady","reader","onload","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","bufferClone","buf","view","byteLength","Body","_initBody","_bodyInit","_bodyText","_bodyBlob","FormData","_bodyFormData","URLSearchParams","_bodyArrayBuffer","rejected","arrayBuffer","isConsumed","byteOffset","readAsText","readBlobAsText","chars","fromCharCode","readArrayBufferAsText","formData","decode","json","oldValue","thisArg","entries","methods","Request","input","credentials","method","mode","signal","upcased","normalizeMethod","referrer","cache","reParamSearch","form","trim","bytes","decodeURIComponent","parseHeaders","rawHeaders","parts","Response","bodyInit","statusText","clone","response","redirectStatuses","redirect","RangeError","DOMException","fetch","init","aborted","xhr","XMLHttpRequest","abortXhr","abort","getAllResponseHeaders","responseURL","responseText","ontimeout","onabort","open","href","fixUrl","withCredentials","responseType","setRequestHeader","addEventListener","onreadystatechange","removeEventListener","polyfill","ms","pow","rand","random","deviation","setMin","setMax","setJitter","prefix","Events","EE","once","addListener","emitter","listener","evt","_events","_eventsCount","clearEvent","eventNames","events","names","listeners","handlers","ee","listenerCount","a1","a2","a3","a4","a5","removeListener","removeAllListeners","prefixed","_documentAST$definiti2","_definition$name","ponyfill","originalModule","webpackPolyfill","GRAPHQL_SUBSCRIPTIONS","SUBSCRIPTION_START","SUBSCRIPTION_DATA","SUBSCRIPTION_SUCCESS","SUBSCRIPTION_FAIL","SUBSCRIPTION_END","INIT","INIT_SUCCESS","INIT_FAIL","KEEP_ALIVE","MessageTypes","isMissingVariable","valueNode","VARIABLE","buildClientSchema","introspection","__schema","schemaIntrospection","keyValMap","typeIntrospection","TypeKind","scalarIntrospection","GraphQLScalarType","specifiedByUrl","objectIntrospection","GraphQLObjectType","buildImplementationsList","buildFieldDefMap","interfaceIntrospection","GraphQLInterfaceType","unionIntrospection","possibleTypes","unionIntrospectionStr","GraphQLUnionType","getObjectType","buildUnionDef","enumIntrospection","enumIntrospectionStr","GraphQLEnumType","valueIntrospection","buildEnumDef","inputObjectIntrospection","inputFields","inputObjectIntrospectionStr","GraphQLInputObjectType","buildInputValueDefMap","buildInputObjectDef","buildType","stdType","directiveIntrospection","directiveIntrospectionStr","_directiveIntrospectionStr","GraphQLDirective","typeRef","itemRef","NON_NULL","nullableRef","nullableType","assertNullableType","assertObjectType","getInterfaceType","assertInterfaceType","implementingIntrospection","implementingIntrospectionStr","fieldIntrospection","buildField","fieldIntrospectionStr","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","valueFromAST","variableValue","coercedValues","_valueNode$values2","itemNode","itemValue","coercedValue","coercedObj","fieldValue","_error","parseValue"],"mappings":"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","file":"static/js/8.ec20ce1e.chunk.js","sourcesContent":["/* eslint-disable no-redeclare */\n// $FlowFixMe\nvar find = Array.prototype.find ? function (list, predicate) {\n  return Array.prototype.find.call(list, predicate);\n} : function (list, predicate) {\n  for (var _i2 = 0; _i2 < list.length; _i2++) {\n    var value = list[_i2];\n\n    if (predicate(value)) {\n      return value;\n    }\n  }\n};\nexport default find;\n","'use strict';\n\nvar objectAssign = require('object-assign');\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n// NB: The URL to the CommonJS spec is kept just for tradition.\n//     node-assert has evolved a lot since then, both in API and behavior.\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util/');\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\n// Expose a strict only variant of assert\nfunction strict(value, message) {\n  if (!value) fail(value, true, message, '==', strict);\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n","function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport find from \"../polyfills/find.mjs\";\nimport arrayFrom from \"../polyfills/arrayFrom.mjs\";\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport { SYMBOL_TO_STRING_TAG } from \"../polyfills/symbols.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport toObjMap from \"../jsutils/toObjMap.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport instanceOf from \"../jsutils/instanceOf.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport { __Schema } from \"./introspection.mjs\";\nimport { GraphQLDirective, isDirective, specifiedDirectives } from \"./directives.mjs\";\nimport { isObjectType, isInterfaceType, isUnionType, isInputObjectType, getNamedType } from \"./definition.mjs\";\n/**\n * Test if the given value is a GraphQL schema.\n */\n\n// eslint-disable-next-line no-redeclare\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\nexport function assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(\"Expected \".concat(inspect(schema), \" to be a GraphQL schema.\"));\n  }\n\n  return schema;\n}\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n *     const characterInterface = new GraphQLInterfaceType({\n *       name: 'Character',\n *       ...\n *     });\n *\n *     const humanType = new GraphQLObjectType({\n *       name: 'Human',\n *       interfaces: [characterInterface],\n *       ...\n *     });\n *\n *     const droidType = new GraphQLObjectType({\n *       name: 'Droid',\n *       interfaces: [characterInterface],\n *       ...\n *     });\n *\n *     const schema = new GraphQLSchema({\n *       query: new GraphQLObjectType({\n *         name: 'Query',\n *         fields: {\n *           hero: { type: characterInterface, ... },\n *         }\n *       }),\n *       ...\n *       // Since this schema references only the `Character` interface it's\n *       // necessary to explicitly list the types that implement it if\n *       // you want them to be included in the final schema.\n *       types: [humanType, droidType],\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\n\nexport var GraphQLSchema = /*#__PURE__*/function () {\n  // Used as a cache for validateSchema().\n  function GraphQLSchema(config) {\n    var _config$directives;\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\n\n    isObjectLike(config) || devAssert(0, 'Must provide configuration object.');\n    !config.types || Array.isArray(config.types) || devAssert(0, \"\\\"types\\\" must be Array if provided but got: \".concat(inspect(config.types), \".\"));\n    !config.directives || Array.isArray(config.directives) || devAssert(0, '\"directives\" must be Array if provided but got: ' + \"\".concat(inspect(config.directives), \".\"));\n    this.description = config.description;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n\n    var allReferencedTypes = new Set(config.types);\n\n    if (config.types != null) {\n      for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {\n        var type = _config$types2[_i2];\n        // When we ready to process this type, we remove it from \"collected\" types\n        // and then add it together with all dependent types in the correct position.\n        allReferencedTypes.delete(type);\n        collectReferencedTypes(type, allReferencedTypes);\n      }\n    }\n\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n\n    for (var _i4 = 0, _this$_directives2 = this._directives; _i4 < _this$_directives2.length; _i4++) {\n      var directive = _this$_directives2[_i4];\n\n      // Directives are not validated until validateSchema() is called.\n      if (isDirective(directive)) {\n        for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {\n          var arg = _directive$args2[_i6];\n          collectReferencedTypes(arg.type, allReferencedTypes);\n        }\n      }\n    }\n\n    collectReferencedTypes(__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = Object.create(null);\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementationsMap = Object.create(null);\n\n    for (var _i8 = 0, _arrayFrom2 = arrayFrom(allReferencedTypes); _i8 < _arrayFrom2.length; _i8++) {\n      var namedType = _arrayFrom2[_i8];\n\n      if (namedType == null) {\n        continue;\n      }\n\n      var typeName = namedType.name;\n      typeName || devAssert(0, 'One of the provided types for building the Schema is missing a name.');\n\n      if (this._typeMap[typeName] !== undefined) {\n        throw new Error(\"Schema must contain uniquely named types but contains multiple types named \\\"\".concat(typeName, \"\\\".\"));\n      }\n\n      this._typeMap[typeName] = namedType;\n\n      if (isInterfaceType(namedType)) {\n        // Store implementations by interface.\n        for (var _i10 = 0, _namedType$getInterfa2 = namedType.getInterfaces(); _i10 < _namedType$getInterfa2.length; _i10++) {\n          var iface = _namedType$getInterfa2[_i10];\n\n          if (isInterfaceType(iface)) {\n            var implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n\n            implementations.interfaces.push(namedType);\n          }\n        }\n      } else if (isObjectType(namedType)) {\n        // Store implementations by objects.\n        for (var _i12 = 0, _namedType$getInterfa4 = namedType.getInterfaces(); _i12 < _namedType$getInterfa4.length; _i12++) {\n          var _iface = _namedType$getInterfa4[_i12];\n\n          if (isInterfaceType(_iface)) {\n            var _implementations = this._implementationsMap[_iface.name];\n\n            if (_implementations === undefined) {\n              _implementations = this._implementationsMap[_iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n\n            _implementations.objects.push(namedType);\n          }\n        }\n      }\n    }\n  }\n\n  var _proto = GraphQLSchema.prototype;\n\n  _proto.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n\n  _proto.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n\n  _proto.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n\n  _proto.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n\n  _proto.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n\n  _proto.getPossibleTypes = function getPossibleTypes(abstractType) {\n    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;\n  };\n\n  _proto.getImplementations = function getImplementations(interfaceType) {\n    var implementations = this._implementationsMap[interfaceType.name];\n    return implementations !== null && implementations !== void 0 ? implementations : {\n      objects: [],\n      interfaces: []\n    };\n  } // @deprecated: use isSubType instead - will be removed in v16.\n  ;\n\n  _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    return this.isSubType(abstractType, possibleType);\n  };\n\n  _proto.isSubType = function isSubType(abstractType, maybeSubType) {\n    var map = this._subTypeMap[abstractType.name];\n\n    if (map === undefined) {\n      map = Object.create(null);\n\n      if (isUnionType(abstractType)) {\n        for (var _i14 = 0, _abstractType$getType2 = abstractType.getTypes(); _i14 < _abstractType$getType2.length; _i14++) {\n          var type = _abstractType$getType2[_i14];\n          map[type.name] = true;\n        }\n      } else {\n        var implementations = this.getImplementations(abstractType);\n\n        for (var _i16 = 0, _implementations$obje2 = implementations.objects; _i16 < _implementations$obje2.length; _i16++) {\n          var _type = _implementations$obje2[_i16];\n          map[_type.name] = true;\n        }\n\n        for (var _i18 = 0, _implementations$inte2 = implementations.interfaces; _i18 < _implementations$inte2.length; _i18++) {\n          var _type2 = _implementations$inte2[_i18];\n          map[_type2.name] = true;\n        }\n      }\n\n      this._subTypeMap[abstractType.name] = map;\n    }\n\n    return map[maybeSubType.name] !== undefined;\n  };\n\n  _proto.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n\n  _proto.getDirective = function getDirective(name) {\n    return find(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n\n  _proto.toConfig = function toConfig() {\n    var _this$extensionASTNod;\n\n    return {\n      description: this.description,\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: objectValues(this.getTypeMap()),\n      directives: this.getDirectives().slice(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: (_this$extensionASTNod = this.extensionASTNodes) !== null && _this$extensionASTNod !== void 0 ? _this$extensionASTNod : [],\n      assumeValid: this.__validationErrors !== undefined\n    };\n  } // $FlowFixMe Flow doesn't support computed properties yet\n  ;\n\n  _createClass(GraphQLSchema, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'GraphQLSchema';\n    }\n  }]);\n\n  return GraphQLSchema;\n}();\n\nfunction collectReferencedTypes(type, typeSet) {\n  var namedType = getNamedType(type);\n\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n\n    if (isUnionType(namedType)) {\n      for (var _i20 = 0, _namedType$getTypes2 = namedType.getTypes(); _i20 < _namedType$getTypes2.length; _i20++) {\n        var memberType = _namedType$getTypes2[_i20];\n        collectReferencedTypes(memberType, typeSet);\n      }\n    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {\n      for (var _i22 = 0, _namedType$getInterfa6 = namedType.getInterfaces(); _i22 < _namedType$getInterfa6.length; _i22++) {\n        var interfaceType = _namedType$getInterfa6[_i22];\n        collectReferencedTypes(interfaceType, typeSet);\n      }\n\n      for (var _i24 = 0, _objectValues2 = objectValues(namedType.getFields()); _i24 < _objectValues2.length; _i24++) {\n        var field = _objectValues2[_i24];\n        collectReferencedTypes(field.type, typeSet);\n\n        for (var _i26 = 0, _field$args2 = field.args; _i26 < _field$args2.length; _i26++) {\n          var arg = _field$args2[_i26];\n          collectReferencedTypes(arg.type, typeSet);\n        }\n      }\n    } else if (isInputObjectType(namedType)) {\n      for (var _i28 = 0, _objectValues4 = objectValues(namedType.getFields()); _i28 < _objectValues4.length; _i28++) {\n        var _field = _objectValues4[_i28];\n        collectReferencedTypes(_field.type, typeSet);\n      }\n    }\n  }\n\n  return typeSet;\n}\n","/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\n/**\r\n * The Position namespace provides helper functions to work with\r\n * [Position](#Position) literals.\r\n */\r\nexport var Position;\r\n(function (Position) {\r\n    /**\r\n     * Creates a new Position literal from the given line and character.\r\n     * @param line The position's line.\r\n     * @param character The position's character.\r\n     */\r\n    function create(line, character) {\r\n        return { line: line, character: character };\r\n    }\r\n    Position.create = create;\r\n    /**\r\n     * Checks whether the given liternal conforms to the [Position](#Position) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(candidate) && Is.number(candidate.line) && Is.number(candidate.character);\r\n    }\r\n    Position.is = is;\r\n})(Position || (Position = {}));\r\n/**\r\n * The Range namespace provides helper functions to work with\r\n * [Range](#Range) literals.\r\n */\r\nexport var Range;\r\n(function (Range) {\r\n    function create(one, two, three, four) {\r\n        if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {\r\n            return { start: Position.create(one, two), end: Position.create(three, four) };\r\n        }\r\n        else if (Position.is(one) && Position.is(two)) {\r\n            return { start: one, end: two };\r\n        }\r\n        else {\r\n            throw new Error(\"Range#create called with invalid arguments[\" + one + \", \" + two + \", \" + three + \", \" + four + \"]\");\r\n        }\r\n    }\r\n    Range.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Range](#Range) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\r\n    }\r\n    Range.is = is;\r\n})(Range || (Range = {}));\r\n/**\r\n * The Location namespace provides helper functions to work with\r\n * [Location](#Location) literals.\r\n */\r\nexport var Location;\r\n(function (Location) {\r\n    /**\r\n     * Creates a Location literal.\r\n     * @param uri The location's uri.\r\n     * @param range The location's range.\r\n     */\r\n    function create(uri, range) {\r\n        return { uri: uri, range: range };\r\n    }\r\n    Location.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Location](#Location) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\r\n    }\r\n    Location.is = is;\r\n})(Location || (Location = {}));\r\n/**\r\n * The LocationLink namespace provides helper functions to work with\r\n * [LocationLink](#LocationLink) literals.\r\n */\r\nexport var LocationLink;\r\n(function (LocationLink) {\r\n    /**\r\n     * Creates a LocationLink literal.\r\n     * @param targetUri The definition's uri.\r\n     * @param targetRange The full range of the definition.\r\n     * @param targetSelectionRange The span of the symbol definition at the target.\r\n     * @param originSelectionRange The span of the symbol being defined in the originating source file.\r\n     */\r\n    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\r\n        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };\r\n    }\r\n    LocationLink.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\r\n            && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))\r\n            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\r\n    }\r\n    LocationLink.is = is;\r\n})(LocationLink || (LocationLink = {}));\r\n/**\r\n * The Color namespace provides helper functions to work with\r\n * [Color](#Color) literals.\r\n */\r\nexport var Color;\r\n(function (Color) {\r\n    /**\r\n     * Creates a new Color literal.\r\n     */\r\n    function create(red, green, blue, alpha) {\r\n        return {\r\n            red: red,\r\n            green: green,\r\n            blue: blue,\r\n            alpha: alpha,\r\n        };\r\n    }\r\n    Color.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Color](#Color) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.number(candidate.red)\r\n            && Is.number(candidate.green)\r\n            && Is.number(candidate.blue)\r\n            && Is.number(candidate.alpha);\r\n    }\r\n    Color.is = is;\r\n})(Color || (Color = {}));\r\n/**\r\n * The ColorInformation namespace provides helper functions to work with\r\n * [ColorInformation](#ColorInformation) literals.\r\n */\r\nexport var ColorInformation;\r\n(function (ColorInformation) {\r\n    /**\r\n     * Creates a new ColorInformation literal.\r\n     */\r\n    function create(range, color) {\r\n        return {\r\n            range: range,\r\n            color: color,\r\n        };\r\n    }\r\n    ColorInformation.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Range.is(candidate.range) && Color.is(candidate.color);\r\n    }\r\n    ColorInformation.is = is;\r\n})(ColorInformation || (ColorInformation = {}));\r\n/**\r\n * The Color namespace provides helper functions to work with\r\n * [ColorPresentation](#ColorPresentation) literals.\r\n */\r\nexport var ColorPresentation;\r\n(function (ColorPresentation) {\r\n    /**\r\n     * Creates a new ColorInformation literal.\r\n     */\r\n    function create(label, textEdit, additionalTextEdits) {\r\n        return {\r\n            label: label,\r\n            textEdit: textEdit,\r\n            additionalTextEdits: additionalTextEdits,\r\n        };\r\n    }\r\n    ColorPresentation.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.string(candidate.label)\r\n            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\r\n            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\r\n    }\r\n    ColorPresentation.is = is;\r\n})(ColorPresentation || (ColorPresentation = {}));\r\n/**\r\n * Enum of known range kinds\r\n */\r\nexport var FoldingRangeKind;\r\n(function (FoldingRangeKind) {\r\n    /**\r\n     * Folding range for a comment\r\n     */\r\n    FoldingRangeKind[\"Comment\"] = \"comment\";\r\n    /**\r\n     * Folding range for a imports or includes\r\n     */\r\n    FoldingRangeKind[\"Imports\"] = \"imports\";\r\n    /**\r\n     * Folding range for a region (e.g. `#region`)\r\n     */\r\n    FoldingRangeKind[\"Region\"] = \"region\";\r\n})(FoldingRangeKind || (FoldingRangeKind = {}));\r\n/**\r\n * The folding range namespace provides helper functions to work with\r\n * [FoldingRange](#FoldingRange) literals.\r\n */\r\nexport var FoldingRange;\r\n(function (FoldingRange) {\r\n    /**\r\n     * Creates a new FoldingRange literal.\r\n     */\r\n    function create(startLine, endLine, startCharacter, endCharacter, kind) {\r\n        var result = {\r\n            startLine: startLine,\r\n            endLine: endLine\r\n        };\r\n        if (Is.defined(startCharacter)) {\r\n            result.startCharacter = startCharacter;\r\n        }\r\n        if (Is.defined(endCharacter)) {\r\n            result.endCharacter = endCharacter;\r\n        }\r\n        if (Is.defined(kind)) {\r\n            result.kind = kind;\r\n        }\r\n        return result;\r\n    }\r\n    FoldingRange.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.number(candidate.startLine) && Is.number(candidate.startLine)\r\n            && (Is.undefined(candidate.startCharacter) || Is.number(candidate.startCharacter))\r\n            && (Is.undefined(candidate.endCharacter) || Is.number(candidate.endCharacter))\r\n            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\r\n    }\r\n    FoldingRange.is = is;\r\n})(FoldingRange || (FoldingRange = {}));\r\n/**\r\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\r\n * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.\r\n */\r\nexport var DiagnosticRelatedInformation;\r\n(function (DiagnosticRelatedInformation) {\r\n    /**\r\n     * Creates a new DiagnosticRelatedInformation literal.\r\n     */\r\n    function create(location, message) {\r\n        return {\r\n            location: location,\r\n            message: message\r\n        };\r\n    }\r\n    DiagnosticRelatedInformation.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\r\n    }\r\n    DiagnosticRelatedInformation.is = is;\r\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\r\n/**\r\n * The diagnostic's severity.\r\n */\r\nexport var DiagnosticSeverity;\r\n(function (DiagnosticSeverity) {\r\n    /**\r\n     * Reports an error.\r\n     */\r\n    DiagnosticSeverity.Error = 1;\r\n    /**\r\n     * Reports a warning.\r\n     */\r\n    DiagnosticSeverity.Warning = 2;\r\n    /**\r\n     * Reports an information.\r\n     */\r\n    DiagnosticSeverity.Information = 3;\r\n    /**\r\n     * Reports a hint.\r\n     */\r\n    DiagnosticSeverity.Hint = 4;\r\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\r\n/**\r\n * The diagnostic tags.\r\n *\r\n * @since 3.15.0\r\n */\r\nexport var DiagnosticTag;\r\n(function (DiagnosticTag) {\r\n    /**\r\n     * Unused or unnecessary code.\r\n     *\r\n     * Clients are allowed to render diagnostics with this tag faded out instead of having\r\n     * an error squiggle.\r\n     */\r\n    DiagnosticTag.Unnecessary = 1;\r\n    /**\r\n     * Deprecated or obsolete code.\r\n     *\r\n     * Clients are allowed to rendered diagnostics with this tag strike through.\r\n     */\r\n    DiagnosticTag.Deprecated = 2;\r\n})(DiagnosticTag || (DiagnosticTag = {}));\r\n/**\r\n * The Diagnostic namespace provides helper functions to work with\r\n * [Diagnostic](#Diagnostic) literals.\r\n */\r\nexport var Diagnostic;\r\n(function (Diagnostic) {\r\n    /**\r\n     * Creates a new Diagnostic literal.\r\n     */\r\n    function create(range, message, severity, code, source, relatedInformation) {\r\n        var result = { range: range, message: message };\r\n        if (Is.defined(severity)) {\r\n            result.severity = severity;\r\n        }\r\n        if (Is.defined(code)) {\r\n            result.code = code;\r\n        }\r\n        if (Is.defined(source)) {\r\n            result.source = source;\r\n        }\r\n        if (Is.defined(relatedInformation)) {\r\n            result.relatedInformation = relatedInformation;\r\n        }\r\n        return result;\r\n    }\r\n    Diagnostic.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate)\r\n            && Range.is(candidate.range)\r\n            && Is.string(candidate.message)\r\n            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\r\n            && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\r\n            && (Is.string(candidate.source) || Is.undefined(candidate.source))\r\n            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\r\n    }\r\n    Diagnostic.is = is;\r\n})(Diagnostic || (Diagnostic = {}));\r\n/**\r\n * The Command namespace provides helper functions to work with\r\n * [Command](#Command) literals.\r\n */\r\nexport var Command;\r\n(function (Command) {\r\n    /**\r\n     * Creates a new Command literal.\r\n     */\r\n    function create(title, command) {\r\n        var args = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            args[_i - 2] = arguments[_i];\r\n        }\r\n        var result = { title: title, command: command };\r\n        if (Is.defined(args) && args.length > 0) {\r\n            result.arguments = args;\r\n        }\r\n        return result;\r\n    }\r\n    Command.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Command](#Command) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\r\n    }\r\n    Command.is = is;\r\n})(Command || (Command = {}));\r\n/**\r\n * The TextEdit namespace provides helper function to create replace,\r\n * insert and delete edits more easily.\r\n */\r\nexport var TextEdit;\r\n(function (TextEdit) {\r\n    /**\r\n     * Creates a replace text edit.\r\n     * @param range The range of text to be replaced.\r\n     * @param newText The new text.\r\n     */\r\n    function replace(range, newText) {\r\n        return { range: range, newText: newText };\r\n    }\r\n    TextEdit.replace = replace;\r\n    /**\r\n     * Creates a insert text edit.\r\n     * @param position The position to insert the text at.\r\n     * @param newText The text to be inserted.\r\n     */\r\n    function insert(position, newText) {\r\n        return { range: { start: position, end: position }, newText: newText };\r\n    }\r\n    TextEdit.insert = insert;\r\n    /**\r\n     * Creates a delete text edit.\r\n     * @param range The range of text to be deleted.\r\n     */\r\n    function del(range) {\r\n        return { range: range, newText: '' };\r\n    }\r\n    TextEdit.del = del;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(candidate)\r\n            && Is.string(candidate.newText)\r\n            && Range.is(candidate.range);\r\n    }\r\n    TextEdit.is = is;\r\n})(TextEdit || (TextEdit = {}));\r\n/**\r\n * The TextDocumentEdit namespace provides helper function to create\r\n * an edit that manipulates a text document.\r\n */\r\nexport var TextDocumentEdit;\r\n(function (TextDocumentEdit) {\r\n    /**\r\n     * Creates a new `TextDocumentEdit`\r\n     */\r\n    function create(textDocument, edits) {\r\n        return { textDocument: textDocument, edits: edits };\r\n    }\r\n    TextDocumentEdit.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate)\r\n            && VersionedTextDocumentIdentifier.is(candidate.textDocument)\r\n            && Array.isArray(candidate.edits);\r\n    }\r\n    TextDocumentEdit.is = is;\r\n})(TextDocumentEdit || (TextDocumentEdit = {}));\r\nexport var CreateFile;\r\n(function (CreateFile) {\r\n    function create(uri, options) {\r\n        var result = {\r\n            kind: 'create',\r\n            uri: uri\r\n        };\r\n        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\r\n            result.options = options;\r\n        }\r\n        return result;\r\n    }\r\n    CreateFile.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) &&\r\n            (candidate.options === void 0 ||\r\n                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));\r\n    }\r\n    CreateFile.is = is;\r\n})(CreateFile || (CreateFile = {}));\r\nexport var RenameFile;\r\n(function (RenameFile) {\r\n    function create(oldUri, newUri, options) {\r\n        var result = {\r\n            kind: 'rename',\r\n            oldUri: oldUri,\r\n            newUri: newUri\r\n        };\r\n        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\r\n            result.options = options;\r\n        }\r\n        return result;\r\n    }\r\n    RenameFile.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) &&\r\n            (candidate.options === void 0 ||\r\n                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));\r\n    }\r\n    RenameFile.is = is;\r\n})(RenameFile || (RenameFile = {}));\r\nexport var DeleteFile;\r\n(function (DeleteFile) {\r\n    function create(uri, options) {\r\n        var result = {\r\n            kind: 'delete',\r\n            uri: uri\r\n        };\r\n        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {\r\n            result.options = options;\r\n        }\r\n        return result;\r\n    }\r\n    DeleteFile.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) &&\r\n            (candidate.options === void 0 ||\r\n                ((candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))));\r\n    }\r\n    DeleteFile.is = is;\r\n})(DeleteFile || (DeleteFile = {}));\r\nexport var WorkspaceEdit;\r\n(function (WorkspaceEdit) {\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate &&\r\n            (candidate.changes !== void 0 || candidate.documentChanges !== void 0) &&\r\n            (candidate.documentChanges === void 0 || candidate.documentChanges.every(function (change) {\r\n                if (Is.string(change.kind)) {\r\n                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\r\n                }\r\n                else {\r\n                    return TextDocumentEdit.is(change);\r\n                }\r\n            }));\r\n    }\r\n    WorkspaceEdit.is = is;\r\n})(WorkspaceEdit || (WorkspaceEdit = {}));\r\nvar TextEditChangeImpl = /** @class */ (function () {\r\n    function TextEditChangeImpl(edits) {\r\n        this.edits = edits;\r\n    }\r\n    TextEditChangeImpl.prototype.insert = function (position, newText) {\r\n        this.edits.push(TextEdit.insert(position, newText));\r\n    };\r\n    TextEditChangeImpl.prototype.replace = function (range, newText) {\r\n        this.edits.push(TextEdit.replace(range, newText));\r\n    };\r\n    TextEditChangeImpl.prototype.delete = function (range) {\r\n        this.edits.push(TextEdit.del(range));\r\n    };\r\n    TextEditChangeImpl.prototype.add = function (edit) {\r\n        this.edits.push(edit);\r\n    };\r\n    TextEditChangeImpl.prototype.all = function () {\r\n        return this.edits;\r\n    };\r\n    TextEditChangeImpl.prototype.clear = function () {\r\n        this.edits.splice(0, this.edits.length);\r\n    };\r\n    return TextEditChangeImpl;\r\n}());\r\n/**\r\n * A workspace change helps constructing changes to a workspace.\r\n */\r\nvar WorkspaceChange = /** @class */ (function () {\r\n    function WorkspaceChange(workspaceEdit) {\r\n        var _this = this;\r\n        this._textEditChanges = Object.create(null);\r\n        if (workspaceEdit) {\r\n            this._workspaceEdit = workspaceEdit;\r\n            if (workspaceEdit.documentChanges) {\r\n                workspaceEdit.documentChanges.forEach(function (change) {\r\n                    if (TextDocumentEdit.is(change)) {\r\n                        var textEditChange = new TextEditChangeImpl(change.edits);\r\n                        _this._textEditChanges[change.textDocument.uri] = textEditChange;\r\n                    }\r\n                });\r\n            }\r\n            else if (workspaceEdit.changes) {\r\n                Object.keys(workspaceEdit.changes).forEach(function (key) {\r\n                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\r\n                    _this._textEditChanges[key] = textEditChange;\r\n                });\r\n            }\r\n        }\r\n    }\r\n    Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\r\n        /**\r\n         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal\r\n         * use to be returned from a workspace edit operation like rename.\r\n         */\r\n        get: function () {\r\n            return this._workspaceEdit;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    WorkspaceChange.prototype.getTextEditChange = function (key) {\r\n        if (VersionedTextDocumentIdentifier.is(key)) {\r\n            if (!this._workspaceEdit) {\r\n                this._workspaceEdit = {\r\n                    documentChanges: []\r\n                };\r\n            }\r\n            if (!this._workspaceEdit.documentChanges) {\r\n                throw new Error('Workspace edit is not configured for document changes.');\r\n            }\r\n            var textDocument = key;\r\n            var result = this._textEditChanges[textDocument.uri];\r\n            if (!result) {\r\n                var edits = [];\r\n                var textDocumentEdit = {\r\n                    textDocument: textDocument,\r\n                    edits: edits\r\n                };\r\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\r\n                result = new TextEditChangeImpl(edits);\r\n                this._textEditChanges[textDocument.uri] = result;\r\n            }\r\n            return result;\r\n        }\r\n        else {\r\n            if (!this._workspaceEdit) {\r\n                this._workspaceEdit = {\r\n                    changes: Object.create(null)\r\n                };\r\n            }\r\n            if (!this._workspaceEdit.changes) {\r\n                throw new Error('Workspace edit is not configured for normal text edit changes.');\r\n            }\r\n            var result = this._textEditChanges[key];\r\n            if (!result) {\r\n                var edits = [];\r\n                this._workspaceEdit.changes[key] = edits;\r\n                result = new TextEditChangeImpl(edits);\r\n                this._textEditChanges[key] = result;\r\n            }\r\n            return result;\r\n        }\r\n    };\r\n    WorkspaceChange.prototype.createFile = function (uri, options) {\r\n        this.checkDocumentChanges();\r\n        this._workspaceEdit.documentChanges.push(CreateFile.create(uri, options));\r\n    };\r\n    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, options) {\r\n        this.checkDocumentChanges();\r\n        this._workspaceEdit.documentChanges.push(RenameFile.create(oldUri, newUri, options));\r\n    };\r\n    WorkspaceChange.prototype.deleteFile = function (uri, options) {\r\n        this.checkDocumentChanges();\r\n        this._workspaceEdit.documentChanges.push(DeleteFile.create(uri, options));\r\n    };\r\n    WorkspaceChange.prototype.checkDocumentChanges = function () {\r\n        if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {\r\n            throw new Error('Workspace edit is not configured for document changes.');\r\n        }\r\n    };\r\n    return WorkspaceChange;\r\n}());\r\nexport { WorkspaceChange };\r\n/**\r\n * The TextDocumentIdentifier namespace provides helper functions to work with\r\n * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.\r\n */\r\nexport var TextDocumentIdentifier;\r\n(function (TextDocumentIdentifier) {\r\n    /**\r\n     * Creates a new TextDocumentIdentifier literal.\r\n     * @param uri The document's uri.\r\n     */\r\n    function create(uri) {\r\n        return { uri: uri };\r\n    }\r\n    TextDocumentIdentifier.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri);\r\n    }\r\n    TextDocumentIdentifier.is = is;\r\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\r\n/**\r\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\r\n * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.\r\n */\r\nexport var VersionedTextDocumentIdentifier;\r\n(function (VersionedTextDocumentIdentifier) {\r\n    /**\r\n     * Creates a new VersionedTextDocumentIdentifier literal.\r\n     * @param uri The document's uri.\r\n     * @param uri The document's text.\r\n     */\r\n    function create(uri, version) {\r\n        return { uri: uri, version: version };\r\n    }\r\n    VersionedTextDocumentIdentifier.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.number(candidate.version));\r\n    }\r\n    VersionedTextDocumentIdentifier.is = is;\r\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\r\n/**\r\n * The TextDocumentItem namespace provides helper functions to work with\r\n * [TextDocumentItem](#TextDocumentItem) literals.\r\n */\r\nexport var TextDocumentItem;\r\n(function (TextDocumentItem) {\r\n    /**\r\n     * Creates a new TextDocumentItem literal.\r\n     * @param uri The document's uri.\r\n     * @param languageId The document's language identifier.\r\n     * @param version The document's version number.\r\n     * @param text The document's text.\r\n     */\r\n    function create(uri, languageId, version, text) {\r\n        return { uri: uri, languageId: languageId, version: version, text: text };\r\n    }\r\n    TextDocumentItem.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);\r\n    }\r\n    TextDocumentItem.is = is;\r\n})(TextDocumentItem || (TextDocumentItem = {}));\r\n/**\r\n * Describes the content type that a client supports in various\r\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\r\n *\r\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\r\n * are reserved for internal usage.\r\n */\r\nexport var MarkupKind;\r\n(function (MarkupKind) {\r\n    /**\r\n     * Plain text is supported as a content format\r\n     */\r\n    MarkupKind.PlainText = 'plaintext';\r\n    /**\r\n     * Markdown is supported as a content format\r\n     */\r\n    MarkupKind.Markdown = 'markdown';\r\n})(MarkupKind || (MarkupKind = {}));\r\n(function (MarkupKind) {\r\n    /**\r\n     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\r\n    }\r\n    MarkupKind.is = is;\r\n})(MarkupKind || (MarkupKind = {}));\r\nexport var MarkupContent;\r\n(function (MarkupContent) {\r\n    /**\r\n     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\r\n    }\r\n    MarkupContent.is = is;\r\n})(MarkupContent || (MarkupContent = {}));\r\n/**\r\n * The kind of a completion entry.\r\n */\r\nexport var CompletionItemKind;\r\n(function (CompletionItemKind) {\r\n    CompletionItemKind.Text = 1;\r\n    CompletionItemKind.Method = 2;\r\n    CompletionItemKind.Function = 3;\r\n    CompletionItemKind.Constructor = 4;\r\n    CompletionItemKind.Field = 5;\r\n    CompletionItemKind.Variable = 6;\r\n    CompletionItemKind.Class = 7;\r\n    CompletionItemKind.Interface = 8;\r\n    CompletionItemKind.Module = 9;\r\n    CompletionItemKind.Property = 10;\r\n    CompletionItemKind.Unit = 11;\r\n    CompletionItemKind.Value = 12;\r\n    CompletionItemKind.Enum = 13;\r\n    CompletionItemKind.Keyword = 14;\r\n    CompletionItemKind.Snippet = 15;\r\n    CompletionItemKind.Color = 16;\r\n    CompletionItemKind.File = 17;\r\n    CompletionItemKind.Reference = 18;\r\n    CompletionItemKind.Folder = 19;\r\n    CompletionItemKind.EnumMember = 20;\r\n    CompletionItemKind.Constant = 21;\r\n    CompletionItemKind.Struct = 22;\r\n    CompletionItemKind.Event = 23;\r\n    CompletionItemKind.Operator = 24;\r\n    CompletionItemKind.TypeParameter = 25;\r\n})(CompletionItemKind || (CompletionItemKind = {}));\r\n/**\r\n * Defines whether the insert text in a completion item should be interpreted as\r\n * plain text or a snippet.\r\n */\r\nexport var InsertTextFormat;\r\n(function (InsertTextFormat) {\r\n    /**\r\n     * The primary text to be inserted is treated as a plain string.\r\n     */\r\n    InsertTextFormat.PlainText = 1;\r\n    /**\r\n     * The primary text to be inserted is treated as a snippet.\r\n     *\r\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\r\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\r\n     * the end of the snippet. Placeholders with equal identifiers are linked,\r\n     * that is typing in one will update others too.\r\n     *\r\n     * See also: https://github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md\r\n     */\r\n    InsertTextFormat.Snippet = 2;\r\n})(InsertTextFormat || (InsertTextFormat = {}));\r\n/**\r\n * Completion item tags are extra annotations that tweak the rendering of a completion\r\n * item.\r\n *\r\n * @since 3.15.0\r\n */\r\nexport var CompletionItemTag;\r\n(function (CompletionItemTag) {\r\n    /**\r\n     * Render a completion as obsolete, usually using a strike-out.\r\n     */\r\n    CompletionItemTag.Deprecated = 1;\r\n})(CompletionItemTag || (CompletionItemTag = {}));\r\n/**\r\n * The CompletionItem namespace provides functions to deal with\r\n * completion items.\r\n */\r\nexport var CompletionItem;\r\n(function (CompletionItem) {\r\n    /**\r\n     * Create a completion item and seed it with a label.\r\n     * @param label The completion item's label\r\n     */\r\n    function create(label) {\r\n        return { label: label };\r\n    }\r\n    CompletionItem.create = create;\r\n})(CompletionItem || (CompletionItem = {}));\r\n/**\r\n * The CompletionList namespace provides functions to deal with\r\n * completion lists.\r\n */\r\nexport var CompletionList;\r\n(function (CompletionList) {\r\n    /**\r\n     * Creates a new completion list.\r\n     *\r\n     * @param items The completion items.\r\n     * @param isIncomplete The list is not complete.\r\n     */\r\n    function create(items, isIncomplete) {\r\n        return { items: items ? items : [], isIncomplete: !!isIncomplete };\r\n    }\r\n    CompletionList.create = create;\r\n})(CompletionList || (CompletionList = {}));\r\nexport var MarkedString;\r\n(function (MarkedString) {\r\n    /**\r\n     * Creates a marked string from plain text.\r\n     *\r\n     * @param plainText The plain text.\r\n     */\r\n    function fromPlainText(plainText) {\r\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\r\n    }\r\n    MarkedString.fromPlainText = fromPlainText;\r\n    /**\r\n     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\r\n    }\r\n    MarkedString.is = is;\r\n})(MarkedString || (MarkedString = {}));\r\nexport var Hover;\r\n(function (Hover) {\r\n    /**\r\n     * Checks whether the given value conforms to the [Hover](#Hover) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\r\n            MarkedString.is(candidate.contents) ||\r\n            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));\r\n    }\r\n    Hover.is = is;\r\n})(Hover || (Hover = {}));\r\n/**\r\n * The ParameterInformation namespace provides helper functions to work with\r\n * [ParameterInformation](#ParameterInformation) literals.\r\n */\r\nexport var ParameterInformation;\r\n(function (ParameterInformation) {\r\n    /**\r\n     * Creates a new parameter information literal.\r\n     *\r\n     * @param label A label string.\r\n     * @param documentation A doc string.\r\n     */\r\n    function create(label, documentation) {\r\n        return documentation ? { label: label, documentation: documentation } : { label: label };\r\n    }\r\n    ParameterInformation.create = create;\r\n})(ParameterInformation || (ParameterInformation = {}));\r\n/**\r\n * The SignatureInformation namespace provides helper functions to work with\r\n * [SignatureInformation](#SignatureInformation) literals.\r\n */\r\nexport var SignatureInformation;\r\n(function (SignatureInformation) {\r\n    function create(label, documentation) {\r\n        var parameters = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            parameters[_i - 2] = arguments[_i];\r\n        }\r\n        var result = { label: label };\r\n        if (Is.defined(documentation)) {\r\n            result.documentation = documentation;\r\n        }\r\n        if (Is.defined(parameters)) {\r\n            result.parameters = parameters;\r\n        }\r\n        else {\r\n            result.parameters = [];\r\n        }\r\n        return result;\r\n    }\r\n    SignatureInformation.create = create;\r\n})(SignatureInformation || (SignatureInformation = {}));\r\n/**\r\n * A document highlight kind.\r\n */\r\nexport var DocumentHighlightKind;\r\n(function (DocumentHighlightKind) {\r\n    /**\r\n     * A textual occurrence.\r\n     */\r\n    DocumentHighlightKind.Text = 1;\r\n    /**\r\n     * Read-access of a symbol, like reading a variable.\r\n     */\r\n    DocumentHighlightKind.Read = 2;\r\n    /**\r\n     * Write-access of a symbol, like writing to a variable.\r\n     */\r\n    DocumentHighlightKind.Write = 3;\r\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\r\n/**\r\n * DocumentHighlight namespace to provide helper functions to work with\r\n * [DocumentHighlight](#DocumentHighlight) literals.\r\n */\r\nexport var DocumentHighlight;\r\n(function (DocumentHighlight) {\r\n    /**\r\n     * Create a DocumentHighlight object.\r\n     * @param range The range the highlight applies to.\r\n     */\r\n    function create(range, kind) {\r\n        var result = { range: range };\r\n        if (Is.number(kind)) {\r\n            result.kind = kind;\r\n        }\r\n        return result;\r\n    }\r\n    DocumentHighlight.create = create;\r\n})(DocumentHighlight || (DocumentHighlight = {}));\r\n/**\r\n * A symbol kind.\r\n */\r\nexport var SymbolKind;\r\n(function (SymbolKind) {\r\n    SymbolKind.File = 1;\r\n    SymbolKind.Module = 2;\r\n    SymbolKind.Namespace = 3;\r\n    SymbolKind.Package = 4;\r\n    SymbolKind.Class = 5;\r\n    SymbolKind.Method = 6;\r\n    SymbolKind.Property = 7;\r\n    SymbolKind.Field = 8;\r\n    SymbolKind.Constructor = 9;\r\n    SymbolKind.Enum = 10;\r\n    SymbolKind.Interface = 11;\r\n    SymbolKind.Function = 12;\r\n    SymbolKind.Variable = 13;\r\n    SymbolKind.Constant = 14;\r\n    SymbolKind.String = 15;\r\n    SymbolKind.Number = 16;\r\n    SymbolKind.Boolean = 17;\r\n    SymbolKind.Array = 18;\r\n    SymbolKind.Object = 19;\r\n    SymbolKind.Key = 20;\r\n    SymbolKind.Null = 21;\r\n    SymbolKind.EnumMember = 22;\r\n    SymbolKind.Struct = 23;\r\n    SymbolKind.Event = 24;\r\n    SymbolKind.Operator = 25;\r\n    SymbolKind.TypeParameter = 26;\r\n})(SymbolKind || (SymbolKind = {}));\r\n/**\r\n * Symbol tags are extra annotations that tweak the rendering of a symbol.\r\n * @since 3.15\r\n */\r\nexport var SymbolTag;\r\n(function (SymbolTag) {\r\n    /**\r\n     * Render a symbol as obsolete, usually using a strike-out.\r\n     */\r\n    SymbolTag.Deprecated = 1;\r\n})(SymbolTag || (SymbolTag = {}));\r\nexport var SymbolInformation;\r\n(function (SymbolInformation) {\r\n    /**\r\n     * Creates a new symbol information literal.\r\n     *\r\n     * @param name The name of the symbol.\r\n     * @param kind The kind of the symbol.\r\n     * @param range The range of the location of the symbol.\r\n     * @param uri The resource of the location of symbol, defaults to the current document.\r\n     * @param containerName The name of the symbol containing the symbol.\r\n     */\r\n    function create(name, kind, range, uri, containerName) {\r\n        var result = {\r\n            name: name,\r\n            kind: kind,\r\n            location: { uri: uri, range: range }\r\n        };\r\n        if (containerName) {\r\n            result.containerName = containerName;\r\n        }\r\n        return result;\r\n    }\r\n    SymbolInformation.create = create;\r\n})(SymbolInformation || (SymbolInformation = {}));\r\nexport var DocumentSymbol;\r\n(function (DocumentSymbol) {\r\n    /**\r\n     * Creates a new symbol information literal.\r\n     *\r\n     * @param name The name of the symbol.\r\n     * @param detail The detail of the symbol.\r\n     * @param kind The kind of the symbol.\r\n     * @param range The range of the symbol.\r\n     * @param selectionRange The selectionRange of the symbol.\r\n     * @param children Children of the symbol.\r\n     */\r\n    function create(name, detail, kind, range, selectionRange, children) {\r\n        var result = {\r\n            name: name,\r\n            detail: detail,\r\n            kind: kind,\r\n            range: range,\r\n            selectionRange: selectionRange\r\n        };\r\n        if (children !== void 0) {\r\n            result.children = children;\r\n        }\r\n        return result;\r\n    }\r\n    DocumentSymbol.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate &&\r\n            Is.string(candidate.name) && Is.number(candidate.kind) &&\r\n            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\r\n            (candidate.detail === void 0 || Is.string(candidate.detail)) &&\r\n            (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) &&\r\n            (candidate.children === void 0 || Array.isArray(candidate.children));\r\n    }\r\n    DocumentSymbol.is = is;\r\n})(DocumentSymbol || (DocumentSymbol = {}));\r\n/**\r\n * A set of predefined code action kinds\r\n */\r\nexport var CodeActionKind;\r\n(function (CodeActionKind) {\r\n    /**\r\n     * Empty kind.\r\n     */\r\n    CodeActionKind.Empty = '';\r\n    /**\r\n     * Base kind for quickfix actions: 'quickfix'\r\n     */\r\n    CodeActionKind.QuickFix = 'quickfix';\r\n    /**\r\n     * Base kind for refactoring actions: 'refactor'\r\n     */\r\n    CodeActionKind.Refactor = 'refactor';\r\n    /**\r\n     * Base kind for refactoring extraction actions: 'refactor.extract'\r\n     *\r\n     * Example extract actions:\r\n     *\r\n     * - Extract method\r\n     * - Extract function\r\n     * - Extract variable\r\n     * - Extract interface from class\r\n     * - ...\r\n     */\r\n    CodeActionKind.RefactorExtract = 'refactor.extract';\r\n    /**\r\n     * Base kind for refactoring inline actions: 'refactor.inline'\r\n     *\r\n     * Example inline actions:\r\n     *\r\n     * - Inline function\r\n     * - Inline variable\r\n     * - Inline constant\r\n     * - ...\r\n     */\r\n    CodeActionKind.RefactorInline = 'refactor.inline';\r\n    /**\r\n     * Base kind for refactoring rewrite actions: 'refactor.rewrite'\r\n     *\r\n     * Example rewrite actions:\r\n     *\r\n     * - Convert JavaScript function to class\r\n     * - Add or remove parameter\r\n     * - Encapsulate field\r\n     * - Make method static\r\n     * - Move method to base class\r\n     * - ...\r\n     */\r\n    CodeActionKind.RefactorRewrite = 'refactor.rewrite';\r\n    /**\r\n     * Base kind for source actions: `source`\r\n     *\r\n     * Source code actions apply to the entire file.\r\n     */\r\n    CodeActionKind.Source = 'source';\r\n    /**\r\n     * Base kind for an organize imports source action: `source.organizeImports`\r\n     */\r\n    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\r\n    /**\r\n     * Base kind for auto-fix source actions: `source.fixAll`.\r\n     *\r\n     * Fix all actions automatically fix errors that have a clear fix that do not require user input.\r\n     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\r\n     *\r\n     * @since 3.15.0\r\n     */\r\n    CodeActionKind.SourceFixAll = 'source.fixAll';\r\n})(CodeActionKind || (CodeActionKind = {}));\r\n/**\r\n * The CodeActionContext namespace provides helper functions to work with\r\n * [CodeActionContext](#CodeActionContext) literals.\r\n */\r\nexport var CodeActionContext;\r\n(function (CodeActionContext) {\r\n    /**\r\n     * Creates a new CodeActionContext literal.\r\n     */\r\n    function create(diagnostics, only) {\r\n        var result = { diagnostics: diagnostics };\r\n        if (only !== void 0 && only !== null) {\r\n            result.only = only;\r\n        }\r\n        return result;\r\n    }\r\n    CodeActionContext.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));\r\n    }\r\n    CodeActionContext.is = is;\r\n})(CodeActionContext || (CodeActionContext = {}));\r\nexport var CodeAction;\r\n(function (CodeAction) {\r\n    function create(title, commandOrEdit, kind) {\r\n        var result = { title: title };\r\n        if (Command.is(commandOrEdit)) {\r\n            result.command = commandOrEdit;\r\n        }\r\n        else {\r\n            result.edit = commandOrEdit;\r\n        }\r\n        if (kind !== void 0) {\r\n            result.kind = kind;\r\n        }\r\n        return result;\r\n    }\r\n    CodeAction.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && Is.string(candidate.title) &&\r\n            (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\r\n            (candidate.kind === void 0 || Is.string(candidate.kind)) &&\r\n            (candidate.edit !== void 0 || candidate.command !== void 0) &&\r\n            (candidate.command === void 0 || Command.is(candidate.command)) &&\r\n            (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) &&\r\n            (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));\r\n    }\r\n    CodeAction.is = is;\r\n})(CodeAction || (CodeAction = {}));\r\n/**\r\n * The CodeLens namespace provides helper functions to work with\r\n * [CodeLens](#CodeLens) literals.\r\n */\r\nexport var CodeLens;\r\n(function (CodeLens) {\r\n    /**\r\n     * Creates a new CodeLens literal.\r\n     */\r\n    function create(range, data) {\r\n        var result = { range: range };\r\n        if (Is.defined(data)) {\r\n            result.data = data;\r\n        }\r\n        return result;\r\n    }\r\n    CodeLens.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\r\n    }\r\n    CodeLens.is = is;\r\n})(CodeLens || (CodeLens = {}));\r\n/**\r\n * The FormattingOptions namespace provides helper functions to work with\r\n * [FormattingOptions](#FormattingOptions) literals.\r\n */\r\nexport var FormattingOptions;\r\n(function (FormattingOptions) {\r\n    /**\r\n     * Creates a new FormattingOptions literal.\r\n     */\r\n    function create(tabSize, insertSpaces) {\r\n        return { tabSize: tabSize, insertSpaces: insertSpaces };\r\n    }\r\n    FormattingOptions.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.number(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\r\n    }\r\n    FormattingOptions.is = is;\r\n})(FormattingOptions || (FormattingOptions = {}));\r\n/**\r\n * The DocumentLink namespace provides helper functions to work with\r\n * [DocumentLink](#DocumentLink) literals.\r\n */\r\nexport var DocumentLink;\r\n(function (DocumentLink) {\r\n    /**\r\n     * Creates a new DocumentLink literal.\r\n     */\r\n    function create(range, target, data) {\r\n        return { range: range, target: target, data: data };\r\n    }\r\n    DocumentLink.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\r\n    }\r\n    DocumentLink.is = is;\r\n})(DocumentLink || (DocumentLink = {}));\r\n/**\r\n * The SelectionRange namespace provides helper function to work with\r\n * SelectionRange literals.\r\n */\r\nexport var SelectionRange;\r\n(function (SelectionRange) {\r\n    /**\r\n     * Creates a new SelectionRange\r\n     * @param range the range.\r\n     * @param parent an optional parent.\r\n     */\r\n    function create(range, parent) {\r\n        return { range: range, parent: parent };\r\n    }\r\n    SelectionRange.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate !== undefined && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\r\n    }\r\n    SelectionRange.is = is;\r\n})(SelectionRange || (SelectionRange = {}));\r\nexport var EOL = ['\\n', '\\r\\n', '\\r'];\r\n/**\r\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\r\n */\r\nexport var TextDocument;\r\n(function (TextDocument) {\r\n    /**\r\n     * Creates a new ITextDocument literal from the given uri and content.\r\n     * @param uri The document's uri.\r\n     * @param languageId  The document's language Id.\r\n     * @param content The document's content.\r\n     */\r\n    function create(uri, languageId, version, content) {\r\n        return new FullTextDocument(uri, languageId, version, content);\r\n    }\r\n    TextDocument.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount)\r\n            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\r\n    }\r\n    TextDocument.is = is;\r\n    function applyEdits(document, edits) {\r\n        var text = document.getText();\r\n        var sortedEdits = mergeSort(edits, function (a, b) {\r\n            var diff = a.range.start.line - b.range.start.line;\r\n            if (diff === 0) {\r\n                return a.range.start.character - b.range.start.character;\r\n            }\r\n            return diff;\r\n        });\r\n        var lastModifiedOffset = text.length;\r\n        for (var i = sortedEdits.length - 1; i >= 0; i--) {\r\n            var e = sortedEdits[i];\r\n            var startOffset = document.offsetAt(e.range.start);\r\n            var endOffset = document.offsetAt(e.range.end);\r\n            if (endOffset <= lastModifiedOffset) {\r\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\r\n            }\r\n            else {\r\n                throw new Error('Overlapping edit');\r\n            }\r\n            lastModifiedOffset = startOffset;\r\n        }\r\n        return text;\r\n    }\r\n    TextDocument.applyEdits = applyEdits;\r\n    function mergeSort(data, compare) {\r\n        if (data.length <= 1) {\r\n            // sorted\r\n            return data;\r\n        }\r\n        var p = (data.length / 2) | 0;\r\n        var left = data.slice(0, p);\r\n        var right = data.slice(p);\r\n        mergeSort(left, compare);\r\n        mergeSort(right, compare);\r\n        var leftIdx = 0;\r\n        var rightIdx = 0;\r\n        var i = 0;\r\n        while (leftIdx < left.length && rightIdx < right.length) {\r\n            var ret = compare(left[leftIdx], right[rightIdx]);\r\n            if (ret <= 0) {\r\n                // smaller_equal -> take left to preserve order\r\n                data[i++] = left[leftIdx++];\r\n            }\r\n            else {\r\n                // greater -> take right\r\n                data[i++] = right[rightIdx++];\r\n            }\r\n        }\r\n        while (leftIdx < left.length) {\r\n            data[i++] = left[leftIdx++];\r\n        }\r\n        while (rightIdx < right.length) {\r\n            data[i++] = right[rightIdx++];\r\n        }\r\n        return data;\r\n    }\r\n})(TextDocument || (TextDocument = {}));\r\nvar FullTextDocument = /** @class */ (function () {\r\n    function FullTextDocument(uri, languageId, version, content) {\r\n        this._uri = uri;\r\n        this._languageId = languageId;\r\n        this._version = version;\r\n        this._content = content;\r\n        this._lineOffsets = undefined;\r\n    }\r\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\r\n        get: function () {\r\n            return this._uri;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\r\n        get: function () {\r\n            return this._languageId;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\r\n        get: function () {\r\n            return this._version;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FullTextDocument.prototype.getText = function (range) {\r\n        if (range) {\r\n            var start = this.offsetAt(range.start);\r\n            var end = this.offsetAt(range.end);\r\n            return this._content.substring(start, end);\r\n        }\r\n        return this._content;\r\n    };\r\n    FullTextDocument.prototype.update = function (event, version) {\r\n        this._content = event.text;\r\n        this._version = version;\r\n        this._lineOffsets = undefined;\r\n    };\r\n    FullTextDocument.prototype.getLineOffsets = function () {\r\n        if (this._lineOffsets === undefined) {\r\n            var lineOffsets = [];\r\n            var text = this._content;\r\n            var isLineStart = true;\r\n            for (var i = 0; i < text.length; i++) {\r\n                if (isLineStart) {\r\n                    lineOffsets.push(i);\r\n                    isLineStart = false;\r\n                }\r\n                var ch = text.charAt(i);\r\n                isLineStart = (ch === '\\r' || ch === '\\n');\r\n                if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\r\n                    i++;\r\n                }\r\n            }\r\n            if (isLineStart && text.length > 0) {\r\n                lineOffsets.push(text.length);\r\n            }\r\n            this._lineOffsets = lineOffsets;\r\n        }\r\n        return this._lineOffsets;\r\n    };\r\n    FullTextDocument.prototype.positionAt = function (offset) {\r\n        offset = Math.max(Math.min(offset, this._content.length), 0);\r\n        var lineOffsets = this.getLineOffsets();\r\n        var low = 0, high = lineOffsets.length;\r\n        if (high === 0) {\r\n            return Position.create(0, offset);\r\n        }\r\n        while (low < high) {\r\n            var mid = Math.floor((low + high) / 2);\r\n            if (lineOffsets[mid] > offset) {\r\n                high = mid;\r\n            }\r\n            else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        // low is the least x for which the line offset is larger than the current offset\r\n        // or array.length if no line offset is larger than the current offset\r\n        var line = low - 1;\r\n        return Position.create(line, offset - lineOffsets[line]);\r\n    };\r\n    FullTextDocument.prototype.offsetAt = function (position) {\r\n        var lineOffsets = this.getLineOffsets();\r\n        if (position.line >= lineOffsets.length) {\r\n            return this._content.length;\r\n        }\r\n        else if (position.line < 0) {\r\n            return 0;\r\n        }\r\n        var lineOffset = lineOffsets[position.line];\r\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\r\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\r\n    };\r\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\r\n        get: function () {\r\n            return this.getLineOffsets().length;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return FullTextDocument;\r\n}());\r\nvar Is;\r\n(function (Is) {\r\n    var toString = Object.prototype.toString;\r\n    function defined(value) {\r\n        return typeof value !== 'undefined';\r\n    }\r\n    Is.defined = defined;\r\n    function undefined(value) {\r\n        return typeof value === 'undefined';\r\n    }\r\n    Is.undefined = undefined;\r\n    function boolean(value) {\r\n        return value === true || value === false;\r\n    }\r\n    Is.boolean = boolean;\r\n    function string(value) {\r\n        return toString.call(value) === '[object String]';\r\n    }\r\n    Is.string = string;\r\n    function number(value) {\r\n        return toString.call(value) === '[object Number]';\r\n    }\r\n    Is.number = number;\r\n    function func(value) {\r\n        return toString.call(value) === '[object Function]';\r\n    }\r\n    Is.func = func;\r\n    function objectLiteral(value) {\r\n        // Strictly speaking class instances pass this check as well. Since the LSP\r\n        // doesn't use classes we ignore this for now. If we do we need to add something\r\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\r\n        return value !== null && typeof value === 'object';\r\n    }\r\n    Is.objectLiteral = objectLiteral;\r\n    function typedArray(value, check) {\r\n        return Array.isArray(value) && value.every(check);\r\n    }\r\n    Is.typedArray = typedArray;\r\n})(Is || (Is = {}));\r\n","import { isCompositeType } from 'graphql';\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, } from 'graphql/type/introspection';\nexport function getDefinitionState(tokenState) {\n    let definitionState;\n    forEachState(tokenState, (state) => {\n        switch (state.kind) {\n            case 'Query':\n            case 'ShortQuery':\n            case 'Mutation':\n            case 'Subscription':\n            case 'FragmentDefinition':\n                definitionState = state;\n                break;\n        }\n    });\n    return definitionState;\n}\nexport function getFieldDef(schema, type, fieldName) {\n    if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === type) {\n        return SchemaMetaFieldDef;\n    }\n    if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === type) {\n        return TypeMetaFieldDef;\n    }\n    if (fieldName === TypeNameMetaFieldDef.name && isCompositeType(type)) {\n        return TypeNameMetaFieldDef;\n    }\n    if ('getFields' in type) {\n        return type.getFields()[fieldName];\n    }\n    return null;\n}\nexport function forEachState(stack, fn) {\n    const reverseStateStack = [];\n    let state = stack;\n    while (state && state.kind) {\n        reverseStateStack.push(state);\n        state = state.prevState;\n    }\n    for (let i = reverseStateStack.length - 1; i >= 0; i--) {\n        fn(reverseStateStack[i]);\n    }\n}\nexport function objectValues(object) {\n    const keys = Object.keys(object);\n    const len = keys.length;\n    const values = new Array(len);\n    for (let i = 0; i < len; ++i) {\n        values[i] = object[keys[i]];\n    }\n    return values;\n}\nexport function hintList(token, list) {\n    return filterAndSortList(list, normalizeText(token.string));\n}\nfunction filterAndSortList(list, text) {\n    if (!text) {\n        return filterNonEmpty(list, entry => !entry.isDeprecated);\n    }\n    const byProximity = list.map(entry => ({\n        proximity: getProximity(normalizeText(entry.label), text),\n        entry,\n    }));\n    return filterNonEmpty(filterNonEmpty(byProximity, pair => pair.proximity <= 2), pair => !pair.entry.isDeprecated)\n        .sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) ||\n        a.proximity - b.proximity ||\n        a.entry.label.length - b.entry.label.length)\n        .map(pair => pair.entry);\n}\nfunction filterNonEmpty(array, predicate) {\n    const filtered = array.filter(predicate);\n    return filtered.length === 0 ? array : filtered;\n}\nfunction normalizeText(text) {\n    return text.toLowerCase().replace(/\\W/g, '');\n}\nfunction getProximity(suggestion, text) {\n    let proximity = lexicalDistance(text, suggestion);\n    if (suggestion.length > text.length) {\n        proximity -= suggestion.length - text.length - 1;\n        proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n    }\n    return proximity;\n}\nfunction lexicalDistance(a, b) {\n    let i;\n    let j;\n    const d = [];\n    const aLength = a.length;\n    const bLength = b.length;\n    for (i = 0; i <= aLength; i++) {\n        d[i] = [i];\n    }\n    for (j = 1; j <= bLength; j++) {\n        d[0][j] = j;\n    }\n    for (i = 1; i <= aLength; i++) {\n        for (j = 1; j <= bLength; j++) {\n            const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n            d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n                d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n            }\n        }\n    }\n    return d[aLength][bLength];\n}\n//# sourceMappingURL=autocompleteUtils.js.map","import { isInterfaceType, isObjectType, isListType, isNonNullType, isAbstractType } from \"../type/definition.mjs\";\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\n\nexport function isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  } // If either type is non-null, the other must also be non-null.\n\n\n  if (isNonNullType(typeA) && isNonNullType(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // If either type is a list, the other must also be a list.\n\n\n  if (isListType(typeA) && isListType(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // Otherwise the types are not equal.\n\n\n  return false;\n}\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n\nexport function isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  } // If superType is non-null, maybeSubType must also be non-null.\n\n\n  if (isNonNullType(superType)) {\n    if (isNonNullType(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if (isNonNullType(maybeSubType)) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  } // If superType type is a list, maybeSubType type must also be a list.\n\n\n  if (isListType(superType)) {\n    if (isListType(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if (isListType(maybeSubType)) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  } // If superType type is an abstract type, check if it is super type of maybeSubType.\n  // Otherwise, the child type is not a valid subtype of the parent type.\n\n\n  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);\n}\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\n\nexport function doTypesOverlap(schema, typeA, typeB) {\n  // Equivalent types overlap\n  if (typeA === typeB) {\n    return true;\n  }\n\n  if (isAbstractType(typeA)) {\n    if (isAbstractType(typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema.getPossibleTypes(typeA).some(function (type) {\n        return schema.isSubType(typeB, type);\n      });\n    } // Determine if the latter type is a possible concrete type of the former.\n\n\n    return schema.isSubType(typeA, typeB);\n  }\n\n  if (isAbstractType(typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isSubType(typeB, typeA);\n  } // Otherwise the types do not overlap.\n\n\n  return false;\n}\n","export default class CharacterStream {\n    constructor(sourceText) {\n        this.getStartOfToken = () => this._start;\n        this.getCurrentPosition = () => this._pos;\n        this.eol = () => this._sourceText.length === this._pos;\n        this.sol = () => this._pos === 0;\n        this.peek = () => {\n            return this._sourceText.charAt(this._pos)\n                ? this._sourceText.charAt(this._pos)\n                : null;\n        };\n        this.next = () => {\n            const char = this._sourceText.charAt(this._pos);\n            this._pos++;\n            return char;\n        };\n        this.eat = (pattern) => {\n            const isMatched = this._testNextCharacter(pattern);\n            if (isMatched) {\n                this._start = this._pos;\n                this._pos++;\n                return this._sourceText.charAt(this._pos - 1);\n            }\n            return undefined;\n        };\n        this.eatWhile = (match) => {\n            let isMatched = this._testNextCharacter(match);\n            let didEat = false;\n            if (isMatched) {\n                didEat = isMatched;\n                this._start = this._pos;\n            }\n            while (isMatched) {\n                this._pos++;\n                isMatched = this._testNextCharacter(match);\n                didEat = true;\n            }\n            return didEat;\n        };\n        this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n        this.skipToEnd = () => {\n            this._pos = this._sourceText.length;\n        };\n        this.skipTo = (position) => {\n            this._pos = position;\n        };\n        this.match = (pattern, consume = true, caseFold = false) => {\n            let token = null;\n            let match = null;\n            if (typeof pattern === 'string') {\n                const regex = new RegExp(pattern, caseFold ? 'i' : 'g');\n                match = regex.test(this._sourceText.substr(this._pos, pattern.length));\n                token = pattern;\n            }\n            else if (pattern instanceof RegExp) {\n                match = this._sourceText.slice(this._pos).match(pattern);\n                token = match && match[0];\n            }\n            if (match != null) {\n                if (typeof pattern === 'string' ||\n                    (match instanceof Array &&\n                        this._sourceText.startsWith(match[0], this._pos))) {\n                    if (consume) {\n                        this._start = this._pos;\n                        if (token && token.length) {\n                            this._pos += token.length;\n                        }\n                    }\n                    return match;\n                }\n            }\n            return false;\n        };\n        this.backUp = (num) => {\n            this._pos -= num;\n        };\n        this.column = () => this._pos;\n        this.indentation = () => {\n            const match = this._sourceText.match(/\\s*/);\n            let indent = 0;\n            if (match && match.length === 0) {\n                const whitespaces = match[0];\n                let pos = 0;\n                while (whitespaces.length > pos) {\n                    if (whitespaces.charCodeAt(pos) === 9) {\n                        indent += 2;\n                    }\n                    else {\n                        indent++;\n                    }\n                    pos++;\n                }\n            }\n            return indent;\n        };\n        this.current = () => this._sourceText.slice(this._start, this._pos);\n        this._start = 0;\n        this._pos = 0;\n        this._sourceText = sourceText;\n    }\n    _testNextCharacter(pattern) {\n        const character = this._sourceText.charAt(this._pos);\n        let isMatched = false;\n        if (typeof pattern === 'string') {\n            isMatched = character === pattern;\n        }\n        else {\n            isMatched =\n                pattern instanceof RegExp\n                    ? pattern.test(character)\n                    : pattern(character);\n        }\n        return isMatched;\n    }\n}\n//# sourceMappingURL=CharacterStream.js.map","export function opt(ofRule) {\n    return { ofRule };\n}\nexport function list(ofRule, separator) {\n    return { ofRule, isList: true, separator };\n}\nexport function butNot(rule, exclusions) {\n    const ruleMatch = rule.match;\n    rule.match = token => {\n        let check = false;\n        if (ruleMatch) {\n            check = ruleMatch(token);\n        }\n        return (check &&\n            exclusions.every(exclusion => exclusion.match && !exclusion.match(token)));\n    };\n    return rule;\n}\nexport function t(kind, style) {\n    return { style, match: (token) => token.kind === kind };\n}\nexport function p(value, style) {\n    return {\n        style: style || 'punctuation',\n        match: (token) => token.kind === 'Punctuation' && token.value === value,\n    };\n}\n//# sourceMappingURL=RuleHelpers.js.map","import { opt, list, butNot, t, p } from './RuleHelpers';\nexport const isIgnored = (ch) => ch === ' ' ||\n    ch === '\\t' ||\n    ch === ',' ||\n    ch === '\\n' ||\n    ch === '\\r' ||\n    ch === '\\uFEFF' ||\n    ch === '\\u00A0';\nexport const LexRules = {\n    Name: /^[_A-Za-z][_0-9A-Za-z]*/,\n    Punctuation: /^(?:!|\\$|\\(|\\)|\\.\\.\\.|:|=|@|\\[|]|\\{|\\||\\})/,\n    Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,\n    String: /^(?:\"\"\"(?:\\\\\"\"\"|[^\"]|\"[^\"]|\"\"[^\"])*(?:\"\"\")?|\"(?:[^\"\\\\]|\\\\(?:\"|\\/|\\\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*\"?)/,\n    Comment: /^#.*/,\n};\nexport const ParseRules = {\n    Document: [list('Definition')],\n    Definition(token) {\n        switch (token.value) {\n            case '{':\n                return 'ShortQuery';\n            case 'query':\n                return 'Query';\n            case 'mutation':\n                return 'Mutation';\n            case 'subscription':\n                return 'Subscription';\n            case 'fragment':\n                return 'FragmentDefinition';\n            case 'schema':\n                return 'SchemaDef';\n            case 'scalar':\n                return 'ScalarDef';\n            case 'type':\n                return 'ObjectTypeDef';\n            case 'interface':\n                return 'InterfaceDef';\n            case 'union':\n                return 'UnionDef';\n            case 'enum':\n                return 'EnumDef';\n            case 'input':\n                return 'InputDef';\n            case 'extend':\n                return 'ExtendDef';\n            case 'directive':\n                return 'DirectiveDef';\n        }\n    },\n    ShortQuery: ['SelectionSet'],\n    Query: [\n        word('query'),\n        opt(name('def')),\n        opt('VariableDefinitions'),\n        list('Directive'),\n        'SelectionSet',\n    ],\n    Mutation: [\n        word('mutation'),\n        opt(name('def')),\n        opt('VariableDefinitions'),\n        list('Directive'),\n        'SelectionSet',\n    ],\n    Subscription: [\n        word('subscription'),\n        opt(name('def')),\n        opt('VariableDefinitions'),\n        list('Directive'),\n        'SelectionSet',\n    ],\n    VariableDefinitions: [p('('), list('VariableDefinition'), p(')')],\n    VariableDefinition: ['Variable', p(':'), 'Type', opt('DefaultValue')],\n    Variable: [p('$', 'variable'), name('variable')],\n    DefaultValue: [p('='), 'Value'],\n    SelectionSet: [p('{'), list('Selection'), p('}')],\n    Selection(token, stream) {\n        return token.value === '...'\n            ? stream.match(/[\\s\\u00a0,]*(on\\b|@|{)/, false)\n                ? 'InlineFragment'\n                : 'FragmentSpread'\n            : stream.match(/[\\s\\u00a0,]*:/, false)\n                ? 'AliasedField'\n                : 'Field';\n    },\n    AliasedField: [\n        name('property'),\n        p(':'),\n        name('qualifier'),\n        opt('Arguments'),\n        list('Directive'),\n        opt('SelectionSet'),\n    ],\n    Field: [\n        name('property'),\n        opt('Arguments'),\n        list('Directive'),\n        opt('SelectionSet'),\n    ],\n    Arguments: [p('('), list('Argument'), p(')')],\n    Argument: [name('attribute'), p(':'), 'Value'],\n    FragmentSpread: [p('...'), name('def'), list('Directive')],\n    InlineFragment: [\n        p('...'),\n        opt('TypeCondition'),\n        list('Directive'),\n        'SelectionSet',\n    ],\n    FragmentDefinition: [\n        word('fragment'),\n        opt(butNot(name('def'), [word('on')])),\n        'TypeCondition',\n        list('Directive'),\n        'SelectionSet',\n    ],\n    TypeCondition: [word('on'), 'NamedType'],\n    Value(token) {\n        switch (token.kind) {\n            case 'Number':\n                return 'NumberValue';\n            case 'String':\n                return 'StringValue';\n            case 'Punctuation':\n                switch (token.value) {\n                    case '[':\n                        return 'ListValue';\n                    case '{':\n                        return 'ObjectValue';\n                    case '$':\n                        return 'Variable';\n                }\n                return null;\n            case 'Name':\n                switch (token.value) {\n                    case 'true':\n                    case 'false':\n                        return 'BooleanValue';\n                }\n                if (token.value === 'null') {\n                    return 'NullValue';\n                }\n                return 'EnumValue';\n        }\n    },\n    NumberValue: [t('Number', 'number')],\n    StringValue: [t('String', 'string')],\n    BooleanValue: [t('Name', 'builtin')],\n    NullValue: [t('Name', 'keyword')],\n    EnumValue: [name('string-2')],\n    ListValue: [p('['), list('Value'), p(']')],\n    ObjectValue: [p('{'), list('ObjectField'), p('}')],\n    ObjectField: [name('attribute'), p(':'), 'Value'],\n    Type(token) {\n        return token.value === '[' ? 'ListType' : 'NonNullType';\n    },\n    ListType: [p('['), 'Type', p(']'), opt(p('!'))],\n    NonNullType: ['NamedType', opt(p('!'))],\n    NamedType: [type('atom')],\n    Directive: [p('@', 'meta'), name('meta'), opt('Arguments')],\n    SchemaDef: [\n        word('schema'),\n        list('Directive'),\n        p('{'),\n        list('OperationTypeDef'),\n        p('}'),\n    ],\n    OperationTypeDef: [name('keyword'), p(':'), name('atom')],\n    ScalarDef: [word('scalar'), name('atom'), list('Directive')],\n    ObjectTypeDef: [\n        word('type'),\n        name('atom'),\n        opt('Implements'),\n        list('Directive'),\n        p('{'),\n        list('FieldDef'),\n        p('}'),\n    ],\n    Implements: [word('implements'), list('NamedType')],\n    FieldDef: [\n        name('property'),\n        opt('ArgumentsDef'),\n        p(':'),\n        'Type',\n        list('Directive'),\n    ],\n    ArgumentsDef: [p('('), list('InputValueDef'), p(')')],\n    InputValueDef: [\n        name('attribute'),\n        p(':'),\n        'Type',\n        opt('DefaultValue'),\n        list('Directive'),\n    ],\n    InterfaceDef: [\n        word('interface'),\n        name('atom'),\n        list('Directive'),\n        p('{'),\n        list('FieldDef'),\n        p('}'),\n    ],\n    UnionDef: [\n        word('union'),\n        name('atom'),\n        list('Directive'),\n        p('='),\n        list('UnionMember', p('|')),\n    ],\n    UnionMember: ['NamedType'],\n    EnumDef: [\n        word('enum'),\n        name('atom'),\n        list('Directive'),\n        p('{'),\n        list('EnumValueDef'),\n        p('}'),\n    ],\n    EnumValueDef: [name('string-2'), list('Directive')],\n    InputDef: [\n        word('input'),\n        name('atom'),\n        list('Directive'),\n        p('{'),\n        list('InputValueDef'),\n        p('}'),\n    ],\n    ExtendDef: [word('extend'), 'ObjectTypeDef'],\n    DirectiveDef: [\n        word('directive'),\n        p('@', 'meta'),\n        name('meta'),\n        opt('ArgumentsDef'),\n        word('on'),\n        list('DirectiveLocation', p('|')),\n    ],\n    DirectiveLocation: [name('string-2')],\n};\nfunction word(value) {\n    return {\n        style: 'keyword',\n        match: (token) => token.kind === 'Name' && token.value === value,\n    };\n}\nfunction name(style) {\n    return {\n        style,\n        match: (token) => token.kind === 'Name',\n        update(state, token) {\n            state.name = token.value;\n        },\n    };\n}\nfunction type(style) {\n    return {\n        style,\n        match: (token) => token.kind === 'Name',\n        update(state, token) {\n            if (state.prevState && state.prevState.prevState) {\n                state.name = token.value;\n                state.prevState.prevState.type = token.value;\n            }\n        },\n    };\n}\n//# sourceMappingURL=Rules.js.map","import { LexRules, ParseRules, isIgnored } from './Rules';\nexport default function onlineParser(options = {\n    eatWhitespace: stream => stream.eatWhile(isIgnored),\n    lexRules: LexRules,\n    parseRules: ParseRules,\n    editorConfig: {},\n}) {\n    return {\n        startState() {\n            const initialState = {\n                level: 0,\n                step: 0,\n                name: null,\n                kind: null,\n                type: null,\n                rule: null,\n                needsSeperator: false,\n                prevState: null,\n            };\n            pushRule(options.parseRules, initialState, 'Document');\n            return initialState;\n        },\n        token(stream, state) {\n            return getToken(stream, state, options);\n        },\n    };\n}\nfunction getToken(stream, state, options) {\n    const { lexRules, parseRules, eatWhitespace, editorConfig } = options;\n    if (state.rule && state.rule.length === 0) {\n        popRule(state);\n    }\n    else if (state.needsAdvance) {\n        state.needsAdvance = false;\n        advanceRule(state, true);\n    }\n    if (stream.sol()) {\n        const tabSize = (editorConfig && editorConfig.tabSize) || 2;\n        state.indentLevel = Math.floor(stream.indentation() / tabSize);\n    }\n    if (eatWhitespace(stream)) {\n        return 'ws';\n    }\n    const token = lex(lexRules, stream);\n    if (!token) {\n        const matchedSomething = stream.match(/\\S+/);\n        if (!matchedSomething) {\n            stream.match(/\\s/);\n        }\n        pushRule(SpecialParseRules, state, 'Invalid');\n        return 'invalidchar';\n    }\n    if (token.kind === 'Comment') {\n        pushRule(SpecialParseRules, state, 'Comment');\n        return 'comment';\n    }\n    const backupState = assign({}, state);\n    if (token.kind === 'Punctuation') {\n        if (/^[{([]/.test(token.value)) {\n            if (state.indentLevel !== undefined) {\n                state.levels = (state.levels || []).concat(state.indentLevel + 1);\n            }\n        }\n        else if (/^[})\\]]/.test(token.value)) {\n            const levels = (state.levels = (state.levels || []).slice(0, -1));\n            if (state.indentLevel) {\n                if (levels.length > 0 &&\n                    levels[levels.length - 1] < state.indentLevel) {\n                    state.indentLevel = levels[levels.length - 1];\n                }\n            }\n        }\n    }\n    while (state.rule) {\n        let expected = typeof state.rule === 'function'\n            ? state.step === 0\n                ? state.rule(token, stream)\n                : null\n            : state.rule[state.step];\n        if (state.needsSeperator) {\n            expected = expected && expected.separator;\n        }\n        if (expected) {\n            if (expected.ofRule) {\n                expected = expected.ofRule;\n            }\n            if (typeof expected === 'string') {\n                pushRule(parseRules, state, expected);\n                continue;\n            }\n            if (expected.match && expected.match(token)) {\n                if (expected.update) {\n                    expected.update(state, token);\n                }\n                if (token.kind === 'Punctuation') {\n                    advanceRule(state, true);\n                }\n                else {\n                    state.needsAdvance = true;\n                }\n                return expected.style;\n            }\n        }\n        unsuccessful(state);\n    }\n    assign(state, backupState);\n    pushRule(SpecialParseRules, state, 'Invalid');\n    return 'invalidchar';\n}\nfunction assign(to, from) {\n    const keys = Object.keys(from);\n    for (let i = 0; i < keys.length; i++) {\n        to[keys[i]] = from[keys[i]];\n    }\n    return to;\n}\nconst SpecialParseRules = {\n    Invalid: [],\n    Comment: [],\n};\nfunction pushRule(rules, state, ruleKind) {\n    if (!rules[ruleKind]) {\n        throw new TypeError('Unknown rule: ' + ruleKind);\n    }\n    state.prevState = Object.assign({}, state);\n    state.kind = ruleKind;\n    state.name = null;\n    state.type = null;\n    state.rule = rules[ruleKind];\n    state.step = 0;\n    state.needsSeperator = false;\n}\nfunction popRule(state) {\n    if (!state.prevState) {\n        return;\n    }\n    state.kind = state.prevState.kind;\n    state.name = state.prevState.name;\n    state.type = state.prevState.type;\n    state.rule = state.prevState.rule;\n    state.step = state.prevState.step;\n    state.needsSeperator = state.prevState.needsSeperator;\n    state.prevState = state.prevState.prevState;\n}\nfunction advanceRule(state, successful) {\n    if (isList(state) && state.rule) {\n        const step = state.rule[state.step];\n        if (step.separator) {\n            const separator = step.separator;\n            state.needsSeperator = !state.needsSeperator;\n            if (!state.needsSeperator && separator.ofRule) {\n                return;\n            }\n        }\n        if (successful) {\n            return;\n        }\n    }\n    state.needsSeperator = false;\n    state.step++;\n    while (state.rule &&\n        !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n        popRule(state);\n        if (state.rule) {\n            if (isList(state)) {\n                if (state.rule && state.rule[state.step].separator) {\n                    state.needsSeperator = !state.needsSeperator;\n                }\n            }\n            else {\n                state.needsSeperator = false;\n                state.step++;\n            }\n        }\n    }\n}\nfunction isList(state) {\n    const step = Array.isArray(state.rule) &&\n        typeof state.rule[state.step] !== 'string' &&\n        state.rule[state.step];\n    return step && step.isList;\n}\nfunction unsuccessful(state) {\n    while (state.rule &&\n        !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n        popRule(state);\n    }\n    if (state.rule) {\n        advanceRule(state, false);\n    }\n}\nfunction lex(lexRules, stream) {\n    const kinds = Object.keys(lexRules);\n    for (let i = 0; i < kinds.length; i++) {\n        const match = stream.match(lexRules[kinds[i]]);\n        if (match && match instanceof Array) {\n            return { kind: kinds[i], value: match[0] };\n        }\n    }\n}\n//# sourceMappingURL=onlineParser.js.map","import { Kind } from 'graphql';\nexport const AdditionalRuleKinds = {\n    ALIASED_FIELD: 'AliasedField',\n    ARGUMENTS: 'Arguments',\n    SHORT_QUERY: 'ShortQuery',\n    QUERY: 'Query',\n    MUTATION: 'Mutation',\n    SUBSCRIPTION: 'Subscription',\n    TYPE_CONDITION: 'TypeCondition',\n    INVALID: 'Invalid',\n    COMMENT: 'Comment',\n    SCHEMA_DEF: 'SchemaDef',\n    SCALAR_DEF: 'ScalarDef',\n    OBJECT_TYPE_DEF: 'ObjectTypeDef',\n    OBJECT_VALUE: 'ObjectValue',\n    LIST_VALUE: 'ListValue',\n    INTERFACE_DEF: 'InterfaceDef',\n    UNION_DEF: 'UnionDef',\n    ENUM_DEF: 'EnumDef',\n    ENUM_VALUE: 'EnumValue',\n    FIELD_DEF: 'FieldDef',\n    INPUT_DEF: 'InputDef',\n    INPUT_VALUE_DEF: 'InputValueDef',\n    ARGUMENTS_DEF: 'ArgumentsDef',\n    EXTEND_DEF: 'ExtendDef',\n    DIRECTIVE_DEF: 'DirectiveDef',\n};\nexport const RuleKinds = Object.assign(Object.assign({}, Kind), AdditionalRuleKinds);\n//# sourceMappingURL=types.js.map","import { CompletionItemKind } from 'vscode-languageserver-types';\nimport { parse, visit, } from 'graphql';\nimport { GraphQLBoolean, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, assertAbstractType, doTypesOverlap, getNamedType, getNullableType, isAbstractType, isCompositeType, isInputType, } from 'graphql';\nimport { CharacterStream, onlineParser, RuleKinds, } from 'graphql-language-service-parser';\nimport { forEachState, getDefinitionState, getFieldDef, hintList, objectValues, } from './autocompleteUtils';\nexport function getAutocompleteSuggestions(schema, queryText, cursor, contextToken) {\n    const token = contextToken || getTokenAtPosition(queryText, cursor);\n    const state = token.state.kind === 'Invalid' ? token.state.prevState : token.state;\n    if (!state) {\n        return [];\n    }\n    const kind = state.kind;\n    const step = state.step;\n    const typeInfo = getTypeInfo(schema, token.state);\n    if (kind === RuleKinds.DOCUMENT) {\n        return hintList(token, [\n            { label: 'query', kind: CompletionItemKind.Function },\n            { label: 'mutation', kind: CompletionItemKind.Function },\n            { label: 'subscription', kind: CompletionItemKind.Function },\n            { label: 'fragment', kind: CompletionItemKind.Function },\n            { label: '{', kind: CompletionItemKind.Constructor },\n        ]);\n    }\n    if (kind === RuleKinds.SELECTION_SET ||\n        kind === RuleKinds.FIELD ||\n        kind === RuleKinds.ALIASED_FIELD) {\n        return getSuggestionsForFieldNames(token, typeInfo, schema, kind);\n    }\n    if (kind === RuleKinds.ARGUMENTS ||\n        (kind === RuleKinds.ARGUMENT && step === 0)) {\n        const argDefs = typeInfo.argDefs;\n        if (argDefs) {\n            return hintList(token, argDefs.map(argDef => {\n                var _a;\n                return ({\n                    label: argDef.name,\n                    detail: String(argDef.type),\n                    documentation: (_a = argDef.description) !== null && _a !== void 0 ? _a : undefined,\n                    kind: CompletionItemKind.Variable,\n                });\n            }));\n        }\n    }\n    if (kind === RuleKinds.OBJECT_VALUE ||\n        (kind === RuleKinds.OBJECT_FIELD && step === 0)) {\n        if (typeInfo.objectFieldDefs) {\n            const objectFields = objectValues(typeInfo.objectFieldDefs);\n            const completionKind = kind === RuleKinds.OBJECT_VALUE\n                ? CompletionItemKind.Value\n                : CompletionItemKind.Field;\n            return hintList(token, objectFields.map(field => {\n                var _a;\n                return ({\n                    label: field.name,\n                    detail: String(field.type),\n                    documentation: (_a = field.description) !== null && _a !== void 0 ? _a : undefined,\n                    kind: completionKind,\n                });\n            }));\n        }\n    }\n    if (kind === RuleKinds.ENUM_VALUE ||\n        (kind === RuleKinds.LIST_VALUE && step === 1) ||\n        (kind === RuleKinds.OBJECT_FIELD && step === 2) ||\n        (kind === RuleKinds.ARGUMENT && step === 2)) {\n        return getSuggestionsForInputValues(token, typeInfo, kind);\n    }\n    if (kind === RuleKinds.VARIABLE && step === 1) {\n        const queryVariables = [];\n        visit(parse(queryText, {\n            allowLegacySDLEmptyFields: true,\n            allowLegacySDLImplementsInterfaces: true,\n        }), {\n            VariableDefinition(node) {\n                queryVariables.push(node);\n            },\n        });\n        return hintList(token, queryVariables.map(variableDef => ({\n            label: `$${variableDef.variable.name.value}`,\n            kind: CompletionItemKind.Variable,\n            detail: 'name' in variableDef.type\n                ? variableDef.type.name.value\n                : 'Variable',\n        })));\n    }\n    if ((kind === RuleKinds.TYPE_CONDITION && step === 1) ||\n        (kind === RuleKinds.NAMED_TYPE &&\n            state.prevState != null &&\n            state.prevState.kind === RuleKinds.TYPE_CONDITION)) {\n        return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, kind);\n    }\n    if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {\n        return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, kind);\n    }\n    if ((kind === RuleKinds.VARIABLE_DEFINITION && step === 2) ||\n        (kind === RuleKinds.LIST_TYPE && step === 1) ||\n        (kind === RuleKinds.NAMED_TYPE &&\n            state.prevState &&\n            (state.prevState.kind === RuleKinds.VARIABLE_DEFINITION ||\n                state.prevState.kind === RuleKinds.LIST_TYPE ||\n                state.prevState.kind === RuleKinds.NON_NULL_TYPE))) {\n        return getSuggestionsForVariableDefinition(token, schema, kind);\n    }\n    if (kind === RuleKinds.DIRECTIVE) {\n        return getSuggestionsForDirective(token, state, schema, kind);\n    }\n    return [];\n}\nfunction getSuggestionsForFieldNames(token, typeInfo, schema, _kind) {\n    if (typeInfo.parentType) {\n        const parentType = typeInfo.parentType;\n        let fields = [];\n        if ('getFields' in parentType) {\n            fields = objectValues(parentType.getFields());\n        }\n        if (isCompositeType(parentType)) {\n            fields.push(TypeNameMetaFieldDef);\n        }\n        if (parentType === schema.getQueryType()) {\n            fields.push(SchemaMetaFieldDef, TypeMetaFieldDef);\n        }\n        return hintList(token, fields.map((field, index) => {\n            var _a;\n            return ({\n                sortText: String(index) + field.name,\n                label: field.name,\n                detail: String(field.type),\n                documentation: (_a = field.description) !== null && _a !== void 0 ? _a : undefined,\n                deprecated: field.isDeprecated,\n                isDeprecated: field.isDeprecated,\n                deprecationReason: field.deprecationReason,\n                kind: CompletionItemKind.Field,\n            });\n        }));\n    }\n    return [];\n}\nfunction getSuggestionsForInputValues(token, typeInfo, _kind) {\n    const namedInputType = getNamedType(typeInfo.inputType);\n    if (namedInputType instanceof GraphQLEnumType) {\n        const values = namedInputType.getValues();\n        return hintList(token, values.map((value) => {\n            var _a;\n            return ({\n                label: value.name,\n                detail: String(namedInputType),\n                documentation: (_a = value.description) !== null && _a !== void 0 ? _a : undefined,\n                deprecated: value.isDeprecated,\n                isDeprecated: value.isDeprecated,\n                deprecationReason: value.deprecationReason,\n                kind: CompletionItemKind.EnumMember,\n            });\n        }));\n    }\n    else if (namedInputType === GraphQLBoolean) {\n        return hintList(token, [\n            {\n                label: 'true',\n                detail: String(GraphQLBoolean),\n                documentation: 'Not false.',\n                kind: CompletionItemKind.Variable,\n            },\n            {\n                label: 'false',\n                detail: String(GraphQLBoolean),\n                documentation: 'Not true.',\n                kind: CompletionItemKind.Variable,\n            },\n        ]);\n    }\n    return [];\n}\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {\n    let possibleTypes;\n    if (typeInfo.parentType) {\n        if (isAbstractType(typeInfo.parentType)) {\n            const abstractType = assertAbstractType(typeInfo.parentType);\n            const possibleObjTypes = schema.getPossibleTypes(abstractType);\n            const possibleIfaceMap = Object.create(null);\n            possibleObjTypes.forEach(type => {\n                type.getInterfaces().forEach(iface => {\n                    possibleIfaceMap[iface.name] = iface;\n                });\n            });\n            possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));\n        }\n        else {\n            possibleTypes = [typeInfo.parentType];\n        }\n    }\n    else {\n        const typeMap = schema.getTypeMap();\n        possibleTypes = objectValues(typeMap).filter(isCompositeType);\n    }\n    return hintList(token, possibleTypes.map((type) => {\n        const namedType = getNamedType(type);\n        return {\n            label: String(type),\n            documentation: (namedType && namedType.description) || '',\n            kind: CompletionItemKind.Field,\n        };\n    }));\n}\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, _kind) {\n    const typeMap = schema.getTypeMap();\n    const defState = getDefinitionState(token.state);\n    const fragments = getFragmentDefinitions(queryText);\n    const relevantFrags = fragments.filter(frag => typeMap[frag.typeCondition.name.value] &&\n        !(defState &&\n            defState.kind === RuleKinds.FRAGMENT_DEFINITION &&\n            defState.name === frag.name.value) &&\n        isCompositeType(typeInfo.parentType) &&\n        isCompositeType(typeMap[frag.typeCondition.name.value]) &&\n        doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));\n    return hintList(token, relevantFrags.map(frag => ({\n        label: frag.name.value,\n        detail: String(typeMap[frag.typeCondition.name.value]),\n        documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,\n        kind: CompletionItemKind.Field,\n    })));\n}\nexport function getFragmentDefinitions(queryText) {\n    const fragmentDefs = [];\n    runOnlineParser(queryText, (_, state) => {\n        if (state.kind === RuleKinds.FRAGMENT_DEFINITION &&\n            state.name &&\n            state.type) {\n            fragmentDefs.push({\n                kind: RuleKinds.FRAGMENT_DEFINITION,\n                name: {\n                    kind: 'Name',\n                    value: state.name,\n                },\n                selectionSet: {\n                    kind: RuleKinds.SELECTION_SET,\n                    selections: [],\n                },\n                typeCondition: {\n                    kind: RuleKinds.NAMED_TYPE,\n                    name: {\n                        kind: 'Name',\n                        value: state.type,\n                    },\n                },\n            });\n        }\n    });\n    return fragmentDefs;\n}\nfunction getSuggestionsForVariableDefinition(token, schema, _kind) {\n    const inputTypeMap = schema.getTypeMap();\n    const inputTypes = objectValues(inputTypeMap).filter(isInputType);\n    return hintList(token, inputTypes.map((type) => ({\n        label: type.name,\n        documentation: type.description,\n        kind: CompletionItemKind.Variable,\n    })));\n}\nfunction getSuggestionsForDirective(token, state, schema, _kind) {\n    if (state.prevState && state.prevState.kind) {\n        const directives = schema\n            .getDirectives()\n            .filter(directive => canUseDirective(state.prevState, directive));\n        return hintList(token, directives.map(directive => ({\n            label: directive.name,\n            documentation: directive.description || '',\n            kind: CompletionItemKind.Function,\n        })));\n    }\n    return [];\n}\nexport function getTokenAtPosition(queryText, cursor) {\n    let styleAtCursor = null;\n    let stateAtCursor = null;\n    let stringAtCursor = null;\n    const token = runOnlineParser(queryText, (stream, state, style, index) => {\n        if (index === cursor.line) {\n            if (stream.getCurrentPosition() >= cursor.character) {\n                styleAtCursor = style;\n                stateAtCursor = Object.assign({}, state);\n                stringAtCursor = stream.current();\n                return 'BREAK';\n            }\n        }\n    });\n    return {\n        start: token.start,\n        end: token.end,\n        string: stringAtCursor || token.string,\n        state: stateAtCursor || token.state,\n        style: styleAtCursor || token.style,\n    };\n}\nexport function runOnlineParser(queryText, callback) {\n    const lines = queryText.split('\\n');\n    const parser = onlineParser();\n    let state = parser.startState();\n    let style = '';\n    let stream = new CharacterStream('');\n    for (let i = 0; i < lines.length; i++) {\n        stream = new CharacterStream(lines[i]);\n        while (!stream.eol()) {\n            style = parser.token(stream, state);\n            const code = callback(stream, state, style, i);\n            if (code === 'BREAK') {\n                break;\n            }\n        }\n        callback(stream, state, style, i);\n        if (!state.kind) {\n            state = parser.startState();\n        }\n    }\n    return {\n        start: stream.getStartOfToken(),\n        end: stream.getCurrentPosition(),\n        string: stream.current(),\n        state,\n        style,\n    };\n}\nexport function canUseDirective(state, directive) {\n    if (!state || !state.kind) {\n        return false;\n    }\n    const kind = state.kind;\n    const locations = directive.locations;\n    switch (kind) {\n        case RuleKinds.QUERY:\n            return locations.indexOf('QUERY') !== -1;\n        case RuleKinds.MUTATION:\n            return locations.indexOf('MUTATION') !== -1;\n        case RuleKinds.SUBSCRIPTION:\n            return locations.indexOf('SUBSCRIPTION') !== -1;\n        case RuleKinds.FIELD:\n        case RuleKinds.ALIASED_FIELD:\n            return locations.indexOf('FIELD') !== -1;\n        case RuleKinds.FRAGMENT_DEFINITION:\n            return locations.indexOf('FRAGMENT_DEFINITION') !== -1;\n        case RuleKinds.FRAGMENT_SPREAD:\n            return locations.indexOf('FRAGMENT_SPREAD') !== -1;\n        case RuleKinds.INLINE_FRAGMENT:\n            return locations.indexOf('INLINE_FRAGMENT') !== -1;\n        case RuleKinds.SCHEMA_DEF:\n            return locations.indexOf('SCHEMA') !== -1;\n        case RuleKinds.SCALAR_DEF:\n            return locations.indexOf('SCALAR') !== -1;\n        case RuleKinds.OBJECT_TYPE_DEF:\n            return locations.indexOf('OBJECT') !== -1;\n        case RuleKinds.FIELD_DEF:\n            return locations.indexOf('FIELD_DEFINITION') !== -1;\n        case RuleKinds.INTERFACE_DEF:\n            return locations.indexOf('INTERFACE') !== -1;\n        case RuleKinds.UNION_DEF:\n            return locations.indexOf('UNION') !== -1;\n        case RuleKinds.ENUM_DEF:\n            return locations.indexOf('ENUM') !== -1;\n        case RuleKinds.ENUM_VALUE:\n            return locations.indexOf('ENUM_VALUE') !== -1;\n        case RuleKinds.INPUT_DEF:\n            return locations.indexOf('INPUT_OBJECT') !== -1;\n        case RuleKinds.INPUT_VALUE_DEF:\n            const prevStateKind = state.prevState && state.prevState.kind;\n            switch (prevStateKind) {\n                case RuleKinds.ARGUMENTS_DEF:\n                    return locations.indexOf('ARGUMENT_DEFINITION') !== -1;\n                case RuleKinds.INPUT_DEF:\n                    return locations.indexOf('INPUT_FIELD_DEFINITION') !== -1;\n            }\n    }\n    return false;\n}\nexport function getTypeInfo(schema, tokenState) {\n    let argDef;\n    let argDefs;\n    let directiveDef;\n    let enumValue;\n    let fieldDef;\n    let inputType;\n    let objectFieldDefs;\n    let parentType;\n    let type;\n    forEachState(tokenState, state => {\n        switch (state.kind) {\n            case RuleKinds.QUERY:\n            case 'ShortQuery':\n                type = schema.getQueryType();\n                break;\n            case RuleKinds.MUTATION:\n                type = schema.getMutationType();\n                break;\n            case RuleKinds.SUBSCRIPTION:\n                type = schema.getSubscriptionType();\n                break;\n            case RuleKinds.INLINE_FRAGMENT:\n            case RuleKinds.FRAGMENT_DEFINITION:\n                if (state.type) {\n                    type = schema.getType(state.type);\n                }\n                break;\n            case RuleKinds.FIELD:\n            case RuleKinds.ALIASED_FIELD:\n                if (!type || !state.name) {\n                    fieldDef = null;\n                }\n                else {\n                    fieldDef = parentType\n                        ? getFieldDef(schema, parentType, state.name)\n                        : null;\n                    type = fieldDef ? fieldDef.type : null;\n                }\n                break;\n            case RuleKinds.SELECTION_SET:\n                parentType = getNamedType(type);\n                break;\n            case RuleKinds.DIRECTIVE:\n                directiveDef = state.name ? schema.getDirective(state.name) : null;\n                break;\n            case RuleKinds.ARGUMENTS:\n                if (!state.prevState) {\n                    argDefs = null;\n                }\n                else {\n                    switch (state.prevState.kind) {\n                        case RuleKinds.FIELD:\n                            argDefs = fieldDef && fieldDef.args;\n                            break;\n                        case RuleKinds.DIRECTIVE:\n                            argDefs = directiveDef && directiveDef.args;\n                            break;\n                        case RuleKinds.ALIASED_FIELD:\n                            const name = state.prevState && state.prevState.name;\n                            if (!name) {\n                                argDefs = null;\n                                break;\n                            }\n                            const field = parentType\n                                ? getFieldDef(schema, parentType, name)\n                                : null;\n                            if (!field) {\n                                argDefs = null;\n                                break;\n                            }\n                            argDefs = field.args;\n                            break;\n                        default:\n                            argDefs = null;\n                            break;\n                    }\n                }\n                break;\n            case RuleKinds.ARGUMENT:\n                if (argDefs) {\n                    for (let i = 0; i < argDefs.length; i++) {\n                        if (argDefs[i].name === state.name) {\n                            argDef = argDefs[i];\n                            break;\n                        }\n                    }\n                }\n                inputType = argDef && argDef.type;\n                break;\n            case RuleKinds.ENUM_VALUE:\n                const enumType = getNamedType(inputType);\n                enumValue =\n                    enumType instanceof GraphQLEnumType\n                        ? find(enumType.getValues(), (val) => val.value === state.name)\n                        : null;\n                break;\n            case RuleKinds.LIST_VALUE:\n                const nullableType = getNullableType(inputType);\n                inputType =\n                    nullableType instanceof GraphQLList ? nullableType.ofType : null;\n                break;\n            case RuleKinds.OBJECT_VALUE:\n                const objectType = getNamedType(inputType);\n                objectFieldDefs =\n                    objectType instanceof GraphQLInputObjectType\n                        ? objectType.getFields()\n                        : null;\n                break;\n            case RuleKinds.OBJECT_FIELD:\n                const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;\n                inputType = objectField && objectField.type;\n                break;\n            case RuleKinds.NAMED_TYPE:\n                if (state.name) {\n                    type = schema.getType(state.name);\n                }\n                break;\n        }\n    });\n    return {\n        argDef,\n        argDefs,\n        directiveDef,\n        enumValue,\n        fieldDef,\n        inputType,\n        objectFieldDefs,\n        parentType,\n        type,\n    };\n}\nfunction find(array, predicate) {\n    for (let i = 0; i < array.length; i++) {\n        if (predicate(array[i])) {\n            return array[i];\n        }\n    }\n    return null;\n}\n//# sourceMappingURL=getAutocompleteSuggestions.js.map","export class Range {\n    constructor(start, end) {\n        this.containsPosition = (position) => {\n            if (this.start.line === position.line) {\n                return this.start.character <= position.character;\n            }\n            else if (this.end.line === position.line) {\n                return this.end.character >= position.character;\n            }\n            else {\n                return this.start.line <= position.line && this.end.line >= position.line;\n            }\n        };\n        this.start = start;\n        this.end = end;\n    }\n    setStart(line, character) {\n        this.start = new Position(line, character);\n    }\n    setEnd(line, character) {\n        this.end = new Position(line, character);\n    }\n}\nexport class Position {\n    constructor(line, character) {\n        this.lessThanOrEqualTo = (position) => this.line < position.line ||\n            (this.line === position.line && this.character <= position.character);\n        this.line = line;\n        this.character = character;\n    }\n    setLine(line) {\n        this.line = line;\n    }\n    setCharacter(character) {\n        this.character = character;\n    }\n}\nexport function offsetToPosition(text, loc) {\n    const EOL = '\\n';\n    const buf = text.slice(0, loc);\n    const lines = buf.split(EOL).length - 1;\n    const lastLineIndex = buf.lastIndexOf(EOL);\n    return new Position(lines, loc - lastLineIndex - 1);\n}\nexport function locToRange(text, loc) {\n    const start = offsetToPosition(text, loc.start);\n    const end = offsetToPosition(text, loc.end);\n    return new Range(start, end);\n}\n//# sourceMappingURL=Range.js.map","import { Kind } from \"./kinds.mjs\";\nexport function isDefinitionNode(node) {\n  return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);\n}\nexport function isExecutableDefinitionNode(node) {\n  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;\n}\nexport function isSelectionNode(node) {\n  return node.kind === Kind.FIELD || node.kind === Kind.FRAGMENT_SPREAD || node.kind === Kind.INLINE_FRAGMENT;\n}\nexport function isValueNode(node) {\n  return node.kind === Kind.VARIABLE || node.kind === Kind.INT || node.kind === Kind.FLOAT || node.kind === Kind.STRING || node.kind === Kind.BOOLEAN || node.kind === Kind.NULL || node.kind === Kind.ENUM || node.kind === Kind.LIST || node.kind === Kind.OBJECT;\n}\nexport function isTypeNode(node) {\n  return node.kind === Kind.NAMED_TYPE || node.kind === Kind.LIST_TYPE || node.kind === Kind.NON_NULL_TYPE;\n}\nexport function isTypeSystemDefinitionNode(node) {\n  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;\n}\nexport function isTypeDefinitionNode(node) {\n  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;\n}\nexport function isTypeSystemExtensionNode(node) {\n  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);\n}\nexport function isTypeExtensionNode(node) {\n  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isExecutableDefinitionNode } from \"../../language/predicates.mjs\";\n\n/**\n * Executable definitions\n *\n * A GraphQL document is only valid for execution if all definitions are either\n * operation or fragment definitions.\n */\nexport function ExecutableDefinitionsRule(context) {\n  return {\n    Document: function Document(node) {\n      for (var _i2 = 0, _node$definitions2 = node.definitions; _i2 < _node$definitions2.length; _i2++) {\n        var definition = _node$definitions2[_i2];\n\n        if (!isExecutableDefinitionNode(definition)) {\n          var defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? 'schema' : '\"' + definition.name.value + '\"';\n          context.reportError(new GraphQLError(\"The \".concat(defName, \" definition is not executable.\"), definition));\n        }\n      }\n\n      return false;\n    }\n  };\n}\n","import didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isTypeDefinitionNode, isTypeSystemDefinitionNode, isTypeSystemExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedScalarTypes } from \"../../type/scalars.mjs\";\nimport { introspectionTypes } from \"../../type/introspection.mjs\";\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n */\nexport function KnownTypeNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));\n  return {\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\n      var typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;\n        var isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && isStandardTypeName(typeName)) {\n          return;\n        }\n\n        var suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);\n        context.reportError(new GraphQLError(\"Unknown type \\\"\".concat(typeName, \"\\\".\") + didYouMean(suggestedTypes), node));\n      }\n    }\n  };\n}\nvar standardTypeNames = [].concat(specifiedScalarTypes, introspectionTypes).map(function (type) {\n  return type.name;\n});\n\nfunction isStandardTypeName(typeName) {\n  return standardTypeNames.indexOf(typeName) !== -1;\n}\n\nfunction isSDLNode(value) {\n  return !Array.isArray(value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));\n}\n","import inspect from \"../jsutils/inspect.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { GraphQLList, GraphQLNonNull } from \"../type/definition.mjs\";\n/**\n * Given a Schema and an AST node describing a type, return a GraphQLType\n * definition which applies to that type. For example, if provided the parsed\n * AST node for `[User]`, a GraphQLList instance will be returned, containing\n * the type called \"User\" found in the schema. If a type called \"User\" is not\n * found in the schema, then undefined will be returned.\n */\n\n/* eslint-disable no-redeclare */\n\nexport function typeFromAST(schema, typeNode) {\n  /* eslint-enable no-redeclare */\n  var innerType;\n\n  if (typeNode.kind === Kind.LIST_TYPE) {\n    innerType = typeFromAST(schema, typeNode.type);\n    return innerType && GraphQLList(innerType);\n  }\n\n  if (typeNode.kind === Kind.NON_NULL_TYPE) {\n    innerType = typeFromAST(schema, typeNode.type);\n    return innerType && GraphQLNonNull(innerType);\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (typeNode.kind === Kind.NAMED_TYPE) {\n    return schema.getType(typeNode.name.value);\n  } // istanbul ignore next (Not reachable. All possible type nodes have been considered)\n\n\n  false || invariant(0, 'Unexpected type node: ' + inspect(typeNode));\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Known fragment names\n *\n * A GraphQL document is only valid if all `...Fragment` fragment spreads refer\n * to fragments defined in the same document.\n */\nexport function KnownFragmentNamesRule(context) {\n  return {\n    FragmentSpread: function FragmentSpread(node) {\n      var fragmentName = node.name.value;\n      var fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        context.reportError(new GraphQLError(\"Unknown fragment \\\"\".concat(fragmentName, \"\\\".\"), node.name));\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * No unused fragments\n *\n * A GraphQL document is only valid if all fragment definitions are spread\n * within operations, or spread within other fragments spread within operations.\n */\nexport function NoUnusedFragmentsRule(context) {\n  var operationDefs = [];\n  var fragmentDefs = [];\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      operationDefs.push(node);\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fragmentDefs.push(node);\n      return false;\n    },\n    Document: {\n      leave: function leave() {\n        var fragmentNameUsed = Object.create(null);\n\n        for (var _i2 = 0; _i2 < operationDefs.length; _i2++) {\n          var operation = operationDefs[_i2];\n\n          for (var _i4 = 0, _context$getRecursive2 = context.getRecursivelyReferencedFragments(operation); _i4 < _context$getRecursive2.length; _i4++) {\n            var fragment = _context$getRecursive2[_i4];\n            fragmentNameUsed[fragment.name.value] = true;\n          }\n        }\n\n        for (var _i6 = 0; _i6 < fragmentDefs.length; _i6++) {\n          var fragmentDef = fragmentDefs[_i6];\n          var fragName = fragmentDef.name.value;\n\n          if (fragmentNameUsed[fragName] !== true) {\n            context.reportError(new GraphQLError(\"Fragment \\\"\".concat(fragName, \"\\\" is never used.\"), fragmentDef));\n          }\n        }\n      }\n    }\n  };\n}\n","import inspect from \"../../jsutils/inspect.mjs\";\nimport invariant from \"../../jsutils/invariant.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { DirectiveLocation } from \"../../language/directiveLocation.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\n\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n */\nexport function KnownDirectivesRule(context) {\n  var locationsMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    locationsMap[directive.name] = directive.locations;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      locationsMap[def.name.value] = def.locations.map(function (name) {\n        return name.value;\n      });\n    }\n  }\n\n  return {\n    Directive: function Directive(node, _key, _parent, _path, ancestors) {\n      var name = node.name.value;\n      var locations = locationsMap[name];\n\n      if (!locations) {\n        context.reportError(new GraphQLError(\"Unknown directive \\\"@\".concat(name, \"\\\".\"), node));\n        return;\n      }\n\n      var candidateLocation = getDirectiveLocationForASTPath(ancestors);\n\n      if (candidateLocation && locations.indexOf(candidateLocation) === -1) {\n        context.reportError(new GraphQLError(\"Directive \\\"@\".concat(name, \"\\\" may not be used on \").concat(candidateLocation, \".\"), node));\n      }\n    }\n  };\n}\n\nfunction getDirectiveLocationForASTPath(ancestors) {\n  var appliedTo = ancestors[ancestors.length - 1];\n  !Array.isArray(appliedTo) || invariant(0);\n\n  switch (appliedTo.kind) {\n    case Kind.OPERATION_DEFINITION:\n      return getDirectiveLocationForOperation(appliedTo.operation);\n\n    case Kind.FIELD:\n      return DirectiveLocation.FIELD;\n\n    case Kind.FRAGMENT_SPREAD:\n      return DirectiveLocation.FRAGMENT_SPREAD;\n\n    case Kind.INLINE_FRAGMENT:\n      return DirectiveLocation.INLINE_FRAGMENT;\n\n    case Kind.FRAGMENT_DEFINITION:\n      return DirectiveLocation.FRAGMENT_DEFINITION;\n\n    case Kind.VARIABLE_DEFINITION:\n      return DirectiveLocation.VARIABLE_DEFINITION;\n\n    case Kind.SCHEMA_DEFINITION:\n    case Kind.SCHEMA_EXTENSION:\n      return DirectiveLocation.SCHEMA;\n\n    case Kind.SCALAR_TYPE_DEFINITION:\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return DirectiveLocation.SCALAR;\n\n    case Kind.OBJECT_TYPE_DEFINITION:\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.OBJECT;\n\n    case Kind.FIELD_DEFINITION:\n      return DirectiveLocation.FIELD_DEFINITION;\n\n    case Kind.INTERFACE_TYPE_DEFINITION:\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return DirectiveLocation.INTERFACE;\n\n    case Kind.UNION_TYPE_DEFINITION:\n    case Kind.UNION_TYPE_EXTENSION:\n      return DirectiveLocation.UNION;\n\n    case Kind.ENUM_TYPE_DEFINITION:\n    case Kind.ENUM_TYPE_EXTENSION:\n      return DirectiveLocation.ENUM;\n\n    case Kind.ENUM_VALUE_DEFINITION:\n      return DirectiveLocation.ENUM_VALUE;\n\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.INPUT_OBJECT;\n\n    case Kind.INPUT_VALUE_DEFINITION:\n      {\n        var parentNode = ancestors[ancestors.length - 3];\n        return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;\n      }\n  }\n}\n\nfunction getDirectiveLocationForOperation(operation) {\n  switch (operation) {\n    case 'query':\n      return DirectiveLocation.QUERY;\n\n    case 'mutation':\n      return DirectiveLocation.MUTATION;\n\n    case 'subscription':\n      return DirectiveLocation.SUBSCRIPTION;\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || invariant(0, 'Unexpected operation: ' + inspect(operation));\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isTypeDefinitionNode, isTypeExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\n\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n */\nexport function UniqueDirectivesPerLocationRule(context) {\n  var uniqueDirectiveMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  var schemaDirectives = Object.create(null);\n  var typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      if (node.directives == null) {\n        return;\n      }\n\n      var seenDirectives;\n\n      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {\n        seenDirectives = schemaDirectives;\n      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {\n        var typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n\n      for (var _i6 = 0, _node$directives2 = node.directives; _i6 < _node$directives2.length; _i6++) {\n        var _directive = _node$directives2[_i6];\n        var directiveName = _directive.name.value;\n\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(new GraphQLError(\"The directive \\\"@\".concat(directiveName, \"\\\" can only be used once at this location.\"), [seenDirectives[directiveName], _directive]));\n          } else {\n            seenDirectives[directiveName] = _directive;\n          }\n        }\n      }\n    }\n  };\n}\n","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\n\n/**\n * Known argument names\n *\n * A GraphQL field is only valid if all supplied arguments are defined by\n * that field.\n */\nexport function KnownArgumentNamesRule(context) {\n  return _objectSpread(_objectSpread({}, KnownArgumentNamesOnDirectivesRule(context)), {}, {\n    Argument: function Argument(argNode) {\n      var argDef = context.getArgument();\n      var fieldDef = context.getFieldDef();\n      var parentType = context.getParentType();\n\n      if (!argDef && fieldDef && parentType) {\n        var argName = argNode.name.value;\n        var knownArgsNames = fieldDef.args.map(function (arg) {\n          return arg.name;\n        });\n        var suggestions = suggestionList(argName, knownArgsNames);\n        context.reportError(new GraphQLError(\"Unknown argument \\\"\".concat(argName, \"\\\" on field \\\"\").concat(parentType.name, \".\").concat(fieldDef.name, \"\\\".\") + didYouMean(suggestions), argNode));\n      }\n    }\n  });\n}\n/**\n * @internal\n */\n\nexport function KnownArgumentNamesOnDirectivesRule(context) {\n  var directiveArgs = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    directiveArgs[directive.name] = directive.args.map(function (arg) {\n      return arg.name;\n    });\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];\n      directiveArgs[def.name.value] = argsNodes.map(function (arg) {\n        return arg.name.value;\n      });\n    }\n  }\n\n  return {\n    Directive: function Directive(directiveNode) {\n      var directiveName = directiveNode.name.value;\n      var knownArgs = directiveArgs[directiveName];\n\n      if (directiveNode.arguments && knownArgs) {\n        for (var _i6 = 0, _directiveNode$argume2 = directiveNode.arguments; _i6 < _directiveNode$argume2.length; _i6++) {\n          var argNode = _directiveNode$argume2[_i6];\n          var argName = argNode.name.value;\n\n          if (knownArgs.indexOf(argName) === -1) {\n            var suggestions = suggestionList(argName, knownArgs);\n            context.reportError(new GraphQLError(\"Unknown argument \\\"\".concat(argName, \"\\\" on directive \\\"@\").concat(directiveName, \"\\\".\") + didYouMean(suggestions), argNode));\n          }\n        }\n      }\n\n      return false;\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique argument names\n *\n * A GraphQL field or directive is only valid if all supplied arguments are\n * uniquely named.\n */\nexport function UniqueArgumentNamesRule(context) {\n  var knownArgNames = Object.create(null);\n  return {\n    Field: function Field() {\n      knownArgNames = Object.create(null);\n    },\n    Directive: function Directive() {\n      knownArgNames = Object.create(null);\n    },\n    Argument: function Argument(node) {\n      var argName = node.name.value;\n\n      if (knownArgNames[argName]) {\n        context.reportError(new GraphQLError(\"There can be only one argument named \\\"\".concat(argName, \"\\\".\"), [knownArgNames[argName], node.name]));\n      } else {\n        knownArgNames[argName] = node.name;\n      }\n\n      return false;\n    }\n  };\n}\n","import objectValues from \"../../polyfills/objectValues.mjs\";\nimport keyMap from \"../../jsutils/keyMap.mjs\";\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { isLeafType, isInputObjectType, isListType, isNonNullType, isRequiredInputField, getNullableType, getNamedType } from \"../../type/definition.mjs\";\n\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n */\nexport function ValuesOfCorrectTypeRule(context) {\n  return {\n    ListValue: function ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      var type = getNullableType(context.getParentInputType());\n\n      if (!isListType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n    ObjectValue: function ObjectValue(node) {\n      var type = getNamedType(context.getInputType());\n\n      if (!isInputObjectType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n\n      var fieldNodeMap = keyMap(node.fields, function (field) {\n        return field.name.value;\n      });\n\n      for (var _i2 = 0, _objectValues2 = objectValues(type.getFields()); _i2 < _objectValues2.length; _i2++) {\n        var fieldDef = _objectValues2[_i2];\n        var fieldNode = fieldNodeMap[fieldDef.name];\n\n        if (!fieldNode && isRequiredInputField(fieldDef)) {\n          var typeStr = inspect(fieldDef.type);\n          context.reportError(new GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldDef.name, \"\\\" of required type \\\"\").concat(typeStr, \"\\\" was not provided.\"), node));\n        }\n      }\n    },\n    ObjectField: function ObjectField(node) {\n      var parentType = getNamedType(context.getParentInputType());\n      var fieldType = context.getInputType();\n\n      if (!fieldType && isInputObjectType(parentType)) {\n        var suggestions = suggestionList(node.name.value, Object.keys(parentType.getFields()));\n        context.reportError(new GraphQLError(\"Field \\\"\".concat(node.name.value, \"\\\" is not defined by type \\\"\").concat(parentType.name, \"\\\".\") + didYouMean(suggestions), node));\n      }\n    },\n    NullValue: function NullValue(node) {\n      var type = context.getInputType();\n\n      if (isNonNullType(type)) {\n        context.reportError(new GraphQLError(\"Expected value of type \\\"\".concat(inspect(type), \"\\\", found \").concat(print(node), \".\"), node));\n      }\n    },\n    EnumValue: function EnumValue(node) {\n      return isValidValueNode(context, node);\n    },\n    IntValue: function IntValue(node) {\n      return isValidValueNode(context, node);\n    },\n    FloatValue: function FloatValue(node) {\n      return isValidValueNode(context, node);\n    },\n    StringValue: function StringValue(node) {\n      return isValidValueNode(context, node);\n    },\n    BooleanValue: function BooleanValue(node) {\n      return isValidValueNode(context, node);\n    }\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  var locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  var type = getNamedType(locationType);\n\n  if (!isLeafType(type)) {\n    var typeStr = inspect(locationType);\n    context.reportError(new GraphQLError(\"Expected value of type \\\"\".concat(typeStr, \"\\\", found \").concat(print(node), \".\"), node));\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n\n  try {\n    var parseResult = type.parseLiteral(node, undefined\n    /* variables */\n    );\n\n    if (parseResult === undefined) {\n      var _typeStr = inspect(locationType);\n\n      context.reportError(new GraphQLError(\"Expected value of type \\\"\".concat(_typeStr, \"\\\", found \").concat(print(node), \".\"), node));\n    }\n  } catch (error) {\n    var _typeStr2 = inspect(locationType);\n\n    if (error instanceof GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(new GraphQLError(\"Expected value of type \\\"\".concat(_typeStr2, \"\\\", found \").concat(print(node), \"; \") + error.message, node, undefined, undefined, undefined, error));\n    }\n  }\n}\n","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport keyMap from \"../../jsutils/keyMap.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\nimport { isType, isRequiredArgument } from \"../../type/definition.mjs\";\n\n/**\n * Provided required arguments\n *\n * A field or directive is only valid if all required (non-null without a\n * default value) field arguments have been provided.\n */\nexport function ProvidedRequiredArgumentsRule(context) {\n  return _objectSpread(_objectSpread({}, ProvidedRequiredArgumentsOnDirectivesRule(context)), {}, {\n    Field: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave: function leave(fieldNode) {\n        var _fieldNode$arguments;\n\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          return false;\n        } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n        var argNodes = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];\n        var argNodeMap = keyMap(argNodes, function (arg) {\n          return arg.name.value;\n        });\n\n        for (var _i2 = 0, _fieldDef$args2 = fieldDef.args; _i2 < _fieldDef$args2.length; _i2++) {\n          var argDef = _fieldDef$args2[_i2];\n          var argNode = argNodeMap[argDef.name];\n\n          if (!argNode && isRequiredArgument(argDef)) {\n            var argTypeStr = inspect(argDef.type);\n            context.reportError(new GraphQLError(\"Field \\\"\".concat(fieldDef.name, \"\\\" argument \\\"\").concat(argDef.name, \"\\\" of type \\\"\").concat(argTypeStr, \"\\\" is required, but it was not provided.\"), fieldNode));\n          }\n        }\n      }\n    }\n  });\n}\n/**\n * @internal\n */\n\nexport function ProvidedRequiredArgumentsOnDirectivesRule(context) {\n  var requiredArgsMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i4 = 0; _i4 < definedDirectives.length; _i4++) {\n    var directive = definedDirectives[_i4];\n    requiredArgsMap[directive.name] = keyMap(directive.args.filter(isRequiredArgument), function (arg) {\n      return arg.name;\n    });\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i6 = 0; _i6 < astDefinitions.length; _i6++) {\n    var def = astDefinitions[_i6];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];\n      requiredArgsMap[def.name.value] = keyMap(argNodes.filter(isRequiredArgumentNode), function (arg) {\n        return arg.name.value;\n      });\n    }\n  }\n\n  return {\n    Directive: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave: function leave(directiveNode) {\n        var directiveName = directiveNode.name.value;\n        var requiredArgs = requiredArgsMap[directiveName];\n\n        if (requiredArgs) {\n          var _directiveNode$argume;\n\n          // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n          var _argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];\n\n          var argNodeMap = keyMap(_argNodes, function (arg) {\n            return arg.name.value;\n          });\n\n          for (var _i8 = 0, _Object$keys2 = Object.keys(requiredArgs); _i8 < _Object$keys2.length; _i8++) {\n            var argName = _Object$keys2[_i8];\n\n            if (!argNodeMap[argName]) {\n              var argType = requiredArgs[argName].type;\n              var argTypeStr = isType(argType) ? inspect(argType) : print(argType);\n              context.reportError(new GraphQLError(\"Directive \\\"@\".concat(directiveName, \"\\\" argument \\\"\").concat(argName, \"\\\" of type \\\"\").concat(argTypeStr, \"\\\" is required, but it was not provided.\"), directiveNode));\n            }\n          }\n        }\n      }\n    }\n  };\n}\n\nfunction isRequiredArgumentNode(arg) {\n  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;\n}\n","import inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isNonNullType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\nimport { isTypeSubTypeOf } from \"../../utilities/typeComparators.mjs\";\n\n/**\n * Variables passed to field arguments conform to type\n */\nexport function VariablesInAllowedPositionRule(context) {\n  var varDefMap = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        varDefMap = Object.create(null);\n      },\n      leave: function leave(operation) {\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        for (var _i2 = 0; _i2 < usages.length; _i2++) {\n          var _ref2 = usages[_i2];\n          var node = _ref2.node;\n          var type = _ref2.type;\n          var defaultValue = _ref2.defaultValue;\n          var varName = node.name.value;\n          var varDef = varDefMap[varName];\n\n          if (varDef && type) {\n            // A var type is allowed if it is the same or more strict (e.g. is\n            // a subtype of) than the expected type. It can be more strict if\n            // the variable type is non-null when the expected type is nullable.\n            // If both are list types, the variable item type can be more strict\n            // than the expected item type (contravariant).\n            var schema = context.getSchema();\n            var varType = typeFromAST(schema, varDef.type);\n\n            if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {\n              var varTypeStr = inspect(varType);\n              var typeStr = inspect(type);\n              context.reportError(new GraphQLError(\"Variable \\\"$\".concat(varName, \"\\\" of type \\\"\").concat(varTypeStr, \"\\\" used in position expecting type \\\"\").concat(typeStr, \"\\\".\"), [varDef, node]));\n            }\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      varDefMap[node.variable.name.value] = node;\n    }\n  };\n}\n/**\n * Returns true if the variable is allowed in the location it was found,\n * which includes considering if default values exist for either the variable\n * or the location at which it is located.\n */\n\nfunction allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {\n  if (isNonNullType(locationType) && !isNonNullType(varType)) {\n    var hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;\n    var hasLocationDefaultValue = locationDefaultValue !== undefined;\n\n    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {\n      return false;\n    }\n\n    var nullableLocationType = locationType.ofType;\n    return isTypeSubTypeOf(schema, varType, nullableLocationType);\n  }\n\n  return isTypeSubTypeOf(schema, varType, locationType);\n}\n","import find from \"../../polyfills/find.mjs\";\nimport objectEntries from \"../../polyfills/objectEntries.mjs\";\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { getNamedType, isNonNullType, isLeafType, isObjectType, isListType, isInterfaceType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var responseName = _ref[0],\n          subReason = _ref[1];\n      return \"subfields \\\"\".concat(responseName, \"\\\" conflict because \") + reasonMessage(subReason);\n    }).join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\n\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  var cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n\n      for (var _i2 = 0; _i2 < conflicts.length; _i2++) {\n        var _ref3 = conflicts[_i2];\n        var _ref2$ = _ref3[0];\n        var responseName = _ref2$[0];\n        var reason = _ref2$[1];\n        var fields1 = _ref3[1];\n        var fields2 = _ref3[2];\n        var reasonMsg = reasonMessage(reason);\n        context.reportError(new GraphQLError(\"Fields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMsg, \". Use different aliases on the fields to fetch both if this was intentional.\"), fields1.concat(fields2)));\n      }\n    }\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n      fieldMap = _getFieldsAndFragment[0],\n      fragmentNames = _getFieldsAndFragment[1]; // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (var i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (var j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  var fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n      fieldMap2 = _getReferencedFieldsA[0],\n      fragmentNames2 = _getReferencedFieldsA[1]; // Do not compare a fragment's fieldMap to itself.\n\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (var i = 0; i < fragmentNames2.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n      fieldMap1 = _getReferencedFieldsA2[0],\n      fragmentNames1 = _getReferencedFieldsA2[1];\n\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n      fieldMap2 = _getReferencedFieldsA3[0],\n      fragmentNames2 = _getReferencedFieldsA3[1]; // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n      fieldMap1 = _getFieldsAndFragment2[0],\n      fragmentNames1 = _getFieldsAndFragment2[1];\n\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n      fieldMap2 = _getFieldsAndFragment3[0],\n      fragmentNames2 = _getFieldsAndFragment3[1]; // (H) First, collect all conflicts between these two collections of field.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  if (fragmentNames2.length !== 0) {\n    for (var j = 0; j < fragmentNames2.length; j++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\n    }\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n\n  if (fragmentNames1.length !== 0) {\n    for (var i = 0; i < fragmentNames1.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\n    }\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n\n  for (var _i3 = 0; _i3 < fragmentNames1.length; _i3++) {\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i3], fragmentNames2[_j]);\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (var _i5 = 0, _objectEntries2 = objectEntries(fieldMap); _i5 < _objectEntries2.length; _i5++) {\n    var _ref5 = _objectEntries2[_i5];\n    var responseName = _ref5[0];\n    var fields = _ref5[1];\n\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (var _i7 = 0, _Object$keys2 = Object.keys(fieldMap1); _i7 < _Object$keys2.length; _i7++) {\n    var responseName = _Object$keys2[_i7];\n    var fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      var fields1 = fieldMap1[responseName];\n\n      for (var i = 0; i < fields1.length; i++) {\n        for (var j = 0; j < fields2.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var parentType1 = field1[0],\n      node1 = field1[1],\n      def1 = field1[2];\n  var parentType2 = field2[0],\n      node2 = field2[1],\n      def2 = field2[2]; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);\n\n  if (!areMutuallyExclusive) {\n    var _node1$arguments, _node2$arguments;\n\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [[responseName, \"\\\"\".concat(name1, \"\\\" and \\\"\").concat(name2, \"\\\" are different fields\")], [node1], [node2]];\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n    var args1 = (_node1$arguments = node1.arguments) !== null && _node1$arguments !== void 0 ? _node1$arguments : []; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n    var args2 = (_node2$arguments = node2.arguments) !== null && _node2$arguments !== void 0 ? _node2$arguments : []; // Two field calls must have the same arguments.\n\n    if (!sameArguments(args1, args2)) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  } // The return type for each field.\n\n\n  var type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  var type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, \"they return conflicting types \\\"\".concat(inspect(type1), \"\\\" and \\\"\").concat(inspect(type2), \"\\\"\")], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n\n  return arguments1.every(function (argument1) {\n    var argument2 = find(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n\n    if (!argument2) {\n      return false;\n    }\n\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return print(value1) === print(value2);\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (!cached) {\n    var nodeAndDefs = Object.create(null);\n    var fragmentNames = Object.create(null);\n\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n\n  return cached;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  var fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (var _i9 = 0, _selectionSet$selecti2 = selectionSet.selections; _i9 < _selectionSet$selecti2.length; _i9++) {\n    var selection = _selectionSet$selecti2[_i9];\n\n    switch (selection.kind) {\n      case Kind.FIELD:\n        {\n          var fieldName = selection.name.value;\n          var fieldDef = void 0;\n\n          if (isObjectType(parentType) || isInterfaceType(parentType)) {\n            fieldDef = parentType.getFields()[fieldName];\n          }\n\n          var responseName = selection.alias ? selection.alias.value : fieldName;\n\n          if (!nodeAndDefs[responseName]) {\n            nodeAndDefs[responseName] = [];\n          }\n\n          nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n          break;\n        }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT:\n        {\n          var typeCondition = selection.typeCondition;\n          var inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\n\n          _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n\n          break;\n        }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref6) {\n      var reason = _ref6[0];\n      return reason;\n    })], conflicts.reduce(function (allFields, _ref7) {\n      var fields1 = _ref7[1];\n      return allFields.concat(fields1);\n    }, [node1]), conflicts.reduce(function (allFields, _ref8) {\n      var fields2 = _ref8[2];\n      return allFields.concat(fields2);\n    }, [node2])];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\n\n\nvar PairSet = /*#__PURE__*/function () {\n  function PairSet() {\n    this._data = Object.create(null);\n  }\n\n  var _proto = PairSet.prototype;\n\n  _proto.has = function has(a, b, areMutuallyExclusive) {\n    var first = this._data[a];\n    var result = first && first[b];\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n\n\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n\n    return true;\n  };\n\n  _proto.add = function add(a, b, areMutuallyExclusive) {\n    _pairSetAdd(this._data, a, b, areMutuallyExclusive);\n\n    _pairSetAdd(this._data, b, a, areMutuallyExclusive);\n  };\n\n  return PairSet;\n}();\n\nfunction _pairSetAdd(data, a, b, areMutuallyExclusive) {\n  var map = data[a];\n\n  if (!map) {\n    map = Object.create(null);\n    data[a] = map;\n  }\n\n  map[b] = areMutuallyExclusive;\n}\n","var _defKindToExtKind;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport invariant from \"../../jsutils/invariant.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isTypeDefinitionNode } from \"../../language/predicates.mjs\";\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType } from \"../../type/definition.mjs\";\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nexport function PossibleTypeExtensionsRule(context) {\n  var schema = context.getSchema();\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension\n  };\n\n  function checkExtension(node) {\n    var typeName = node.name.value;\n    var defNode = definedTypes[typeName];\n    var existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    var expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        var kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(new GraphQLError(\"Cannot extend non-\".concat(kindStr, \" type \\\"\").concat(typeName, \"\\\".\"), defNode ? [defNode, node] : node));\n      }\n    } else {\n      var allTypeNames = Object.keys(definedTypes);\n\n      if (schema) {\n        allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));\n      }\n\n      var suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(new GraphQLError(\"Cannot extend type \\\"\".concat(typeName, \"\\\" because it is not defined.\") + didYouMean(suggestedTypes), node.name));\n    }\n  }\n}\nvar defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, Kind.SCALAR_TYPE_DEFINITION, Kind.SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.OBJECT_TYPE_DEFINITION, Kind.OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INTERFACE_TYPE_DEFINITION, Kind.INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.UNION_TYPE_DEFINITION, Kind.UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.ENUM_TYPE_DEFINITION, Kind.ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INPUT_OBJECT_TYPE_DEFINITION, Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || invariant(0, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || invariant(0, 'Unexpected kind: ' + inspect(kind));\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique input field names\n *\n * A GraphQL input object value is only valid if all supplied fields are\n * uniquely named.\n */\nexport function UniqueInputFieldNamesRule(context) {\n  var knownNameStack = [];\n  var knownNames = Object.create(null);\n  return {\n    ObjectValue: {\n      enter: function enter() {\n        knownNameStack.push(knownNames);\n        knownNames = Object.create(null);\n      },\n      leave: function leave() {\n        knownNames = knownNameStack.pop();\n      }\n    },\n    ObjectField: function ObjectField(node) {\n      var fieldName = node.name.value;\n\n      if (knownNames[fieldName]) {\n        context.reportError(new GraphQLError(\"There can be only one input field named \\\"\".concat(fieldName, \"\\\".\"), [knownNames[fieldName], node.name]));\n      } else {\n        knownNames[fieldName] = node.name;\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isObjectType, isInterfaceType, isInputObjectType } from \"../../type/definition.mjs\";\n\n/**\n * Unique field definition names\n *\n * A GraphQL complex type is only valid if all its fields are uniquely named.\n */\nexport function UniqueFieldDefinitionNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  var knownFieldNames = Object.create(null);\n  return {\n    InputObjectTypeDefinition: checkFieldUniqueness,\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeDefinition: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeDefinition: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness\n  };\n\n  function checkFieldUniqueness(node) {\n    var _node$fields;\n\n    var typeName = node.name.value;\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n    var fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n    var fieldNames = knownFieldNames[typeName];\n\n    for (var _i2 = 0; _i2 < fieldNodes.length; _i2++) {\n      var fieldDef = fieldNodes[_i2];\n      var fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(new GraphQLError(\"Field \\\"\".concat(typeName, \".\").concat(fieldName, \"\\\" already exists in the schema. It cannot also be defined in this type extension.\"), fieldDef.name));\n      } else if (fieldNames[fieldName]) {\n        context.reportError(new GraphQLError(\"Field \\\"\".concat(typeName, \".\").concat(fieldName, \"\\\" can only be defined once.\"), [fieldNames[fieldName], fieldDef.name]));\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction hasField(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n    return type.getFields()[fieldName];\n  }\n\n  return false;\n}\n","// Spec Section: \"Executable Definitions\"\nimport { ExecutableDefinitionsRule } from \"./rules/ExecutableDefinitionsRule.mjs\"; // Spec Section: \"Operation Name Uniqueness\"\n\nimport { UniqueOperationNamesRule } from \"./rules/UniqueOperationNamesRule.mjs\"; // Spec Section: \"Lone Anonymous Operation\"\n\nimport { LoneAnonymousOperationRule } from \"./rules/LoneAnonymousOperationRule.mjs\"; // Spec Section: \"Subscriptions with Single Root Field\"\n\nimport { SingleFieldSubscriptionsRule } from \"./rules/SingleFieldSubscriptionsRule.mjs\"; // Spec Section: \"Fragment Spread Type Existence\"\n\nimport { KnownTypeNamesRule } from \"./rules/KnownTypeNamesRule.mjs\"; // Spec Section: \"Fragments on Composite Types\"\n\nimport { FragmentsOnCompositeTypesRule } from \"./rules/FragmentsOnCompositeTypesRule.mjs\"; // Spec Section: \"Variables are Input Types\"\n\nimport { VariablesAreInputTypesRule } from \"./rules/VariablesAreInputTypesRule.mjs\"; // Spec Section: \"Leaf Field Selections\"\n\nimport { ScalarLeafsRule } from \"./rules/ScalarLeafsRule.mjs\"; // Spec Section: \"Field Selections on Objects, Interfaces, and Unions Types\"\n\nimport { FieldsOnCorrectTypeRule } from \"./rules/FieldsOnCorrectTypeRule.mjs\"; // Spec Section: \"Fragment Name Uniqueness\"\n\nimport { UniqueFragmentNamesRule } from \"./rules/UniqueFragmentNamesRule.mjs\"; // Spec Section: \"Fragment spread target defined\"\n\nimport { KnownFragmentNamesRule } from \"./rules/KnownFragmentNamesRule.mjs\"; // Spec Section: \"Fragments must be used\"\n\nimport { NoUnusedFragmentsRule } from \"./rules/NoUnusedFragmentsRule.mjs\"; // Spec Section: \"Fragment spread is possible\"\n\nimport { PossibleFragmentSpreadsRule } from \"./rules/PossibleFragmentSpreadsRule.mjs\"; // Spec Section: \"Fragments must not form cycles\"\n\nimport { NoFragmentCyclesRule } from \"./rules/NoFragmentCyclesRule.mjs\"; // Spec Section: \"Variable Uniqueness\"\n\nimport { UniqueVariableNamesRule } from \"./rules/UniqueVariableNamesRule.mjs\"; // Spec Section: \"All Variable Used Defined\"\n\nimport { NoUndefinedVariablesRule } from \"./rules/NoUndefinedVariablesRule.mjs\"; // Spec Section: \"All Variables Used\"\n\nimport { NoUnusedVariablesRule } from \"./rules/NoUnusedVariablesRule.mjs\"; // Spec Section: \"Directives Are Defined\"\n\nimport { KnownDirectivesRule } from \"./rules/KnownDirectivesRule.mjs\"; // Spec Section: \"Directives Are Unique Per Location\"\n\nimport { UniqueDirectivesPerLocationRule } from \"./rules/UniqueDirectivesPerLocationRule.mjs\"; // Spec Section: \"Argument Names\"\n\nimport { KnownArgumentNamesRule, KnownArgumentNamesOnDirectivesRule } from \"./rules/KnownArgumentNamesRule.mjs\"; // Spec Section: \"Argument Uniqueness\"\n\nimport { UniqueArgumentNamesRule } from \"./rules/UniqueArgumentNamesRule.mjs\"; // Spec Section: \"Value Type Correctness\"\n\nimport { ValuesOfCorrectTypeRule } from \"./rules/ValuesOfCorrectTypeRule.mjs\"; // Spec Section: \"Argument Optionality\"\n\nimport { ProvidedRequiredArgumentsRule, ProvidedRequiredArgumentsOnDirectivesRule } from \"./rules/ProvidedRequiredArgumentsRule.mjs\"; // Spec Section: \"All Variable Usages Are Allowed\"\n\nimport { VariablesInAllowedPositionRule } from \"./rules/VariablesInAllowedPositionRule.mjs\"; // Spec Section: \"Field Selection Merging\"\n\nimport { OverlappingFieldsCanBeMergedRule } from \"./rules/OverlappingFieldsCanBeMergedRule.mjs\"; // Spec Section: \"Input Object Field Uniqueness\"\n\nimport { UniqueInputFieldNamesRule } from \"./rules/UniqueInputFieldNamesRule.mjs\"; // SDL-specific validation rules\n\nimport { LoneSchemaDefinitionRule } from \"./rules/LoneSchemaDefinitionRule.mjs\";\nimport { UniqueOperationTypesRule } from \"./rules/UniqueOperationTypesRule.mjs\";\nimport { UniqueTypeNamesRule } from \"./rules/UniqueTypeNamesRule.mjs\";\nimport { UniqueEnumValueNamesRule } from \"./rules/UniqueEnumValueNamesRule.mjs\";\nimport { UniqueFieldDefinitionNamesRule } from \"./rules/UniqueFieldDefinitionNamesRule.mjs\";\nimport { UniqueDirectiveNamesRule } from \"./rules/UniqueDirectiveNamesRule.mjs\";\nimport { PossibleTypeExtensionsRule } from \"./rules/PossibleTypeExtensionsRule.mjs\";\n/**\n * This set includes all validation rules defined by the GraphQL spec.\n *\n * The order of the rules in this list has been adjusted to lead to the\n * most clear output when encountering multiple validation errors.\n */\n\nexport var specifiedRules = Object.freeze([ExecutableDefinitionsRule, UniqueOperationNamesRule, LoneAnonymousOperationRule, SingleFieldSubscriptionsRule, KnownTypeNamesRule, FragmentsOnCompositeTypesRule, VariablesAreInputTypesRule, ScalarLeafsRule, FieldsOnCorrectTypeRule, UniqueFragmentNamesRule, KnownFragmentNamesRule, NoUnusedFragmentsRule, PossibleFragmentSpreadsRule, NoFragmentCyclesRule, UniqueVariableNamesRule, NoUndefinedVariablesRule, NoUnusedVariablesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, KnownArgumentNamesRule, UniqueArgumentNamesRule, ValuesOfCorrectTypeRule, ProvidedRequiredArgumentsRule, VariablesInAllowedPositionRule, OverlappingFieldsCanBeMergedRule, UniqueInputFieldNamesRule]);\n/**\n * @internal\n */\n\nexport var specifiedSDLRules = Object.freeze([LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, KnownArgumentNamesOnDirectivesRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule, ProvidedRequiredArgumentsOnDirectivesRule]);\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique operation names\n *\n * A GraphQL document is only valid if all defined operations have unique names.\n */\nexport function UniqueOperationNamesRule(context) {\n  var knownOperationNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      var operationName = node.name;\n\n      if (operationName) {\n        if (knownOperationNames[operationName.value]) {\n          context.reportError(new GraphQLError(\"There can be only one operation named \\\"\".concat(operationName.value, \"\\\".\"), [knownOperationNames[operationName.value], operationName]));\n        } else {\n          knownOperationNames[operationName.value] = operationName;\n        }\n      }\n\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition() {\n      return false;\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\n\n/**\n * Lone anonymous operation\n *\n * A GraphQL document is only valid if when it contains an anonymous operation\n * (the query short-hand) that it contains only that one operation definition.\n */\nexport function LoneAnonymousOperationRule(context) {\n  var operationCount = 0;\n  return {\n    Document: function Document(node) {\n      operationCount = node.definitions.filter(function (definition) {\n        return definition.kind === Kind.OPERATION_DEFINITION;\n      }).length;\n    },\n    OperationDefinition: function OperationDefinition(node) {\n      if (!node.name && operationCount > 1) {\n        context.reportError(new GraphQLError('This anonymous operation must be the only defined operation.', node));\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Subscriptions must only include one field.\n *\n * A GraphQL subscription is valid only if it contains a single root field.\n */\nexport function SingleFieldSubscriptionsRule(context) {\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      if (node.operation === 'subscription') {\n        if (node.selectionSet.selections.length !== 1) {\n          context.reportError(new GraphQLError(node.name ? \"Subscription \\\"\".concat(node.name.value, \"\\\" must select only one top level field.\") : 'Anonymous Subscription must select only one top level field.', node.selectionSet.selections.slice(1)));\n        }\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { isCompositeType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n */\nexport function FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        var type = typeFromAST(context.getSchema(), typeCondition);\n\n        if (type && !isCompositeType(type)) {\n          var typeStr = print(typeCondition);\n          context.reportError(new GraphQLError(\"Fragment cannot condition on non composite type \\\"\".concat(typeStr, \"\\\".\"), typeCondition));\n        }\n      }\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      var type = typeFromAST(context.getSchema(), node.typeCondition);\n\n      if (type && !isCompositeType(type)) {\n        var typeStr = print(node.typeCondition);\n        context.reportError(new GraphQLError(\"Fragment \\\"\".concat(node.name.value, \"\\\" cannot condition on non composite type \\\"\").concat(typeStr, \"\\\".\"), node.typeCondition));\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { isInputType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\n\n/**\n * Variables are input types\n *\n * A GraphQL operation is only valid if all the variables it defines are of\n * input types (scalar, enum, or input object).\n */\nexport function VariablesAreInputTypesRule(context) {\n  return {\n    VariableDefinition: function VariableDefinition(node) {\n      var type = typeFromAST(context.getSchema(), node.type);\n\n      if (type && !isInputType(type)) {\n        var variableName = node.variable.name.value;\n        var typeName = print(node.type);\n        context.reportError(new GraphQLError(\"Variable \\\"$\".concat(variableName, \"\\\" cannot be non-input type \\\"\").concat(typeName, \"\\\".\"), node.type));\n      }\n    }\n  };\n}\n","import inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { getNamedType, isLeafType } from \"../../type/definition.mjs\";\n\n/**\n * Scalar leafs\n *\n * A GraphQL document is valid only if all leaf fields (fields without\n * sub selections) are of scalar or enum types.\n */\nexport function ScalarLeafsRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getType();\n      var selectionSet = node.selectionSet;\n\n      if (type) {\n        if (isLeafType(getNamedType(type))) {\n          if (selectionSet) {\n            var fieldName = node.name.value;\n            var typeStr = inspect(type);\n            context.reportError(new GraphQLError(\"Field \\\"\".concat(fieldName, \"\\\" must not have a selection since type \\\"\").concat(typeStr, \"\\\" has no subfields.\"), selectionSet));\n          }\n        } else if (!selectionSet) {\n          var _fieldName = node.name.value;\n\n          var _typeStr = inspect(type);\n\n          context.reportError(new GraphQLError(\"Field \\\"\".concat(_fieldName, \"\\\" of type \\\"\").concat(_typeStr, \"\\\" must have a selection of subfields. Did you mean \\\"\").concat(_fieldName, \" { ... }\\\"?\"), node));\n        }\n      }\n    }\n  };\n}\n","import arrayFrom from \"../../polyfills/arrayFrom.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isObjectType, isInterfaceType, isAbstractType } from \"../../type/definition.mjs\";\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestion = didYouMean('to use an inline fragment on', getSuggestedTypeNames(schema, type, fieldName)); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n\n          context.reportError(new GraphQLError(\"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type.name, \"\\\".\") + suggestion, node));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  var suggestedTypes = new Set();\n  var usageCount = Object.create(null);\n\n  for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {\n    var possibleType = _schema$getPossibleTy2[_i2];\n\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {\n      var _usageCount$possibleI;\n\n      var possibleInterface = _possibleType$getInte2[_i4];\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;\n    }\n  }\n\n  return arrayFrom(suggestedTypes).sort(function (typeA, typeB) {\n    // Suggest both interface and object types based on how common they are.\n    var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n    if (usageCountDiff !== 0) {\n      return usageCountDiff;\n    } // Suggest super types first followed by subtypes\n\n\n    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n      return -1;\n    }\n\n    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n      return 1;\n    }\n\n    return typeA.name.localeCompare(typeB.name);\n  }).map(function (x) {\n    return x.name;\n  });\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique fragment names\n *\n * A GraphQL document is only valid if all defined fragments have unique names.\n */\nexport function UniqueFragmentNamesRule(context) {\n  var knownFragmentNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      var fragmentName = node.name.value;\n\n      if (knownFragmentNames[fragmentName]) {\n        context.reportError(new GraphQLError(\"There can be only one fragment named \\\"\".concat(fragmentName, \"\\\".\"), [knownFragmentNames[fragmentName], node.name]));\n      } else {\n        knownFragmentNames[fragmentName] = node.name;\n      }\n\n      return false;\n    }\n  };\n}\n","import inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isCompositeType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\nimport { doTypesOverlap } from \"../../utilities/typeComparators.mjs\";\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nexport function PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        var parentTypeStr = inspect(parentType);\n        var fragTypeStr = inspect(fragType);\n        context.reportError(new GraphQLError(\"Fragment cannot be spread here as objects of type \\\"\".concat(parentTypeStr, \"\\\" can never be of type \\\"\").concat(fragTypeStr, \"\\\".\"), node));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        var parentTypeStr = inspect(parentType);\n        var fragTypeStr = inspect(fragType);\n        context.reportError(new GraphQLError(\"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of type \\\"\").concat(parentTypeStr, \"\\\" can never be of type \\\"\").concat(fragTypeStr, \"\\\".\"), node));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  var spreadPath = []; // Position in the spread path\n\n  var spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    }\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (var _i2 = 0; _i2 < spreadNodes.length; _i2++) {\n      var spreadNode = spreadNodes[_i2];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        var spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        var viaPath = cyclePath.slice(0, -1).map(function (s) {\n          return '\"' + s.name.value + '\"';\n        }).join(', ');\n        context.reportError(new GraphQLError(\"Cannot spread fragment \\\"\".concat(spreadName, \"\\\" within itself\") + (viaPath !== '' ? \" via \".concat(viaPath, \".\") : '.'), cyclePath));\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique variable names\n *\n * A GraphQL operation is only valid if all its variables are uniquely named.\n */\nexport function UniqueVariableNamesRule(context) {\n  var knownVariableNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      knownVariableNames = Object.create(null);\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      var variableName = node.variable.name.value;\n\n      if (knownVariableNames[variableName]) {\n        context.reportError(new GraphQLError(\"There can be only one variable named \\\"$\".concat(variableName, \"\\\".\"), [knownVariableNames[variableName], node.variable.name]));\n      } else {\n        knownVariableNames[variableName] = node.variable.name;\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * No undefined variables\n *\n * A GraphQL operation is only valid if all variables encountered, both directly\n * and via fragment spreads, are defined by that operation.\n */\nexport function NoUndefinedVariablesRule(context) {\n  var variableNameDefined = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        variableNameDefined = Object.create(null);\n      },\n      leave: function leave(operation) {\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        for (var _i2 = 0; _i2 < usages.length; _i2++) {\n          var _ref2 = usages[_i2];\n          var node = _ref2.node;\n          var varName = node.name.value;\n\n          if (variableNameDefined[varName] !== true) {\n            context.reportError(new GraphQLError(operation.name ? \"Variable \\\"$\".concat(varName, \"\\\" is not defined by operation \\\"\").concat(operation.name.value, \"\\\".\") : \"Variable \\\"$\".concat(varName, \"\\\" is not defined.\"), [node, operation]));\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      variableNameDefined[node.variable.name.value] = true;\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * No unused variables\n *\n * A GraphQL operation is only valid if all variables defined by an operation\n * are used, either directly or within a spread fragment.\n */\nexport function NoUnusedVariablesRule(context) {\n  var variableDefs = [];\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        variableDefs = [];\n      },\n      leave: function leave(operation) {\n        var variableNameUsed = Object.create(null);\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        for (var _i2 = 0; _i2 < usages.length; _i2++) {\n          var _ref2 = usages[_i2];\n          var node = _ref2.node;\n          variableNameUsed[node.name.value] = true;\n        }\n\n        for (var _i4 = 0, _variableDefs2 = variableDefs; _i4 < _variableDefs2.length; _i4++) {\n          var variableDef = _variableDefs2[_i4];\n          var variableName = variableDef.variable.name.value;\n\n          if (variableNameUsed[variableName] !== true) {\n            context.reportError(new GraphQLError(operation.name ? \"Variable \\\"$\".concat(variableName, \"\\\" is never used in operation \\\"\").concat(operation.name.value, \"\\\".\") : \"Variable \\\"$\".concat(variableName, \"\\\" is never used.\"), variableDef));\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(def) {\n      variableDefs.push(def);\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Lone Schema definition\n *\n * A GraphQL document is only valid if it contains only one schema definition.\n */\nexport function LoneSchemaDefinitionRule(context) {\n  var _ref, _ref2, _oldSchema$astNode;\n\n  var oldSchema = context.getSchema();\n  var alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();\n  var schemaDefinitionsCount = 0;\n  return {\n    SchemaDefinition: function SchemaDefinition(node) {\n      if (alreadyDefined) {\n        context.reportError(new GraphQLError('Cannot define a new schema within a schema extension.', node));\n        return;\n      }\n\n      if (schemaDefinitionsCount > 0) {\n        context.reportError(new GraphQLError('Must provide only one schema definition.', node));\n      }\n\n      ++schemaDefinitionsCount;\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique operation types\n *\n * A GraphQL document is only valid if it has only one type per operation.\n */\nexport function UniqueOperationTypesRule(context) {\n  var schema = context.getSchema();\n  var definedOperationTypes = Object.create(null);\n  var existingOperationTypes = schema ? {\n    query: schema.getQueryType(),\n    mutation: schema.getMutationType(),\n    subscription: schema.getSubscriptionType()\n  } : {};\n  return {\n    SchemaDefinition: checkOperationTypes,\n    SchemaExtension: checkOperationTypes\n  };\n\n  function checkOperationTypes(node) {\n    var _node$operationTypes;\n\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n\n    for (var _i2 = 0; _i2 < operationTypesNodes.length; _i2++) {\n      var operationType = operationTypesNodes[_i2];\n      var operation = operationType.operation;\n      var alreadyDefinedOperationType = definedOperationTypes[operation];\n\n      if (existingOperationTypes[operation]) {\n        context.reportError(new GraphQLError(\"Type for \".concat(operation, \" already defined in the schema. It cannot be redefined.\"), operationType));\n      } else if (alreadyDefinedOperationType) {\n        context.reportError(new GraphQLError(\"There can be only one \".concat(operation, \" type in schema.\"), [alreadyDefinedOperationType, operationType]));\n      } else {\n        definedOperationTypes[operation] = operationType;\n      }\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique type names\n *\n * A GraphQL document is only valid if all defined types have unique names.\n */\nexport function UniqueTypeNamesRule(context) {\n  var knownTypeNames = Object.create(null);\n  var schema = context.getSchema();\n  return {\n    ScalarTypeDefinition: checkTypeName,\n    ObjectTypeDefinition: checkTypeName,\n    InterfaceTypeDefinition: checkTypeName,\n    UnionTypeDefinition: checkTypeName,\n    EnumTypeDefinition: checkTypeName,\n    InputObjectTypeDefinition: checkTypeName\n  };\n\n  function checkTypeName(node) {\n    var typeName = node.name.value;\n\n    if (schema === null || schema === void 0 ? void 0 : schema.getType(typeName)) {\n      context.reportError(new GraphQLError(\"Type \\\"\".concat(typeName, \"\\\" already exists in the schema. It cannot also be defined in this type definition.\"), node.name));\n      return;\n    }\n\n    if (knownTypeNames[typeName]) {\n      context.reportError(new GraphQLError(\"There can be only one type named \\\"\".concat(typeName, \"\\\".\"), [knownTypeNames[typeName], node.name]));\n    } else {\n      knownTypeNames[typeName] = node.name;\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isEnumType } from \"../../type/definition.mjs\";\n\n/**\n * Unique enum value names\n *\n * A GraphQL enum type is only valid if all its values are uniquely named.\n */\nexport function UniqueEnumValueNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  var knownValueNames = Object.create(null);\n  return {\n    EnumTypeDefinition: checkValueUniqueness,\n    EnumTypeExtension: checkValueUniqueness\n  };\n\n  function checkValueUniqueness(node) {\n    var _node$values;\n\n    var typeName = node.name.value;\n\n    if (!knownValueNames[typeName]) {\n      knownValueNames[typeName] = Object.create(null);\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n    var valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n    var valueNames = knownValueNames[typeName];\n\n    for (var _i2 = 0; _i2 < valueNodes.length; _i2++) {\n      var valueDef = valueNodes[_i2];\n      var valueName = valueDef.name.value;\n      var existingType = existingTypeMap[typeName];\n\n      if (isEnumType(existingType) && existingType.getValue(valueName)) {\n        context.reportError(new GraphQLError(\"Enum value \\\"\".concat(typeName, \".\").concat(valueName, \"\\\" already exists in the schema. It cannot also be defined in this type extension.\"), valueDef.name));\n      } else if (valueNames[valueName]) {\n        context.reportError(new GraphQLError(\"Enum value \\\"\".concat(typeName, \".\").concat(valueName, \"\\\" can only be defined once.\"), [valueNames[valueName], valueDef.name]));\n      } else {\n        valueNames[valueName] = valueDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique directive names\n *\n * A GraphQL document is only valid if all defined directives have unique names.\n */\nexport function UniqueDirectiveNamesRule(context) {\n  var knownDirectiveNames = Object.create(null);\n  var schema = context.getSchema();\n  return {\n    DirectiveDefinition: function DirectiveDefinition(node) {\n      var directiveName = node.name.value;\n\n      if (schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName)) {\n        context.reportError(new GraphQLError(\"Directive \\\"@\".concat(directiveName, \"\\\" already exists in the schema. It cannot be redefined.\"), node.name));\n        return;\n      }\n\n      if (knownDirectiveNames[directiveName]) {\n        context.reportError(new GraphQLError(\"There can be only one directive named \\\"@\".concat(directiveName, \"\\\".\"), [knownDirectiveNames[directiveName], node.name]));\n      } else {\n        knownDirectiveNames[directiveName] = node.name;\n      }\n\n      return false;\n    }\n  };\n}\n","var flatMapMethod = Array.prototype.flatMap;\n/* eslint-disable no-redeclare */\n// $FlowFixMe\n\nvar flatMap = flatMapMethod ? function (list, fn) {\n  return flatMapMethod.call(list, fn);\n} : function (list, fn) {\n  var result = [];\n\n  for (var _i2 = 0; _i2 < list.length; _i2++) {\n    var _item = list[_i2];\n    var value = fn(_item);\n\n    if (Array.isArray(value)) {\n      result = result.concat(value);\n    } else {\n      result.push(value);\n    }\n  }\n\n  return result;\n};\nexport default flatMap;\n","import devAssert from \"../jsutils/devAssert.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nvar NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n/**\n * Upholds the spec rules about naming.\n */\n\nexport function assertValidName(name) {\n  var error = isValidNameError(name);\n\n  if (error) {\n    throw error;\n  }\n\n  return name;\n}\n/**\n * Returns an Error if a name is invalid.\n */\n\nexport function isValidNameError(name) {\n  typeof name === 'string' || devAssert(0, 'Expected name to be a string.');\n\n  if (name.length > 1 && name[0] === '_' && name[1] === '_') {\n    return new GraphQLError(\"Name \\\"\".concat(name, \"\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\"));\n  }\n\n  if (!NAME_RX.test(name)) {\n    return new GraphQLError(\"Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but \\\"\".concat(name, \"\\\" does not.\"));\n  }\n}\n","import find from \"../polyfills/find.mjs\";\nimport flatMap from \"../polyfills/flatMap.mjs\";\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { locatedError } from \"../error/locatedError.mjs\";\nimport { isValidNameError } from \"../utilities/assertValidName.mjs\";\nimport { isEqualType, isTypeSubTypeOf } from \"../utilities/typeComparators.mjs\";\nimport { assertSchema } from \"./schema.mjs\";\nimport { isDirective } from \"./directives.mjs\";\nimport { isIntrospectionType } from \"./introspection.mjs\";\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isNonNullType, isInputType, isOutputType, isRequiredArgument } from \"./definition.mjs\";\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext = /*#__PURE__*/function () {\n  function SchemaValidationContext(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  var _proto = SchemaValidationContext.prototype;\n\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this.addError(new GraphQLError(message, _nodes));\n  };\n\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), (_getOperationTypeNode = getOperationTypeNode(schema, 'query')) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), (_getOperationTypeNode2 = getOperationTypeNode(schema, 'mutation')) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), (_getOperationTypeNode3 = getOperationTypeNode(schema, 'subscription')) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n\n  for (var _i2 = 0; _i2 < operationNodes.length; _i2++) {\n    var node = operationNodes[_i2];\n\n    if (node.operation === operation) {\n      return node.type;\n    }\n  }\n\n  return undefined;\n}\n\nfunction validateDirectives(context) {\n  for (var _i4 = 0, _context$schema$getDi2 = context.schema.getDirectives(); _i4 < _context$schema$getDi2.length; _i4++) {\n    var directive = _context$schema$getDi2[_i4];\n\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive === null || directive === void 0 ? void 0 : directive.astNode);\n      continue;\n    } // Ensure they are named correctly.\n\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {\n      var arg = _directive$args2[_i6];\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(arg.name, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), arg.astNode);\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  var error = isValidNameError(node.name);\n\n  if (error) {\n    context.addError(locatedError(error, node.astNode));\n  }\n}\n\nfunction validateTypes(context) {\n  var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  var typeMap = context.schema.getTypeMap();\n\n  for (var _i8 = 0, _objectValues2 = objectValues(typeMap); _i8 < _objectValues2.length; _i8++) {\n    var type = _objectValues2[_i8];\n\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n\n  for (var _i10 = 0; _i10 < fields.length; _i10++) {\n    var field = fields[_i10];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n\n      context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);\n    } // Ensure the arguments are valid\n\n\n    for (var _i12 = 0, _field$args2 = field.args; _i12 < _field$args2.length; _i12++) {\n      var arg = _field$args2[_i12];\n      var argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        var _arg$astNode;\n\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type);\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  var ifaceTypeNames = Object.create(null);\n\n  for (var _i14 = 0, _type$getInterfaces2 = type.getInterfaces(); _i14 < _type$getInterfaces2.length; _i14++) {\n    var iface = _type$getInterfaces2[_i14];\n\n    if (!isInterfaceType(iface)) {\n      context.reportError(\"Type \".concat(inspect(type), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(\"Type \".concat(type.name, \" cannot implement itself because it would create a circular reference.\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(\"Type \".concat(type.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  var typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (var _i16 = 0, _objectValues4 = objectValues(iface.getFields()); _i16 < _objectValues4.length; _i16++) {\n    var ifaceField = _objectValues4[_i16];\n    var fieldName = ifaceField.name;\n    var typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \").concat(type.name, \" does not provide it.\"), [ifaceField.astNode].concat(getAllNodes(type)));\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(type.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(typeField.type), \".\"), [// istanbul ignore next (TODO need to write coverage tests)\n      (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type, // istanbul ignore next (TODO need to write coverage tests)\n      (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n\n    var _loop = function _loop(_i18, _ifaceField$args2) {\n      var ifaceArg = _ifaceField$args2[_i18];\n      var argName = ifaceArg.name;\n      var typeArg = find(typeField.args, function (arg) {\n        return arg.name === argName;\n      }); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) expected but \").concat(type.name, \".\").concat(fieldName, \" does not provide it.\"), [ifaceArg.astNode, typeField.astNode]);\n        return \"continue\";\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(type.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(typeArg.type), \".\"), [// istanbul ignore next (TODO need to write coverage tests)\n        (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type, // istanbul ignore next (TODO need to write coverage tests)\n        (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type]);\n      } // TODO: validate default values?\n\n    };\n\n    for (var _i18 = 0, _ifaceField$args2 = ifaceField.args; _i18 < _ifaceField$args2.length; _i18++) {\n      var _ret = _loop(_i18, _ifaceField$args2);\n\n      if (_ret === \"continue\") continue;\n    } // Assert additional arguments must not be required.\n\n\n    var _loop2 = function _loop2(_i20, _typeField$args2) {\n      var typeArg = _typeField$args2[_i20];\n      var argName = typeArg.name;\n      var ifaceArg = find(ifaceField.args, function (arg) {\n        return arg.name === argName;\n      });\n\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(\"Object field \".concat(type.name, \".\").concat(fieldName, \" includes required argument \").concat(argName, \" that is missing from the Interface field \").concat(iface.name, \".\").concat(fieldName, \".\"), [typeArg.astNode, ifaceField.astNode]);\n      }\n    };\n\n    for (var _i20 = 0, _typeField$args2 = typeField.args; _i20 < _typeField$args2.length; _i20++) {\n      _loop2(_i20, _typeField$args2);\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  var ifaceInterfaces = type.getInterfaces();\n\n  for (var _i22 = 0, _iface$getInterfaces2 = iface.getInterfaces(); _i22 < _iface$getInterfaces2.length; _i22++) {\n    var transitive = _iface$getInterfaces2[_i22];\n\n    if (ifaceInterfaces.indexOf(transitive) === -1) {\n      context.reportError(transitive === type ? \"Type \".concat(type.name, \" cannot implement \").concat(iface.name, \" because it would create a circular reference.\") : \"Type \".concat(type.name, \" must implement \").concat(transitive.name, \" because it is implemented by \").concat(iface.name, \".\"), [].concat(getAllImplementsInterfaceNodes(iface, transitive), getAllImplementsInterfaceNodes(type, iface)));\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n\n  var includedTypeNames = Object.create(null);\n\n  for (var _i24 = 0; _i24 < memberTypes.length; _i24++) {\n    var memberType = memberTypes[_i24];\n\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include type \").concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n\n  for (var _i26 = 0; _i26 < enumValues.length; _i26++) {\n    var enumValue = enumValues[_i26];\n    var valueName = enumValue.name; // Ensure valid name.\n\n    validateName(context, enumValue);\n\n    if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n      context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n    }\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n\n  for (var _i28 = 0; _i28 < fields.length; _i28++) {\n    var field = fields[_i28];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  var fieldPath = []; // Position in the type path\n\n  var fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    var fields = objectValues(inputObj.getFields());\n\n    for (var _i30 = 0; _i30 < fields.length; _i30++) {\n      var field = fields[_i30];\n\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        var fieldType = field.type.ofType;\n        var cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          var cyclePath = fieldPath.slice(cycleIndex);\n          var pathStr = cyclePath.map(function (fieldObj) {\n            return fieldObj.name;\n          }).join('.');\n          context.reportError(\"Cannot reference Input Object \\\"\".concat(fieldType.name, \"\\\" within itself through a series of non-null fields: \\\"\").concat(pathStr, \"\\\".\"), cyclePath.map(function (fieldObj) {\n            return fieldObj.astNode;\n          }));\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n      extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes !== null && extensionASTNodes !== void 0 ? extensionASTNodes : [];\n}\n\nfunction getAllSubNodes(object, getter) {\n  // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n  return flatMap(getAllNodes(object), function (item) {\n    var _getter;\n\n    return (_getter = getter(item)) !== null && _getter !== void 0 ? _getter : [];\n  });\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\n","import { GraphQLError } from \"./GraphQLError.mjs\";\n/**\n * Given an arbitrary Error, presumably thrown while attempting to execute a\n * GraphQL operation, produce a new GraphQLError aware of the location in the\n * document responsible for the original Error.\n */\n\nexport function locatedError(originalError, nodes, path) {\n  var _nodes;\n\n  // Note: this uses a brand-check to support GraphQL errors originating from\n  // other contexts.\n  if (Array.isArray(originalError.path)) {\n    return originalError;\n  }\n\n  return new GraphQLError(originalError.message, (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes, originalError.source, originalError.positions, path, originalError);\n}\n","import find from \"../polyfills/find.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { isNode } from \"../language/ast.mjs\";\nimport { getVisitFn } from \"../language/visitor.mjs\";\nimport { isObjectType, isInterfaceType, isEnumType, isInputObjectType, isListType, isCompositeType, isInputType, isOutputType, getNullableType, getNamedType } from \"../type/definition.mjs\";\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from \"../type/introspection.mjs\";\nimport { typeFromAST } from \"./typeFromAST.mjs\";\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\n\nexport var TypeInfo = /*#__PURE__*/function () {\n  function TypeInfo(schema, // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant code bases. You should never need to use it.\n  // It may disappear in the future.\n  getFieldDefFn, // Initial type may be provided in rare cases to facilitate traversals\n  // beginning somewhere other than documents.\n  initialType) {\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;\n\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  var _proto = TypeInfo.prototype;\n\n  _proto.getType = function getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  };\n\n  _proto.getParentType = function getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  };\n\n  _proto.getInputType = function getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  };\n\n  _proto.getParentInputType = function getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  };\n\n  _proto.getFieldDef = function getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  };\n\n  _proto.getDefaultValue = function getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  };\n\n  _proto.getDirective = function getDirective() {\n    return this._directive;\n  };\n\n  _proto.getArgument = function getArgument() {\n    return this._argument;\n  };\n\n  _proto.getEnumValue = function getEnumValue() {\n    return this._enumValue;\n  };\n\n  _proto.enter = function enter(node) {\n    var schema = this._schema; // Note: many of the types below are explicitly typed as \"mixed\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        {\n          var namedType = getNamedType(this.getType());\n\n          this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);\n\n          break;\n        }\n\n      case Kind.FIELD:\n        {\n          var parentType = this.getParentType();\n          var fieldDef;\n          var fieldType;\n\n          if (parentType) {\n            fieldDef = this._getFieldDef(schema, parentType, node);\n\n            if (fieldDef) {\n              fieldType = fieldDef.type;\n            }\n          }\n\n          this._fieldDefStack.push(fieldDef);\n\n          this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\n\n          break;\n        }\n\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n        {\n          var type;\n\n          switch (node.operation) {\n            case 'query':\n              type = schema.getQueryType();\n              break;\n\n            case 'mutation':\n              type = schema.getMutationType();\n              break;\n\n            case 'subscription':\n              type = schema.getSubscriptionType();\n              break;\n          }\n\n          this._typeStack.push(isObjectType(type) ? type : undefined);\n\n          break;\n        }\n\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        {\n          var typeConditionAST = node.typeCondition;\n          var outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());\n\n          this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\n\n          break;\n        }\n\n      case Kind.VARIABLE_DEFINITION:\n        {\n          var inputType = typeFromAST(schema, node.type);\n\n          this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);\n\n          break;\n        }\n\n      case Kind.ARGUMENT:\n        {\n          var _this$getDirective;\n\n          var argDef;\n          var argType;\n          var fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();\n\n          if (fieldOrDirective) {\n            argDef = find(fieldOrDirective.args, function (arg) {\n              return arg.name === node.name.value;\n            });\n\n            if (argDef) {\n              argType = argDef.type;\n            }\n          }\n\n          this._argument = argDef;\n\n          this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n          this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\n\n          break;\n        }\n\n      case Kind.LIST:\n        {\n          var listType = getNullableType(this.getInputType());\n          var itemType = isListType(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n          this._defaultValueStack.push(undefined);\n\n          this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\n\n          break;\n        }\n\n      case Kind.OBJECT_FIELD:\n        {\n          var objectType = getNamedType(this.getInputType());\n          var inputFieldType;\n          var inputField;\n\n          if (isInputObjectType(objectType)) {\n            inputField = objectType.getFields()[node.name.value];\n\n            if (inputField) {\n              inputFieldType = inputField.type;\n            }\n          }\n\n          this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);\n\n          this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);\n\n          break;\n        }\n\n      case Kind.ENUM:\n        {\n          var enumType = getNamedType(this.getInputType());\n          var enumValue;\n\n          if (isEnumType(enumType)) {\n            enumValue = enumType.getValue(node.value);\n          }\n\n          this._enumValue = enumValue;\n          break;\n        }\n    }\n  };\n\n  _proto.leave = function leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ARGUMENT:\n        this._argument = null;\n\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  };\n\n  return TypeInfo;\n}();\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n\n  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  }\n\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name];\n  }\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\n\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      false);\n\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      true);\n      var result;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n","function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nimport { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\nimport { TypeInfo, visitWithTypeInfo } from \"../utilities/TypeInfo.mjs\";\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport var ASTValidationContext = /*#__PURE__*/function () {\n  function ASTValidationContext(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  var _proto = ASTValidationContext.prototype;\n\n  _proto.reportError = function reportError(error) {\n    this._onError(error);\n  };\n\n  _proto.getDocument = function getDocument() {\n    return this._ast;\n  };\n\n  _proto.getFragment = function getFragment(name) {\n    var fragments = this._fragments;\n\n    if (!fragments) {\n      this._fragments = fragments = this.getDocument().definitions.reduce(function (frags, statement) {\n        if (statement.kind === Kind.FRAGMENT_DEFINITION) {\n          frags[statement.name.value] = statement;\n        }\n\n        return frags;\n      }, Object.create(null));\n    }\n\n    return fragments[name];\n  };\n\n  _proto.getFragmentSpreads = function getFragmentSpreads(node) {\n    var spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      var setsToVisit = [node];\n\n      while (setsToVisit.length !== 0) {\n        var set = setsToVisit.pop();\n\n        for (var _i2 = 0, _set$selections2 = set.selections; _i2 < _set$selections2.length; _i2++) {\n          var selection = _set$selections2[_i2];\n\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  };\n\n  _proto.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {\n    var fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      var collectedNames = Object.create(null);\n      var nodesToVisit = [operation.selectionSet];\n\n      while (nodesToVisit.length !== 0) {\n        var node = nodesToVisit.pop();\n\n        for (var _i4 = 0, _this$getFragmentSpre2 = this.getFragmentSpreads(node); _i4 < _this$getFragmentSpre2.length; _i4++) {\n          var spread = _this$getFragmentSpre2[_i4];\n          var fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            var fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  };\n\n  return ASTValidationContext;\n}();\nexport var SDLValidationContext = /*#__PURE__*/function (_ASTValidationContext) {\n  _inheritsLoose(SDLValidationContext, _ASTValidationContext);\n\n  function SDLValidationContext(ast, schema, onError) {\n    var _this;\n\n    _this = _ASTValidationContext.call(this, ast, onError) || this;\n    _this._schema = schema;\n    return _this;\n  }\n\n  var _proto2 = SDLValidationContext.prototype;\n\n  _proto2.getSchema = function getSchema() {\n    return this._schema;\n  };\n\n  return SDLValidationContext;\n}(ASTValidationContext);\nexport var ValidationContext = /*#__PURE__*/function (_ASTValidationContext2) {\n  _inheritsLoose(ValidationContext, _ASTValidationContext2);\n\n  function ValidationContext(schema, ast, typeInfo, onError) {\n    var _this2;\n\n    _this2 = _ASTValidationContext2.call(this, ast, onError) || this;\n    _this2._schema = schema;\n    _this2._typeInfo = typeInfo;\n    _this2._variableUsages = new Map();\n    _this2._recursiveVariableUsages = new Map();\n    return _this2;\n  }\n\n  var _proto3 = ValidationContext.prototype;\n\n  _proto3.getSchema = function getSchema() {\n    return this._schema;\n  };\n\n  _proto3.getVariableUsages = function getVariableUsages(node) {\n    var usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      var newUsages = [];\n      var typeInfo = new TypeInfo(this._schema);\n      visit(node, visitWithTypeInfo(typeInfo, {\n        VariableDefinition: function VariableDefinition() {\n          return false;\n        },\n        Variable: function Variable(variable) {\n          newUsages.push({\n            node: variable,\n            type: typeInfo.getInputType(),\n            defaultValue: typeInfo.getDefaultValue()\n          });\n        }\n      }));\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  };\n\n  _proto3.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {\n    var usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (var _i6 = 0, _this$getRecursivelyR2 = this.getRecursivelyReferencedFragments(operation); _i6 < _this$getRecursivelyR2.length; _i6++) {\n        var frag = _this$getRecursivelyR2[_i6];\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  };\n\n  _proto3.getType = function getType() {\n    return this._typeInfo.getType();\n  };\n\n  _proto3.getParentType = function getParentType() {\n    return this._typeInfo.getParentType();\n  };\n\n  _proto3.getInputType = function getInputType() {\n    return this._typeInfo.getInputType();\n  };\n\n  _proto3.getParentInputType = function getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  };\n\n  _proto3.getFieldDef = function getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  };\n\n  _proto3.getDirective = function getDirective() {\n    return this._typeInfo.getDirective();\n  };\n\n  _proto3.getArgument = function getArgument() {\n    return this._typeInfo.getArgument();\n  };\n\n  _proto3.getEnumValue = function getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  };\n\n  return ValidationContext;\n}(ASTValidationContext);\n","import devAssert from \"../jsutils/devAssert.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { visit, visitInParallel } from \"../language/visitor.mjs\";\nimport { assertValidSchema } from \"../type/validate.mjs\";\nimport { TypeInfo, visitWithTypeInfo } from \"../utilities/TypeInfo.mjs\";\nimport { specifiedRules, specifiedSDLRules } from \"./specifiedRules.mjs\";\nimport { SDLValidationContext, ValidationContext } from \"./ValidationContext.mjs\";\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(schema, documentAST) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedRules;\n  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new TypeInfo(schema);\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n    maxErrors: undefined\n  };\n  documentAST || devAssert(0, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  var abortObj = Object.freeze({});\n  var errors = [];\n  var context = new ValidationContext(schema, documentAST, typeInfo, function (error) {\n    if (options.maxErrors != null && errors.length >= options.maxErrors) {\n      errors.push(new GraphQLError('Too many validation errors, error limit reached. Validation aborted.'));\n      throw abortObj;\n    }\n\n    errors.push(error);\n  }); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  var visitor = visitInParallel(rules.map(function (rule) {\n    return rule(context);\n  })); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\n * @internal\n */\n\nexport function validateSDL(documentAST, schemaToExtend) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedSDLRules;\n  var errors = [];\n  var context = new SDLValidationContext(documentAST, schemaToExtend, function (error) {\n    errors.push(error);\n  });\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  });\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  var errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  var errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n","import { Kind, specifiedRules, validate, NoUnusedFragmentsRule, KnownFragmentNamesRule, } from 'graphql';\nimport { ExecutableDefinitions } from 'graphql/validation/rules/ExecutableDefinitions';\nexport function validateWithCustomRules(schema, ast, customRules, isRelayCompatMode) {\n    const rules = specifiedRules.filter(rule => {\n        if (rule === NoUnusedFragmentsRule || rule === ExecutableDefinitions) {\n            return false;\n        }\n        if (isRelayCompatMode && rule === KnownFragmentNamesRule) {\n            return false;\n        }\n        return true;\n    });\n    if (customRules) {\n        Array.prototype.push.apply(rules, customRules);\n    }\n    const errors = validate(schema, ast, rules);\n    return errors.filter(error => {\n        if (error.message.indexOf('Unknown directive') !== -1 && error.nodes) {\n            const node = error.nodes[0];\n            if (node && node.kind === Kind.DIRECTIVE) {\n                const name = node.name.value;\n                if (name === 'arguments' || name === 'argumentDefinitions') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    });\n}\n//# sourceMappingURL=validateWithCustomRules.js.map","import { GraphQLError } from \"../../../error/GraphQLError.mjs\";\nimport { getNamedType } from \"../../../type/definition.mjs\";\n\n/**\n * No deprecated\n *\n * A GraphQL document is only valid if all selected fields and all used enum values have not been\n * deprecated.\n *\n * Note: This rule is optional and is not part of the Validation section of the GraphQL\n * Specification. The main purpose of this rule is detection of deprecated usages and not\n * necessarily to forbid their use when querying a service.\n */\nexport function NoDeprecatedCustomRule(context) {\n  return {\n    Field: function Field(node) {\n      var fieldDef = context.getFieldDef();\n      var parentType = context.getParentType();\n\n      if (parentType && (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason) != null) {\n        context.reportError(new GraphQLError(\"The field \".concat(parentType.name, \".\").concat(fieldDef.name, \" is deprecated. \") + fieldDef.deprecationReason, node));\n      }\n    },\n    EnumValue: function EnumValue(node) {\n      var type = getNamedType(context.getInputType());\n      var enumValue = context.getEnumValue();\n\n      if (type && (enumValue === null || enumValue === void 0 ? void 0 : enumValue.deprecationReason) != null) {\n        context.reportError(new GraphQLError(\"The enum value \\\"\".concat(type.name, \".\").concat(enumValue.name, \"\\\" is deprecated. \") + enumValue.deprecationReason, node));\n      }\n    }\n  };\n}\n","import { validate } from \"../validation/validate.mjs\";\nimport { NoDeprecatedCustomRule } from \"../validation/rules/custom/NoDeprecatedCustomRule.mjs\";\n/**\n * A validation rule which reports deprecated usages.\n *\n * Returns a list of GraphQLError instances describing each deprecated use.\n *\n * @deprecated Please use `validate` with `NoDeprecatedCustomRule` instead:\n *\n * ```\n * import { validate, NoDeprecatedCustomRule } from 'graphql'\n *\n * const errors = validate(schema, document, [NoDeprecatedCustomRule])\n * ```\n */\n\nexport function findDeprecatedUsages(schema, ast) {\n  return validate(schema, ast, [NoDeprecatedCustomRule]);\n}\n","import invariant from 'assert';\nimport { findDeprecatedUsages, parse } from 'graphql';\nimport { CharacterStream, onlineParser } from 'graphql-language-service-parser';\nimport { Range, validateWithCustomRules, Position, } from 'graphql-language-service-utils';\nexport const SEVERITY = {\n    Error: 'Error',\n    Warning: 'Warning',\n    Information: 'Information',\n    Hint: 'Hint',\n};\nexport const DIAGNOSTIC_SEVERITY = {\n    [SEVERITY.Error]: 1,\n    [SEVERITY.Warning]: 2,\n    [SEVERITY.Information]: 3,\n    [SEVERITY.Hint]: 4,\n};\nexport function getDiagnostics(query, schema = null, customRules, isRelayCompatMode) {\n    let ast = null;\n    try {\n        ast = parse(query);\n    }\n    catch (error) {\n        const range = getRange(error.locations[0], query);\n        return [\n            {\n                severity: DIAGNOSTIC_SEVERITY.Error,\n                message: error.message,\n                source: 'GraphQL: Syntax',\n                range,\n            },\n        ];\n    }\n    return validateQuery(ast, schema, customRules, isRelayCompatMode);\n}\nexport function validateQuery(ast, schema = null, customRules, isRelayCompatMode) {\n    if (!schema) {\n        return [];\n    }\n    const validationErrorAnnotations = mapCat(validateWithCustomRules(schema, ast, customRules, isRelayCompatMode), error => annotations(error, DIAGNOSTIC_SEVERITY.Error, 'Validation'));\n    const deprecationWarningAnnotations = !findDeprecatedUsages\n        ? []\n        : mapCat(findDeprecatedUsages(schema, ast), error => annotations(error, DIAGNOSTIC_SEVERITY.Warning, 'Deprecation'));\n    return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n}\nfunction mapCat(array, mapper) {\n    return Array.prototype.concat.apply([], array.map(mapper));\n}\nfunction annotations(error, severity, type) {\n    if (!error.nodes) {\n        return [];\n    }\n    const highlightedNodes = [];\n    error.nodes.forEach(node => {\n        const highlightNode = node.kind !== 'Variable' && 'name' in node && node.name !== undefined\n            ? node.name\n            : 'variable' in node && node.variable !== undefined\n                ? node.variable\n                : node;\n        if (highlightNode) {\n            invariant(error.locations, 'GraphQL validation error requires locations.');\n            const loc = error.locations[0];\n            const highlightLoc = getLocation(highlightNode);\n            const end = loc.column + (highlightLoc.end - highlightLoc.start);\n            highlightedNodes.push({\n                source: `GraphQL: ${type}`,\n                message: error.message,\n                severity,\n                range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end)),\n            });\n        }\n    });\n    return highlightedNodes;\n}\nexport function getRange(location, queryText) {\n    const parser = onlineParser();\n    const state = parser.startState();\n    const lines = queryText.split('\\n');\n    invariant(lines.length >= location.line, 'Query text must have more lines than where the error happened');\n    let stream = null;\n    for (let i = 0; i < location.line; i++) {\n        stream = new CharacterStream(lines[i]);\n        while (!stream.eol()) {\n            const style = parser.token(stream, state);\n            if (style === 'invalidchar') {\n                break;\n            }\n        }\n    }\n    invariant(stream, 'Expected Parser stream to be available.');\n    const line = location.line - 1;\n    const start = stream.getStartOfToken();\n    const end = stream.getCurrentPosition();\n    return new Range(new Position(line, start), new Position(line, end));\n}\nfunction getLocation(node) {\n    const typeCastedNode = node;\n    const location = typeCastedNode.loc;\n    invariant(location, 'Expected ASTNode to have a location.');\n    return location;\n}\n//# sourceMappingURL=getDiagnostics.js.map","import { Kind, parse, visit, } from 'graphql';\nimport { offsetToPosition } from 'graphql-language-service-utils';\nconst { INLINE_FRAGMENT } = Kind;\nconst OUTLINEABLE_KINDS = {\n    Field: true,\n    OperationDefinition: true,\n    Document: true,\n    SelectionSet: true,\n    Name: true,\n    FragmentDefinition: true,\n    FragmentSpread: true,\n    InlineFragment: true,\n    ObjectTypeDefinition: true,\n    InputObjectTypeDefinition: true,\n    InterfaceTypeDefinition: true,\n    EnumTypeDefinition: true,\n    EnumValueDefinition: true,\n    InputValueDefinition: true,\n    FieldDefinition: true,\n};\nexport function getOutline(documentText) {\n    let ast;\n    try {\n        ast = parse(documentText);\n    }\n    catch (error) {\n        return null;\n    }\n    const visitorFns = outlineTreeConverter(documentText);\n    const outlineTrees = visit(ast, {\n        leave(node) {\n            if (visitorFns !== undefined && node.kind in visitorFns) {\n                return visitorFns[node.kind](node);\n            }\n            return null;\n        },\n    });\n    return { outlineTrees };\n}\nfunction outlineTreeConverter(docText) {\n    const meta = (node) => {\n        return {\n            representativeName: node.name,\n            startPosition: offsetToPosition(docText, node.loc.start),\n            endPosition: offsetToPosition(docText, node.loc.end),\n            kind: node.kind,\n            children: node.selectionSet || node.fields || node.values || node.arguments || [],\n        };\n    };\n    return {\n        Field: (node) => {\n            const tokenizedText = node.alias\n                ? [buildToken('plain', node.alias), buildToken('plain', ': ')]\n                : [];\n            tokenizedText.push(buildToken('plain', node.name));\n            return Object.assign({ tokenizedText }, meta(node));\n        },\n        OperationDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', node.operation),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        Document: (node) => node.definitions,\n        SelectionSet: (node) => concatMap(node.selections, (child) => {\n            return child.kind === INLINE_FRAGMENT ? child.selectionSet : child;\n        }),\n        Name: (node) => node.value,\n        FragmentDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', 'fragment'),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        InterfaceTypeDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', 'interface'),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        EnumTypeDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', 'enum'),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        EnumValueDefinition: (node) => (Object.assign({ tokenizedText: [buildToken('plain', node.name)] }, meta(node))),\n        ObjectTypeDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', 'type'),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        InputObjectTypeDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', 'input'),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        FragmentSpread: (node) => (Object.assign({ tokenizedText: [\n                buildToken('plain', '...'),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        InputValueDefinition: (node) => {\n            return Object.assign({ tokenizedText: [buildToken('plain', node.name)] }, meta(node));\n        },\n        FieldDefinition: (node) => {\n            return Object.assign({ tokenizedText: [buildToken('plain', node.name)] }, meta(node));\n        },\n        InlineFragment: (node) => node.selectionSet,\n    };\n}\nfunction buildToken(kind, value) {\n    return { kind, value };\n}\nfunction concatMap(arr, fn) {\n    const res = [];\n    for (let i = 0; i < arr.length; i++) {\n        const x = fn(arr[i], i);\n        if (Array.isArray(x)) {\n            res.push(...x);\n        }\n        else {\n            res.push(x);\n        }\n    }\n    return res;\n}\n//# sourceMappingURL=getOutline.js.map","import { GraphQLNonNull, GraphQLList, } from 'graphql';\nimport { getTokenAtPosition, getTypeInfo } from './getAutocompleteSuggestions';\nexport function getHoverInformation(schema, queryText, cursor, contextToken) {\n    const token = contextToken || getTokenAtPosition(queryText, cursor);\n    if (!schema || !token || !token.state) {\n        return '';\n    }\n    const state = token.state;\n    const kind = state.kind;\n    const step = state.step;\n    const typeInfo = getTypeInfo(schema, token.state);\n    const options = { schema };\n    if ((kind === 'Field' && step === 0 && typeInfo.fieldDef) ||\n        (kind === 'AliasedField' && step === 2 && typeInfo.fieldDef)) {\n        const into = [];\n        renderField(into, typeInfo, options);\n        renderDescription(into, options, typeInfo.fieldDef);\n        return into.join('').trim();\n    }\n    else if (kind === 'Directive' && step === 1 && typeInfo.directiveDef) {\n        const into = [];\n        renderDirective(into, typeInfo, options);\n        renderDescription(into, options, typeInfo.directiveDef);\n        return into.join('').trim();\n    }\n    else if (kind === 'Argument' && step === 0 && typeInfo.argDef) {\n        const into = [];\n        renderArg(into, typeInfo, options);\n        renderDescription(into, options, typeInfo.argDef);\n        return into.join('').trim();\n    }\n    else if (kind === 'EnumValue' &&\n        typeInfo.enumValue &&\n        'description' in typeInfo.enumValue) {\n        const into = [];\n        renderEnumValue(into, typeInfo, options);\n        renderDescription(into, options, typeInfo.enumValue);\n        return into.join('').trim();\n    }\n    else if (kind === 'NamedType' &&\n        typeInfo.type &&\n        'description' in typeInfo.type) {\n        const into = [];\n        renderType(into, typeInfo, options, typeInfo.type);\n        renderDescription(into, options, typeInfo.type);\n        return into.join('').trim();\n    }\n    return '';\n}\nfunction renderField(into, typeInfo, options) {\n    renderQualifiedField(into, typeInfo, options);\n    renderTypeAnnotation(into, typeInfo, options, typeInfo.type);\n}\nfunction renderQualifiedField(into, typeInfo, options) {\n    if (!typeInfo.fieldDef) {\n        return;\n    }\n    const fieldName = typeInfo.fieldDef.name;\n    if (fieldName.slice(0, 2) !== '__') {\n        renderType(into, typeInfo, options, typeInfo.parentType);\n        text(into, '.');\n    }\n    text(into, fieldName);\n}\nfunction renderDirective(into, typeInfo, _options) {\n    if (!typeInfo.directiveDef) {\n        return;\n    }\n    const name = '@' + typeInfo.directiveDef.name;\n    text(into, name);\n}\nfunction renderArg(into, typeInfo, options) {\n    if (typeInfo.directiveDef) {\n        renderDirective(into, typeInfo, options);\n    }\n    else if (typeInfo.fieldDef) {\n        renderQualifiedField(into, typeInfo, options);\n    }\n    if (!typeInfo.argDef) {\n        return;\n    }\n    const name = typeInfo.argDef.name;\n    text(into, '(');\n    text(into, name);\n    renderTypeAnnotation(into, typeInfo, options, typeInfo.inputType);\n    text(into, ')');\n}\nfunction renderTypeAnnotation(into, typeInfo, options, t) {\n    text(into, ': ');\n    renderType(into, typeInfo, options, t);\n}\nfunction renderEnumValue(into, typeInfo, options) {\n    if (!typeInfo.enumValue) {\n        return;\n    }\n    const name = typeInfo.enumValue.name;\n    renderType(into, typeInfo, options, typeInfo.inputType);\n    text(into, '.');\n    text(into, name);\n}\nfunction renderType(into, typeInfo, options, t) {\n    if (!t) {\n        return;\n    }\n    if (t instanceof GraphQLNonNull) {\n        renderType(into, typeInfo, options, t.ofType);\n        text(into, '!');\n    }\n    else if (t instanceof GraphQLList) {\n        text(into, '[');\n        renderType(into, typeInfo, options, t.ofType);\n        text(into, ']');\n    }\n    else {\n        text(into, t.name);\n    }\n}\nfunction renderDescription(into, options, def) {\n    if (!def) {\n        return;\n    }\n    const description = typeof def.description === 'string' ? def.description : null;\n    if (description) {\n        text(into, '\\n\\n');\n        text(into, description);\n    }\n    renderDeprecation(into, options, def);\n}\nfunction renderDeprecation(into, _options, def) {\n    if (!def) {\n        return;\n    }\n    const reason = def.deprecationReason ? def.deprecationReason : null;\n    if (!reason) {\n        return;\n    }\n    text(into, '\\n\\n');\n    text(into, 'Deprecated: ');\n    text(into, reason);\n}\nfunction text(into, content) {\n    into.push(content);\n}\n//# sourceMappingURL=getHoverInformation.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SymbolKind, } from 'vscode-languageserver-types';\nimport { Kind, parse, print } from 'graphql';\nimport { getAutocompleteSuggestions } from './getAutocompleteSuggestions';\nimport { getHoverInformation } from './getHoverInformation';\nimport { validateQuery, getRange, DIAGNOSTIC_SEVERITY } from './getDiagnostics';\nimport { getDefinitionQueryResultForFragmentSpread, getDefinitionQueryResultForDefinitionNode, getDefinitionQueryResultForNamedType, } from './getDefinition';\nimport { getOutline } from './getOutline';\nimport { getASTNodeAtPosition } from 'graphql-language-service-utils';\nconst { FRAGMENT_DEFINITION, OBJECT_TYPE_DEFINITION, INTERFACE_TYPE_DEFINITION, ENUM_TYPE_DEFINITION, UNION_TYPE_DEFINITION, SCALAR_TYPE_DEFINITION, INPUT_OBJECT_TYPE_DEFINITION, SCALAR_TYPE_EXTENSION, OBJECT_TYPE_EXTENSION, INTERFACE_TYPE_EXTENSION, UNION_TYPE_EXTENSION, ENUM_TYPE_EXTENSION, INPUT_OBJECT_TYPE_EXTENSION, DIRECTIVE_DEFINITION, FRAGMENT_SPREAD, OPERATION_DEFINITION, NAMED_TYPE, } = Kind;\nconst KIND_TO_SYMBOL_KIND = {\n    [Kind.FIELD]: SymbolKind.Field,\n    [Kind.OPERATION_DEFINITION]: SymbolKind.Class,\n    [Kind.FRAGMENT_DEFINITION]: SymbolKind.Class,\n    [Kind.FRAGMENT_SPREAD]: SymbolKind.Struct,\n    [Kind.OBJECT_TYPE_DEFINITION]: SymbolKind.Class,\n    [Kind.ENUM_TYPE_DEFINITION]: SymbolKind.Enum,\n    [Kind.ENUM_VALUE_DEFINITION]: SymbolKind.EnumMember,\n    [Kind.INPUT_OBJECT_TYPE_DEFINITION]: SymbolKind.Class,\n    [Kind.INPUT_VALUE_DEFINITION]: SymbolKind.Field,\n    [Kind.FIELD_DEFINITION]: SymbolKind.Field,\n    [Kind.INTERFACE_TYPE_DEFINITION]: SymbolKind.Interface,\n    [Kind.DOCUMENT]: SymbolKind.File,\n    FieldWithArguments: SymbolKind.Method,\n};\nfunction getKind(tree) {\n    if (tree.kind === 'FieldDefinition' &&\n        tree.children &&\n        tree.children.length > 0) {\n        return KIND_TO_SYMBOL_KIND.FieldWithArguments;\n    }\n    return KIND_TO_SYMBOL_KIND[tree.kind];\n}\nexport class GraphQLLanguageService {\n    constructor(cache) {\n        this._graphQLCache = cache;\n        this._graphQLConfig = cache.getGraphQLConfig();\n    }\n    getConfigForURI(uri) {\n        const config = this._graphQLConfig.getProjectForFile(uri);\n        if (config) {\n            return config;\n        }\n        throw Error(`No config found for uri: ${uri}`);\n    }\n    getDiagnostics(query, uri, isRelayCompatMode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let queryHasExtensions = false;\n            const projectConfig = this.getConfigForURI(uri);\n            if (!projectConfig) {\n                return [];\n            }\n            const { schema: schemaPath, name: projectName, extensions } = projectConfig;\n            try {\n                const queryAST = parse(query);\n                if (!schemaPath || uri !== schemaPath) {\n                    queryHasExtensions = queryAST.definitions.some(definition => {\n                        switch (definition.kind) {\n                            case OBJECT_TYPE_DEFINITION:\n                            case INTERFACE_TYPE_DEFINITION:\n                            case ENUM_TYPE_DEFINITION:\n                            case UNION_TYPE_DEFINITION:\n                            case SCALAR_TYPE_DEFINITION:\n                            case INPUT_OBJECT_TYPE_DEFINITION:\n                            case SCALAR_TYPE_EXTENSION:\n                            case OBJECT_TYPE_EXTENSION:\n                            case INTERFACE_TYPE_EXTENSION:\n                            case UNION_TYPE_EXTENSION:\n                            case ENUM_TYPE_EXTENSION:\n                            case INPUT_OBJECT_TYPE_EXTENSION:\n                            case DIRECTIVE_DEFINITION:\n                                return true;\n                        }\n                        return false;\n                    });\n                }\n            }\n            catch (error) {\n                const range = getRange(error.locations[0], query);\n                return [\n                    {\n                        severity: DIAGNOSTIC_SEVERITY.Error,\n                        message: error.message,\n                        source: 'GraphQL: Syntax',\n                        range,\n                    },\n                ];\n            }\n            let source = query;\n            const fragmentDefinitions = yield this._graphQLCache.getFragmentDefinitions(projectConfig);\n            const fragmentDependencies = yield this._graphQLCache.getFragmentDependencies(query, fragmentDefinitions);\n            const dependenciesSource = fragmentDependencies.reduce((prev, cur) => `${prev} ${print(cur.definition)}`, '');\n            source = `${source} ${dependenciesSource}`;\n            let validationAst = null;\n            try {\n                validationAst = parse(source);\n            }\n            catch (error) {\n                return [];\n            }\n            let customRules = null;\n            if ((extensions === null || extensions === void 0 ? void 0 : extensions.customValidationRules) &&\n                typeof extensions.customValidationRules === 'function') {\n                customRules = extensions.customValidationRules(this._graphQLConfig);\n            }\n            const schema = yield this._graphQLCache.getSchema(projectName, queryHasExtensions);\n            if (!schema) {\n                return [];\n            }\n            return validateQuery(validationAst, schema, customRules, isRelayCompatMode);\n        });\n    }\n    getAutocompleteSuggestions(query, position, filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const projectConfig = this.getConfigForURI(filePath);\n            const schema = yield this._graphQLCache.getSchema(projectConfig.name);\n            if (schema) {\n                return getAutocompleteSuggestions(schema, query, position);\n            }\n            return [];\n        });\n    }\n    getHoverInformation(query, position, filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const projectConfig = this.getConfigForURI(filePath);\n            const schema = yield this._graphQLCache.getSchema(projectConfig.name);\n            if (schema) {\n                return getHoverInformation(schema, query, position);\n            }\n            return '';\n        });\n    }\n    getDefinition(query, position, filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const projectConfig = this.getConfigForURI(filePath);\n            let ast;\n            try {\n                ast = parse(query);\n            }\n            catch (error) {\n                return null;\n            }\n            const node = getASTNodeAtPosition(query, ast, position);\n            if (node) {\n                switch (node.kind) {\n                    case FRAGMENT_SPREAD:\n                        return this._getDefinitionForFragmentSpread(query, ast, node, filePath, projectConfig);\n                    case FRAGMENT_DEFINITION:\n                    case OPERATION_DEFINITION:\n                        return getDefinitionQueryResultForDefinitionNode(filePath, query, node);\n                    case NAMED_TYPE:\n                        return this._getDefinitionForNamedType(query, ast, node, filePath, projectConfig);\n                }\n            }\n            return null;\n        });\n    }\n    getDocumentSymbols(document, filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const outline = yield this.getOutline(document);\n            if (!outline) {\n                return [];\n            }\n            const output = [];\n            const input = outline.outlineTrees.map((tree) => [null, tree]);\n            while (input.length > 0) {\n                const res = input.pop();\n                if (!res) {\n                    return [];\n                }\n                const [parent, tree] = res;\n                if (!tree) {\n                    return [];\n                }\n                output.push({\n                    name: tree.representativeName,\n                    kind: getKind(tree),\n                    location: {\n                        uri: filePath,\n                        range: {\n                            start: tree.startPosition,\n                            end: tree.endPosition,\n                        },\n                    },\n                    containerName: parent ? parent.representativeName : undefined,\n                });\n                input.push(...tree.children.map(child => [tree, child]));\n            }\n            return output;\n        });\n    }\n    _getDefinitionForNamedType(query, ast, node, filePath, projectConfig) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const objectTypeDefinitions = yield this._graphQLCache.getObjectTypeDefinitions(projectConfig);\n            const dependencies = yield this._graphQLCache.getObjectTypeDependenciesForAST(ast, objectTypeDefinitions);\n            const localObjectTypeDefinitions = ast.definitions.filter(definition => definition.kind === OBJECT_TYPE_DEFINITION ||\n                definition.kind === INPUT_OBJECT_TYPE_DEFINITION ||\n                definition.kind === ENUM_TYPE_DEFINITION ||\n                definition.kind === SCALAR_TYPE_DEFINITION ||\n                definition.kind === INTERFACE_TYPE_DEFINITION);\n            const typeCastedDefs = localObjectTypeDefinitions;\n            const localOperationDefinationInfos = typeCastedDefs.map((definition) => ({\n                filePath,\n                content: query,\n                definition,\n            }));\n            const result = yield getDefinitionQueryResultForNamedType(query, node, dependencies.concat(localOperationDefinationInfos));\n            return result;\n        });\n    }\n    _getDefinitionForFragmentSpread(query, ast, node, filePath, projectConfig) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const fragmentDefinitions = yield this._graphQLCache.getFragmentDefinitions(projectConfig);\n            const dependencies = yield this._graphQLCache.getFragmentDependenciesForAST(ast, fragmentDefinitions);\n            const localFragDefinitions = ast.definitions.filter(definition => definition.kind === FRAGMENT_DEFINITION);\n            const typeCastedDefs = localFragDefinitions;\n            const localFragInfos = typeCastedDefs.map((definition) => ({\n                filePath,\n                content: query,\n                definition,\n            }));\n            const result = yield getDefinitionQueryResultForFragmentSpread(query, node, dependencies.concat(localFragInfos));\n            return result;\n        });\n    }\n    getOutline(documentText) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return getOutline(documentText);\n        });\n    }\n}\n//# sourceMappingURL=GraphQLLanguageService.js.map","declare let window: any;\nconst _global = typeof global !== 'undefined' ? global : (typeof window !== 'undefined' ? window : {});\nconst NativeWebSocket = _global.WebSocket || _global.MozWebSocket;\n\nimport * as Backoff from 'backo2';\nimport { default as EventEmitterType, EventEmitter, ListenerFn } from 'eventemitter3';\nimport isString from './utils/is-string';\nimport isObject from './utils/is-object';\nimport { ExecutionResult } from 'graphql/execution/execute';\nimport { print } from 'graphql/language/printer';\nimport { DocumentNode } from 'graphql/language/ast';\nimport { getOperationAST } from 'graphql/utilities/getOperationAST';\nimport $$observable from 'symbol-observable';\n\nimport { GRAPHQL_WS } from './protocol';\nimport { MIN_WS_TIMEOUT, WS_TIMEOUT } from './defaults';\nimport MessageTypes from './message-types';\n\nexport interface Observer<T> {\n  next?: (value: T) => void;\n  error?: (error: Error) => void;\n  complete?: () => void;\n}\n\nexport interface Observable<T> {\n  subscribe(observer: Observer<T>): {\n    unsubscribe: () => void;\n  };\n}\n\nexport interface OperationOptions {\n  query?: string | DocumentNode;\n  variables?: Object;\n  operationName?: string;\n  [key: string]: any;\n}\n\nexport type FormatedError = Error & {\n  originalError?: any;\n};\n\nexport interface Operation {\n  options: OperationOptions;\n  handler: (error: Error[], result?: any) => void;\n}\n\nexport interface Operations {\n  [id: string]: Operation;\n}\n\nexport interface Middleware {\n  applyMiddleware(options: OperationOptions, next: Function): void;\n}\n\nexport type ConnectionParams = {\n  [paramName: string]: any,\n};\n\nexport type ConnectionParamsOptions = ConnectionParams | Function | Promise<ConnectionParams>;\n\nexport interface ClientOptions {\n  connectionParams?: ConnectionParamsOptions;\n  minTimeout?: number;\n  timeout?: number;\n  reconnect?: boolean;\n  reconnectionAttempts?: number;\n  connectionCallback?: (error: Error[], result?: any) => void;\n  lazy?: boolean;\n  inactivityTimeout?: number;\n  wsOptionArguments?: any[];\n}\n\nexport class SubscriptionClient {\n  public client: any;\n  public operations: Operations;\n  private url: string;\n  private nextOperationId: number;\n  private connectionParams: Function;\n  private minWsTimeout: number;\n  private wsTimeout: number;\n  private unsentMessagesQueue: Array<any>; // queued messages while websocket is opening.\n  private reconnect: boolean;\n  private reconnecting: boolean;\n  private reconnectionAttempts: number;\n  private backoff: any;\n  private connectionCallback: any;\n  private eventEmitter: EventEmitterType;\n  private lazy: boolean;\n  private inactivityTimeout: number;\n  private inactivityTimeoutId: any;\n  private closedByUser: boolean;\n  private wsImpl: any;\n  private wsProtocols: string | string[];\n  private wasKeepAliveReceived: boolean;\n  private tryReconnectTimeoutId: any;\n  private checkConnectionIntervalId: any;\n  private maxConnectTimeoutId: any;\n  private middlewares: Middleware[];\n  private maxConnectTimeGenerator: any;\n  private wsOptionArguments: any[];\n\n  constructor(\n    url: string,\n    options?: ClientOptions,\n    webSocketImpl?: any,\n    webSocketProtocols?: string | string[],\n  ) {\n    const {\n      connectionCallback = undefined,\n      connectionParams = {},\n      minTimeout = MIN_WS_TIMEOUT,\n      timeout = WS_TIMEOUT,\n      reconnect = false,\n      reconnectionAttempts = Infinity,\n      lazy = false,\n      inactivityTimeout = 0,\n      wsOptionArguments = [],\n    } = (options || {});\n\n    this.wsImpl = webSocketImpl || NativeWebSocket;\n    if (!this.wsImpl) {\n      throw new Error('Unable to find native implementation, or alternative implementation for WebSocket!');\n    }\n\n    this.wsProtocols = webSocketProtocols || GRAPHQL_WS;\n    this.connectionCallback = connectionCallback;\n    this.url = url;\n    this.operations = {};\n    this.nextOperationId = 0;\n    this.minWsTimeout = minTimeout;\n    this.wsTimeout = timeout;\n    this.unsentMessagesQueue = [];\n    this.reconnect = reconnect;\n    this.reconnecting = false;\n    this.reconnectionAttempts = reconnectionAttempts;\n    this.lazy = !!lazy;\n    this.inactivityTimeout = inactivityTimeout;\n    this.closedByUser = false;\n    this.backoff = new Backoff({ jitter: 0.5 });\n    this.eventEmitter = new EventEmitter();\n    this.middlewares = [];\n    this.client = null;\n    this.maxConnectTimeGenerator = this.createMaxConnectTimeGenerator();\n    this.connectionParams = this.getConnectionParams(connectionParams);\n    this.wsOptionArguments = wsOptionArguments;\n\n    if (!this.lazy) {\n      this.connect();\n    }\n  }\n\n  public get status() {\n    if (this.client === null) {\n      return this.wsImpl.CLOSED;\n    }\n\n    return this.client.readyState;\n  }\n\n  public close(isForced = true, closedByUser = true) {\n    this.clearInactivityTimeout();\n    if (this.client !== null) {\n      this.closedByUser = closedByUser;\n\n      if (isForced) {\n        this.clearCheckConnectionInterval();\n        this.clearMaxConnectTimeout();\n        this.clearTryReconnectTimeout();\n        this.unsubscribeAll();\n        this.sendMessage(undefined, MessageTypes.GQL_CONNECTION_TERMINATE, null);\n      }\n\n      this.client.close();\n      this.client.onopen = null;\n      this.client.onclose = null;\n      this.client.onerror = null;\n      this.client.onmessage = null;\n      this.client = null;\n      this.eventEmitter.emit('disconnected');\n\n      if (!isForced) {\n        this.tryReconnect();\n      }\n    }\n  }\n\n  public request(request: OperationOptions): Observable<ExecutionResult> {\n    const getObserver = this.getObserver.bind(this);\n    const executeOperation = this.executeOperation.bind(this);\n    const unsubscribe = this.unsubscribe.bind(this);\n\n    let opId: string;\n\n    this.clearInactivityTimeout();\n\n    return {\n      [$$observable]() {\n        return this;\n      },\n      subscribe(\n        observerOrNext: ((Observer<ExecutionResult>) | ((v: ExecutionResult) => void)),\n        onError?: (error: Error) => void,\n        onComplete?: () => void,\n      ) {\n        const observer = getObserver(observerOrNext, onError, onComplete);\n\n        opId = executeOperation(request, (error: Error[], result: any) => {\n          if ( error === null && result === null ) {\n            if ( observer.complete ) {\n              observer.complete();\n            }\n          } else if (error) {\n            if ( observer.error ) {\n              observer.error(error[0]);\n            }\n          } else {\n            if ( observer.next ) {\n              observer.next(result);\n            }\n          }\n        });\n\n        return {\n          unsubscribe: () => {\n            if ( opId ) {\n              unsubscribe(opId);\n              opId = null;\n            }\n          },\n        };\n      },\n    };\n  }\n\n  public on(eventName: string, callback: ListenerFn, context?: any): Function {\n    const handler = this.eventEmitter.on(eventName, callback, context);\n\n    return () => {\n      handler.off(eventName, callback, context);\n    };\n  }\n\n  public onConnected(callback: ListenerFn, context?: any): Function {\n    return this.on('connected', callback, context);\n  }\n\n  public onConnecting(callback: ListenerFn, context?: any): Function {\n    return this.on('connecting', callback, context);\n  }\n\n  public onDisconnected(callback: ListenerFn, context?: any): Function {\n    return this.on('disconnected', callback, context);\n  }\n\n  public onReconnected(callback: ListenerFn, context?: any): Function {\n    return this.on('reconnected', callback, context);\n  }\n\n  public onReconnecting(callback: ListenerFn, context?: any): Function {\n    return this.on('reconnecting', callback, context);\n  }\n\n  public onError(callback: ListenerFn, context?: any): Function {\n    return this.on('error', callback, context);\n  }\n\n  public unsubscribeAll() {\n    Object.keys(this.operations).forEach( subId => {\n      this.unsubscribe(subId);\n    });\n  }\n\n  public applyMiddlewares(options: OperationOptions): Promise<OperationOptions> {\n    return new Promise((resolve, reject) => {\n      const queue = (funcs: Middleware[], scope: any) => {\n        const next = (error?: any) => {\n          if (error) {\n            reject(error);\n          } else {\n            if (funcs.length > 0) {\n              const f = funcs.shift();\n              if (f) {\n                f.applyMiddleware.apply(scope, [options, next]);\n              }\n            } else {\n              resolve(options);\n            }\n          }\n        };\n        next();\n      };\n\n      queue([...this.middlewares], this);\n    });\n  }\n\n  public use(middlewares: Middleware[]): SubscriptionClient {\n    middlewares.map((middleware) => {\n      if (typeof middleware.applyMiddleware === 'function') {\n        this.middlewares.push(middleware);\n      } else {\n        throw new Error('Middleware must implement the applyMiddleware function.');\n      }\n    });\n\n    return this;\n  }\n\n  private getConnectionParams(connectionParams: ConnectionParamsOptions): Function {\n    return (): Promise<ConnectionParams> => new Promise((resolve, reject) => {\n      if (typeof connectionParams === 'function') {\n        try {\n          return resolve(connectionParams.call(null));\n        } catch (error) {\n          return reject(error);\n        }\n      }\n\n      resolve(connectionParams);\n    });\n  }\n\n  private executeOperation(options: OperationOptions, handler: (error: Error[], result?: any) => void): string {\n    if (this.client === null) {\n      this.connect();\n    }\n\n    const opId = this.generateOperationId();\n    this.operations[opId] = { options: options, handler };\n\n    this.applyMiddlewares(options)\n      .then(processedOptions => {\n        this.checkOperationOptions(processedOptions, handler);\n        if (this.operations[opId]) {\n          this.operations[opId] = { options: processedOptions, handler };\n          this.sendMessage(opId, MessageTypes.GQL_START, processedOptions);\n        }\n      })\n      .catch(error => {\n        this.unsubscribe(opId);\n        handler(this.formatErrors(error));\n      });\n\n    return opId;\n  }\n\n  private getObserver<T>(\n    observerOrNext: ((Observer<T>) | ((v: T) => void)),\n    error?: (e: Error) => void,\n    complete?: () => void,\n  ) {\n    if ( typeof observerOrNext === 'function' ) {\n      return {\n        next: (v: T) => observerOrNext(v),\n        error: (e: Error) => error && error(e),\n        complete: () => complete && complete(),\n      };\n    }\n\n    return observerOrNext;\n  }\n\n  private createMaxConnectTimeGenerator() {\n    const minValue = this.minWsTimeout;\n    const maxValue = this.wsTimeout;\n\n    return new Backoff({\n      min: minValue,\n      max: maxValue,\n      factor: 1.2,\n    });\n  }\n\n  private clearCheckConnectionInterval() {\n    if (this.checkConnectionIntervalId) {\n      clearInterval(this.checkConnectionIntervalId);\n      this.checkConnectionIntervalId = null;\n    }\n  }\n\n  private clearMaxConnectTimeout() {\n    if (this.maxConnectTimeoutId) {\n      clearTimeout(this.maxConnectTimeoutId);\n      this.maxConnectTimeoutId = null;\n    }\n    }\n\n  private clearTryReconnectTimeout() {\n    if (this.tryReconnectTimeoutId) {\n      clearTimeout(this.tryReconnectTimeoutId);\n      this.tryReconnectTimeoutId = null;\n    }\n  }\n\n  private clearInactivityTimeout() {\n    if (this.inactivityTimeoutId) {\n      clearTimeout(this.inactivityTimeoutId);\n      this.inactivityTimeoutId = null;\n    }\n  }\n\n  private setInactivityTimeout() {\n    if (this.inactivityTimeout > 0 && Object.keys(this.operations).length === 0) {\n      this.inactivityTimeoutId = setTimeout(() => {\n        if (Object.keys(this.operations).length === 0) {\n          this.close();\n        }\n      }, this.inactivityTimeout);\n    }\n  }\n\n  private checkOperationOptions(options: OperationOptions, handler: (error: Error[], result?: any) => void) {\n    const { query, variables, operationName } = options;\n\n    if (!query) {\n      throw new Error('Must provide a query.');\n    }\n\n    if (!handler) {\n      throw new Error('Must provide an handler.');\n    }\n\n    if (\n      ( !isString(query) && !getOperationAST(query, operationName)) ||\n      ( operationName && !isString(operationName)) ||\n      ( variables && !isObject(variables))\n    ) {\n      throw new Error('Incorrect option types. query must be a string or a document,' +\n        '`operationName` must be a string, and `variables` must be an object.');\n    }\n  }\n\n  private buildMessage(id: string, type: string, payload: any) {\n    const payloadToReturn = payload && payload.query ?\n      {\n        ...payload,\n        query: typeof payload.query === 'string' ? payload.query : print(payload.query),\n      } :\n      payload;\n\n    return {\n      id,\n      type,\n      payload: payloadToReturn,\n    };\n  }\n\n  // ensure we have an array of errors\n  private formatErrors(errors: any): FormatedError[] {\n    if (Array.isArray(errors)) {\n      return errors;\n    }\n\n    // TODO  we should not pass ValidationError to callback in the future.\n    // ValidationError\n    if (errors && errors.errors) {\n      return this.formatErrors(errors.errors);\n    }\n\n    if (errors && errors.message) {\n      return [errors];\n    }\n\n    return [{\n      name: 'FormatedError',\n      message: 'Unknown error',\n      originalError: errors,\n    }];\n  }\n\n  private sendMessage(id: string, type: string, payload: any) {\n    this.sendMessageRaw(this.buildMessage(id, type, payload));\n  }\n\n  // send message, or queue it if connection is not open\n  private sendMessageRaw(message: Object) {\n    switch (this.status) {\n      case this.wsImpl.OPEN:\n        let serializedMessage: string = JSON.stringify(message);\n        try {\n          JSON.parse(serializedMessage);\n        } catch (e) {\n          this.eventEmitter.emit('error', new Error(`Message must be JSON-serializable. Got: ${message}`));\n        }\n\n        this.client.send(serializedMessage);\n        break;\n      case this.wsImpl.CONNECTING:\n        this.unsentMessagesQueue.push(message);\n\n        break;\n      default:\n        if (!this.reconnecting) {\n          this.eventEmitter.emit('error', new Error('A message was not sent because socket is not connected, is closing or ' +\n            'is already closed. Message was: ' + JSON.stringify(message)));\n        }\n    }\n  }\n\n  private generateOperationId(): string {\n    return String(++this.nextOperationId);\n  }\n\n  private tryReconnect() {\n    if (!this.reconnect || this.backoff.attempts >= this.reconnectionAttempts) {\n      return;\n    }\n\n    if (!this.reconnecting) {\n      Object.keys(this.operations).forEach((key) => {\n        this.unsentMessagesQueue.push(\n          this.buildMessage(key, MessageTypes.GQL_START, this.operations[key].options),\n        );\n      });\n      this.reconnecting = true;\n    }\n\n    this.clearTryReconnectTimeout();\n\n    const delay = this.backoff.duration();\n    this.tryReconnectTimeoutId = setTimeout(() => {\n      this.connect();\n    }, delay);\n  }\n\n  private flushUnsentMessagesQueue() {\n    this.unsentMessagesQueue.forEach((message) => {\n      this.sendMessageRaw(message);\n    });\n    this.unsentMessagesQueue = [];\n  }\n\n  private checkConnection() {\n    if (this.wasKeepAliveReceived) {\n      this.wasKeepAliveReceived = false;\n      return;\n    }\n\n    if (!this.reconnecting) {\n      this.close(false, true);\n    }\n  }\n\n  private checkMaxConnectTimeout() {\n    this.clearMaxConnectTimeout();\n\n    // Max timeout trying to connect\n    this.maxConnectTimeoutId = setTimeout(() => {\n      if (this.status !== this.wsImpl.OPEN) {\n        this.reconnecting = true;\n        this.close(false, true);\n      }\n    }, this.maxConnectTimeGenerator.duration());\n  }\n\n  private connect() {\n    this.client = new this.wsImpl(this.url, this.wsProtocols, ...this.wsOptionArguments);\n\n    this.checkMaxConnectTimeout();\n\n    this.client.onopen = async () => {\n      if (this.status === this.wsImpl.OPEN) {\n        this.clearMaxConnectTimeout();\n        this.closedByUser = false;\n        this.eventEmitter.emit(this.reconnecting ? 'reconnecting' : 'connecting');\n\n        try {\n          const connectionParams: ConnectionParams = await this.connectionParams();\n\n          // Send CONNECTION_INIT message, no need to wait for connection to success (reduce roundtrips)\n          this.sendMessage(undefined, MessageTypes.GQL_CONNECTION_INIT, connectionParams);\n          this.flushUnsentMessagesQueue();\n        } catch (error) {\n          this.sendMessage(undefined, MessageTypes.GQL_CONNECTION_ERROR, error);\n          this.flushUnsentMessagesQueue();\n        }\n      }\n    };\n\n    this.client.onclose = () => {\n      if (!this.closedByUser) {\n        this.close(false, false);\n      }\n    };\n\n    this.client.onerror = (err: Error) => {\n      // Capture and ignore errors to prevent unhandled exceptions, wait for\n      // onclose to fire before attempting a reconnect.\n      this.eventEmitter.emit('error', err);\n    };\n\n    this.client.onmessage = ({ data }: {data: any}) => {\n      this.processReceivedData(data);\n    };\n  }\n\n  private processReceivedData(receivedData: any) {\n    let parsedMessage: any;\n    let opId: string;\n\n    try {\n      parsedMessage = JSON.parse(receivedData);\n      opId = parsedMessage.id;\n    } catch (e) {\n      throw new Error(`Message must be JSON-parseable. Got: ${receivedData}`);\n    }\n\n    if (\n      [ MessageTypes.GQL_DATA,\n        MessageTypes.GQL_COMPLETE,\n        MessageTypes.GQL_ERROR,\n      ].indexOf(parsedMessage.type) !== -1 && !this.operations[opId]\n    ) {\n      this.unsubscribe(opId);\n\n      return;\n    }\n\n    switch (parsedMessage.type) {\n      case MessageTypes.GQL_CONNECTION_ERROR:\n        if (this.connectionCallback) {\n          this.connectionCallback(parsedMessage.payload);\n        }\n        break;\n\n      case MessageTypes.GQL_CONNECTION_ACK:\n        this.eventEmitter.emit(this.reconnecting ? 'reconnected' : 'connected', parsedMessage.payload);\n        this.reconnecting = false;\n        this.backoff.reset();\n        this.maxConnectTimeGenerator.reset();\n\n        if (this.connectionCallback) {\n          this.connectionCallback();\n        }\n        break;\n\n      case MessageTypes.GQL_COMPLETE:\n        const handler = this.operations[opId].handler;\n        delete this.operations[opId];\n        handler.call(this, null, null);\n        break;\n\n      case MessageTypes.GQL_ERROR:\n        this.operations[opId].handler(this.formatErrors(parsedMessage.payload), null);\n        delete this.operations[opId];\n        break;\n\n      case MessageTypes.GQL_DATA:\n        const parsedPayload = !parsedMessage.payload.errors ?\n          parsedMessage.payload : {...parsedMessage.payload, errors: this.formatErrors(parsedMessage.payload.errors)};\n        this.operations[opId].handler(null, parsedPayload);\n        break;\n\n      case MessageTypes.GQL_CONNECTION_KEEP_ALIVE:\n        const firstKA = typeof this.wasKeepAliveReceived === 'undefined';\n        this.wasKeepAliveReceived = true;\n\n        if (firstKA) {\n          this.checkConnection();\n        }\n\n        if (this.checkConnectionIntervalId) {\n          clearInterval(this.checkConnectionIntervalId);\n          this.checkConnection();\n        }\n        this.checkConnectionIntervalId = setInterval(this.checkConnection.bind(this), this.wsTimeout);\n        break;\n\n      default:\n        throw new Error('Invalid message type!');\n    }\n  }\n\n  private unsubscribe(opId: string) {\n    if (this.operations[opId]) {\n      delete this.operations[opId];\n      this.setInactivityTimeout();\n      this.sendMessage(opId, MessageTypes.GQL_STOP, undefined);\n    }\n  }\n}\n","export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","var global =\n  (typeof globalThis !== 'undefined' && globalThis) ||\n  (typeof self !== 'undefined' && self) ||\n  (typeof global !== 'undefined' && global)\n\nvar support = {\n  searchParams: 'URLSearchParams' in global,\n  iterable: 'Symbol' in global && 'iterator' in Symbol,\n  blob:\n    'FileReader' in global &&\n    'Blob' in global &&\n    (function() {\n      try {\n        new Blob()\n        return true\n      } catch (e) {\n        return false\n      }\n    })(),\n  formData: 'FormData' in global,\n  arrayBuffer: 'ArrayBuffer' in global\n}\n\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj)\n}\n\nif (support.arrayBuffer) {\n  var viewClasses = [\n    '[object Int8Array]',\n    '[object Uint8Array]',\n    '[object Uint8ClampedArray]',\n    '[object Int16Array]',\n    '[object Uint16Array]',\n    '[object Int32Array]',\n    '[object Uint32Array]',\n    '[object Float32Array]',\n    '[object Float64Array]'\n  ]\n\n  var isArrayBufferView =\n    ArrayBuffer.isView ||\n    function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n}\n\nfunction normalizeName(name) {\n  if (typeof name !== 'string') {\n    name = String(name)\n  }\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {\n    throw new TypeError('Invalid character in header field name')\n  }\n  return name.toLowerCase()\n}\n\nfunction normalizeValue(value) {\n  if (typeof value !== 'string') {\n    value = String(value)\n  }\n  return value\n}\n\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift()\n      return {done: value === undefined, value: value}\n    }\n  }\n\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator\n    }\n  }\n\n  return iterator\n}\n\nexport function Headers(headers) {\n  this.map = {}\n\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value)\n    }, this)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      this.append(header[0], header[1])\n    }, this)\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name])\n    }, this)\n  }\n}\n\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name)\n  value = normalizeValue(value)\n  var oldValue = this.map[name]\n  this.map[name] = oldValue ? oldValue + ', ' + value : value\n}\n\nHeaders.prototype['delete'] = function(name) {\n  delete this.map[normalizeName(name)]\n}\n\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name)\n  return this.has(name) ? this.map[name] : null\n}\n\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name))\n}\n\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value)\n}\n\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this)\n    }\n  }\n}\n\nHeaders.prototype.keys = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push(name)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.values = function() {\n  var items = []\n  this.forEach(function(value) {\n    items.push(value)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.entries = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push([name, value])\n  })\n  return iteratorFor(items)\n}\n\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n}\n\nfunction consumed(body) {\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError('Already read'))\n  }\n  body.bodyUsed = true\n}\n\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result)\n    }\n    reader.onerror = function() {\n      reject(reader.error)\n    }\n  })\n}\n\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsArrayBuffer(blob)\n  return promise\n}\n\nfunction readBlobAsText(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsText(blob)\n  return promise\n}\n\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf)\n  var chars = new Array(view.length)\n\n  for (var i = 0; i < view.length; i++) {\n    chars[i] = String.fromCharCode(view[i])\n  }\n  return chars.join('')\n}\n\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0)\n  } else {\n    var view = new Uint8Array(buf.byteLength)\n    view.set(new Uint8Array(buf))\n    return view.buffer\n  }\n}\n\nfunction Body() {\n  this.bodyUsed = false\n\n  this._initBody = function(body) {\n    /*\n      fetch-mock wraps the Response object in an ES6 Proxy to\n      provide useful test harness features such as flush. However, on\n      ES5 browsers without fetch or Proxy support pollyfills must be used;\n      the proxy-pollyfill is unable to proxy an attribute unless it exists\n      on the object before the Proxy is created. This change ensures\n      Response.bodyUsed exists on the instance, while maintaining the\n      semantic of setting Request.bodyUsed in the constructor before\n      _initBody is called.\n    */\n    this.bodyUsed = this.bodyUsed\n    this._bodyInit = body\n    if (!body) {\n      this._bodyText = ''\n    } else if (typeof body === 'string') {\n      this._bodyText = body\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString()\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer)\n      // IE 10-11 can't handle a DataView body.\n      this._bodyInit = new Blob([this._bodyArrayBuffer])\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body)\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body)\n    }\n\n    if (!this.headers.get('content-type')) {\n      if (typeof body === 'string') {\n        this.headers.set('content-type', 'text/plain;charset=UTF-8')\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set('content-type', this._bodyBlob.type)\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n      }\n    }\n  }\n\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as blob')\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]))\n      }\n    }\n\n    this.arrayBuffer = function() {\n      if (this._bodyArrayBuffer) {\n        var isConsumed = consumed(this)\n        if (isConsumed) {\n          return isConsumed\n        }\n        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n          return Promise.resolve(\n            this._bodyArrayBuffer.buffer.slice(\n              this._bodyArrayBuffer.byteOffset,\n              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n            )\n          )\n        } else {\n          return Promise.resolve(this._bodyArrayBuffer)\n        }\n      } else {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n    }\n  }\n\n  this.text = function() {\n    var rejected = consumed(this)\n    if (rejected) {\n      return rejected\n    }\n\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob)\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n    } else if (this._bodyFormData) {\n      throw new Error('could not read FormData body as text')\n    } else {\n      return Promise.resolve(this._bodyText)\n    }\n  }\n\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode)\n    }\n  }\n\n  this.json = function() {\n    return this.text().then(JSON.parse)\n  }\n\n  return this\n}\n\n// HTTP methods whose capitalization should be normalized\nvar methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase()\n  return methods.indexOf(upcased) > -1 ? upcased : method\n}\n\nexport function Request(input, options) {\n  if (!(this instanceof Request)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n\n  options = options || {}\n  var body = options.body\n\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError('Already read')\n    }\n    this.url = input.url\n    this.credentials = input.credentials\n    if (!options.headers) {\n      this.headers = new Headers(input.headers)\n    }\n    this.method = input.method\n    this.mode = input.mode\n    this.signal = input.signal\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit\n      input.bodyUsed = true\n    }\n  } else {\n    this.url = String(input)\n  }\n\n  this.credentials = options.credentials || this.credentials || 'same-origin'\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers)\n  }\n  this.method = normalizeMethod(options.method || this.method || 'GET')\n  this.mode = options.mode || this.mode || null\n  this.signal = options.signal || this.signal\n  this.referrer = null\n\n  if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n    throw new TypeError('Body not allowed for GET or HEAD requests')\n  }\n  this._initBody(body)\n\n  if (this.method === 'GET' || this.method === 'HEAD') {\n    if (options.cache === 'no-store' || options.cache === 'no-cache') {\n      // Search for a '_' parameter in the query string\n      var reParamSearch = /([?&])_=[^&]*/\n      if (reParamSearch.test(this.url)) {\n        // If it already exists then set the value with the current time\n        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime())\n      } else {\n        // Otherwise add a new '_' parameter to the end with the current time\n        var reQueryString = /\\?/\n        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()\n      }\n    }\n  }\n}\n\nRequest.prototype.clone = function() {\n  return new Request(this, {body: this._bodyInit})\n}\n\nfunction decode(body) {\n  var form = new FormData()\n  body\n    .trim()\n    .split('&')\n    .forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n  return form\n}\n\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers()\n  // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n  // https://tools.ietf.org/html/rfc7230#section-3.2\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n  preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n    var parts = line.split(':')\n    var key = parts.shift().trim()\n    if (key) {\n      var value = parts.join(':').trim()\n      headers.append(key, value)\n    }\n  })\n  return headers\n}\n\nBody.call(Request.prototype)\n\nexport function Response(bodyInit, options) {\n  if (!(this instanceof Response)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n  if (!options) {\n    options = {}\n  }\n\n  this.type = 'default'\n  this.status = options.status === undefined ? 200 : options.status\n  this.ok = this.status >= 200 && this.status < 300\n  this.statusText = 'statusText' in options ? options.statusText : ''\n  this.headers = new Headers(options.headers)\n  this.url = options.url || ''\n  this._initBody(bodyInit)\n}\n\nBody.call(Response.prototype)\n\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  })\n}\n\nResponse.error = function() {\n  var response = new Response(null, {status: 0, statusText: ''})\n  response.type = 'error'\n  return response\n}\n\nvar redirectStatuses = [301, 302, 303, 307, 308]\n\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError('Invalid status code')\n  }\n\n  return new Response(null, {status: status, headers: {location: url}})\n}\n\nexport var DOMException = global.DOMException\ntry {\n  new DOMException()\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message\n    this.name = name\n    var error = Error(message)\n    this.stack = error.stack\n  }\n  DOMException.prototype = Object.create(Error.prototype)\n  DOMException.prototype.constructor = DOMException\n}\n\nexport function fetch(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init)\n\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    var xhr = new XMLHttpRequest()\n\n    function abortXhr() {\n      xhr.abort()\n    }\n\n    xhr.onload = function() {\n      var options = {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n      }\n      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n      var body = 'response' in xhr ? xhr.response : xhr.responseText\n      setTimeout(function() {\n        resolve(new Response(body, options))\n      }, 0)\n    }\n\n    xhr.onerror = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.ontimeout = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.onabort = function() {\n      setTimeout(function() {\n        reject(new DOMException('Aborted', 'AbortError'))\n      }, 0)\n    }\n\n    function fixUrl(url) {\n      try {\n        return url === '' && global.location.href ? global.location.href : url\n      } catch (e) {\n        return url\n      }\n    }\n\n    xhr.open(request.method, fixUrl(request.url), true)\n\n    if (request.credentials === 'include') {\n      xhr.withCredentials = true\n    } else if (request.credentials === 'omit') {\n      xhr.withCredentials = false\n    }\n\n    if ('responseType' in xhr) {\n      if (support.blob) {\n        xhr.responseType = 'blob'\n      } else if (\n        support.arrayBuffer &&\n        request.headers.get('Content-Type') &&\n        request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1\n      ) {\n        xhr.responseType = 'arraybuffer'\n      }\n    }\n\n    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {\n      Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))\n      })\n    } else {\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n    }\n\n    if (request.signal) {\n      request.signal.addEventListener('abort', abortXhr)\n\n      xhr.onreadystatechange = function() {\n        // DONE (success or failure)\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener('abort', abortXhr)\n        }\n      }\n    }\n\n    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n  })\n}\n\nfetch.polyfill = true\n\nif (!global.fetch) {\n  global.fetch = fetch\n  global.Headers = Headers\n  global.Request = Request\n  global.Response = Response\n}\n","\n/**\n * Expose `Backoff`.\n */\n\nmodule.exports = Backoff;\n\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\n\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\n\nBackoff.prototype.duration = function(){\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand =  Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\n\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\n\nBackoff.prototype.reset = function(){\n  this.attempts = 0;\n};\n\n/**\n * Set the minimum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMin = function(min){\n  this.ms = min;\n};\n\n/**\n * Set the maximum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMax = function(max){\n  this.max = max;\n};\n\n/**\n * Set the jitter\n *\n * @api public\n */\n\nBackoff.prototype.setJitter = function(jitter){\n  this.jitter = jitter;\n};\n\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","export default function isString(value?: any): value is string {\n  return typeof value === 'string';\n}\n","export default function isObject(value?: any): boolean {\n  return ((value !== null) && (typeof value === 'object'));\n}\n","import { Kind } from \"../language/kinds.mjs\";\n/**\n * Returns an operation AST given a document AST and optionally an operation\n * name. If a name is not provided, an operation is only returned if only one is\n * provided in the document.\n */\n\nexport function getOperationAST(documentAST, operationName) {\n  var operation = null;\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var definition = _documentAST$definiti2[_i2];\n\n    if (definition.kind === Kind.OPERATION_DEFINITION) {\n      var _definition$name;\n\n      if (operationName == null) {\n        // If no operation name was provided, only return an Operation if there\n        // is one defined in the document. Upon encountering the second, return\n        // null.\n        if (operation) {\n          return null;\n        }\n\n        operation = definition;\n      } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {\n        return definition;\n      }\n    }\n  }\n\n  return operation;\n}\n","/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","const GRAPHQL_WS = 'graphql-ws';\n// NOTE: This protocol is deprecated and will be removed soon.\n/**\n * @deprecated\n */\nconst GRAPHQL_SUBSCRIPTIONS = 'graphql-subscriptions';\n\nexport {\n  GRAPHQL_WS,\n  GRAPHQL_SUBSCRIPTIONS,\n};\n","const MIN_WS_TIMEOUT = 1000;\nconst WS_TIMEOUT = 30000;\n\nexport {\n  MIN_WS_TIMEOUT,\n  WS_TIMEOUT,\n};\n","export default class MessageTypes {\n  public static GQL_CONNECTION_INIT = 'connection_init'; // Client -> Server\n  public static GQL_CONNECTION_ACK = 'connection_ack'; // Server -> Client\n  public static GQL_CONNECTION_ERROR = 'connection_error'; // Server -> Client\n\n  // NOTE: The keep alive message type does not follow the standard due to connection optimizations\n  public static GQL_CONNECTION_KEEP_ALIVE = 'ka'; // Server -> Client\n\n  public static GQL_CONNECTION_TERMINATE = 'connection_terminate'; // Client -> Server\n  public static GQL_START = 'start'; // Client -> Server\n  public static GQL_DATA = 'data'; // Server -> Client\n  public static GQL_ERROR = 'error'; // Server -> Client\n  public static GQL_COMPLETE = 'complete'; // Server -> Client\n  public static GQL_STOP = 'stop'; // Client -> Server\n\n  // NOTE: The following message types are deprecated and will be removed soon.\n  /**\n   * @deprecated\n   */\n  public static SUBSCRIPTION_START = 'subscription_start';\n  /**\n   * @deprecated\n   */\n  public static SUBSCRIPTION_DATA = 'subscription_data';\n  /**\n   * @deprecated\n   */\n  public static SUBSCRIPTION_SUCCESS = 'subscription_success';\n  /**\n   * @deprecated\n   */\n  public static SUBSCRIPTION_FAIL = 'subscription_fail';\n  /**\n   * @deprecated\n   */\n  public static SUBSCRIPTION_END = 'subscription_end';\n  /**\n   * @deprecated\n   */\n  public static INIT = 'init';\n  /**\n   * @deprecated\n   */\n  public static INIT_SUCCESS = 'init_success';\n  /**\n   * @deprecated\n   */\n  public static INIT_FAIL = 'init_fail';\n  /**\n   * @deprecated\n   */\n  public static KEEP_ALIVE = 'keepalive';\n\n  constructor() {\n    throw new Error('Static Class');\n  }\n}\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function filter(predicate, thisArg) {\n    return function filterOperatorFunction(source) {\n        return source.lift(new FilterOperator(predicate, thisArg));\n    };\n}\nvar FilterOperator = /*@__PURE__*/ (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\nvar FilterSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        var _this = _super.call(this, destination) || this;\n        _this.predicate = predicate;\n        _this.thisArg = thisArg;\n        _this.count = 0;\n        return _this;\n    }\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber));\n//# sourceMappingURL=filter.js.map\n","import objectValues from \"../polyfills/objectValues.mjs\";\nimport keyMap from \"../jsutils/keyMap.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { isLeafType, isInputObjectType, isListType, isNonNullType } from \"../type/definition.mjs\";\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * Returns `undefined` when the value could not be validly coerced according to\n * the provided type.\n *\n * | GraphQL Value        | JSON Value    |\n * | -------------------- | ------------- |\n * | Input Object         | Object        |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Number        |\n * | Enum Value           | Mixed         |\n * | NullValue            | null          |\n *\n */\n\nexport function valueFromAST(valueNode, type, variables) {\n  if (!valueNode) {\n    // When there is no node, then there is also no value.\n    // Importantly, this is different from returning the value null.\n    return;\n  }\n\n  if (valueNode.kind === Kind.VARIABLE) {\n    var variableName = valueNode.name.value;\n\n    if (variables == null || variables[variableName] === undefined) {\n      // No valid return value.\n      return;\n    }\n\n    var variableValue = variables[variableName];\n\n    if (variableValue === null && isNonNullType(type)) {\n      return; // Invalid: intentionally return no value.\n    } // Note: This does no further checking that this variable is correct.\n    // This assumes that this query has been validated and the variable\n    // usage here is of the correct type.\n\n\n    return variableValue;\n  }\n\n  if (isNonNullType(type)) {\n    if (valueNode.kind === Kind.NULL) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return valueFromAST(valueNode, type.ofType, variables);\n  }\n\n  if (valueNode.kind === Kind.NULL) {\n    // This is explicitly returning the value null.\n    return null;\n  }\n\n  if (isListType(type)) {\n    var itemType = type.ofType;\n\n    if (valueNode.kind === Kind.LIST) {\n      var coercedValues = [];\n\n      for (var _i2 = 0, _valueNode$values2 = valueNode.values; _i2 < _valueNode$values2.length; _i2++) {\n        var itemNode = _valueNode$values2[_i2];\n\n        if (isMissingVariable(itemNode, variables)) {\n          // If an array contains a missing variable, it is either coerced to\n          // null or if the item type is non-null, it considered invalid.\n          if (isNonNullType(itemType)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(null);\n        } else {\n          var itemValue = valueFromAST(itemNode, itemType, variables);\n\n          if (itemValue === undefined) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(itemValue);\n        }\n      }\n\n      return coercedValues;\n    }\n\n    var coercedValue = valueFromAST(valueNode, itemType, variables);\n\n    if (coercedValue === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return [coercedValue];\n  }\n\n  if (isInputObjectType(type)) {\n    if (valueNode.kind !== Kind.OBJECT) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    var coercedObj = Object.create(null);\n    var fieldNodes = keyMap(valueNode.fields, function (field) {\n      return field.name.value;\n    });\n\n    for (var _i4 = 0, _objectValues2 = objectValues(type.getFields()); _i4 < _objectValues2.length; _i4++) {\n      var field = _objectValues2[_i4];\n      var fieldNode = fieldNodes[field.name];\n\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\n        if (field.defaultValue !== undefined) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          return; // Invalid: intentionally return no value.\n        }\n\n        continue;\n      }\n\n      var fieldValue = valueFromAST(fieldNode.value, field.type, variables);\n\n      if (fieldValue === undefined) {\n        return; // Invalid: intentionally return no value.\n      }\n\n      coercedObj[field.name] = fieldValue;\n    }\n\n    return coercedObj;\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (isLeafType(type)) {\n    // Scalars and Enums fulfill parsing a literal value via parseLiteral().\n    // Invalid values represent a failure to parse correctly, in which case\n    // no value is returned.\n    var result;\n\n    try {\n      result = type.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    if (result === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return result;\n  } // istanbul ignore next (Not reachable. All possible input types have been considered)\n\n\n  false || invariant(0, 'Unexpected input type: ' + inspect(type));\n} // Returns true if the provided valueNode is a variable which is not defined\n// in the set of variables.\n\nfunction isMissingVariable(valueNode, variables) {\n  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined);\n}\n","import objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport keyValMap from \"../jsutils/keyValMap.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport { parseValue } from \"../language/parser.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { GraphQLDirective } from \"../type/directives.mjs\";\nimport { specifiedScalarTypes } from \"../type/scalars.mjs\";\nimport { introspectionTypes, TypeKind } from \"../type/introspection.mjs\";\nimport { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, assertNullableType, assertObjectType, assertInterfaceType } from \"../type/definition.mjs\";\nimport { valueFromAST } from \"./valueFromAST.mjs\";\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(0, \"Invalid or incomplete introspection result. Ensure that you are passing \\\"data\\\" property of introspection response and no \\\"errors\\\" was returned alongside: \".concat(inspect(introspection), \".\")); // Get the schema from the introspection result.\n\n  var schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  var typeMap = keyValMap(schemaIntrospection.types, function (typeIntrospection) {\n    return typeIntrospection.name;\n  }, function (typeIntrospection) {\n    return buildType(typeIntrospection);\n  }); // Include standard types only if they are used.\n\n  for (var _i2 = 0, _ref2 = [].concat(specifiedScalarTypes, introspectionTypes); _i2 < _ref2.length; _i2++) {\n    var stdType = _ref2[_i2];\n\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: objectValues(typeMap),\n    directives: directives,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    var typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(\"Unknown type reference: \".concat(inspect(typeRef), \".\"));\n    }\n\n    var type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure that a full introspection query is used in order to build a client schema.\"));\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type != null && type.name != null && type.kind != null) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    var typeStr = inspect(type);\n    throw new Error(\"Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: \".concat(typeStr, \".\"));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByUrl: scalarIntrospection.specifiedByUrl\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      var implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(\"Introspection result missing interfaces: \".concat(implementingIntrospectionStr, \".\"));\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(objectIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(interfaceIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      var unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(\"Introspection result missing possibleTypes: \".concat(unionIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: function types() {\n        return unionIntrospection.possibleTypes.map(getObjectType);\n      }\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      var enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(\"Introspection result missing enumValues: \".concat(enumIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      var inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(\"Introspection result missing inputFields: \".concat(inputObjectIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\"Introspection result missing fields: \".concat(inspect(typeIntrospection), \".\"));\n    }\n\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, buildField);\n  }\n\n  function buildField(fieldIntrospection) {\n    var type = getType(fieldIntrospection.type);\n\n    if (!isOutputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide output type for fields, but received: \".concat(typeStr, \".\"));\n    }\n\n    if (!fieldIntrospection.args) {\n      var fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(\"Introspection result missing field args: \".concat(fieldIntrospectionStr, \".\"));\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type: type,\n      args: buildInputValueDefMap(fieldIntrospection.args)\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getType(inputValueIntrospection.type);\n\n    if (!isInputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide input type for arguments, but received: \".concat(typeStr, \".\"));\n    }\n\n    var defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      var directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\"Introspection result missing directive args: \".concat(directiveIntrospectionStr, \".\"));\n    }\n\n    if (!directiveIntrospection.locations) {\n      var _directiveIntrospectionStr = inspect(directiveIntrospection);\n\n      throw new Error(\"Introspection result missing directive locations: \".concat(_directiveIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}\n"],"sourceRoot":""}