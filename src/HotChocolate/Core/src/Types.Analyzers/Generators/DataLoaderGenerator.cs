using System.Text;
using HotChocolate.Types.Analyzers.Inspectors;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using static HotChocolate.Types.Analyzers.StringConstants;
using static HotChocolate.Types.Analyzers.WellKnownTypes;

namespace HotChocolate.Types.Analyzers.Generators;

public class DataLoaderGenerator : ISyntaxGenerator
{
    public void Initialize(IncrementalGeneratorPostInitializationContext context)
    {
        context.AddSource(
            WellKnownFileNames.AttributesFile,
            """
            // <auto-generated/>
            #nullable enable

            namespace HotChocolate.Fetching
            {
                [global::System.AttributeUsage(
                    global::System.AttributeTargets.Method,
                    AllowMultiple = false)]
                public sealed class BatchDataLoaderAttribute : global::System.Attribute
                {
                    public BatchDataLoaderAttribute(string? name = null)
                    {
                        Name = name;
                    }

                    public string? Name { get; }

                    public bool Scoped { get; set; }

                    public bool IsInternal { get; set; }
                }
            }
            """);
    }

    public bool Consume(ISyntaxInfo syntaxInfo)
        => syntaxInfo is BatchDataLoaderInfo or ModuleInfo;

    public void Generate(
        SourceProductionContext context,
        Compilation compilation,
        IReadOnlyCollection<ISyntaxInfo> syntaxInfos)
    {
        var module =
            syntaxInfos.OfType<ModuleInfo>().FirstOrDefault() ??
            new ModuleInfo(
                compilation.AssemblyName is null
                    ? "AssemblyTypes"
                    : compilation.AssemblyName?.Split('.').Last() + "Types",
                ModuleOptions.Default);

        var dataLoaders = new List<string>();
        var sourceText = new StringBuilder();

        sourceText.AppendLine("// <auto-generated/>");
        sourceText.AppendLine("#nullable enable");
        sourceText.AppendLine("using System;");
        sourceText.AppendLine("using HotChocolate.Execution.Configuration;");
        sourceText.AppendLine();
        sourceText.AppendLine("namespace Microsoft.Extensions.DependencyInjection");
        sourceText.AppendLine("{");

        foreach (var syntaxInfo in syntaxInfos)
        {
            if (syntaxInfo is BatchDataLoaderInfo batchDataLoader)
            {
                var dataLoaderAttribute = batchDataLoader.MethodSymbol
                    .GetAttributes()
                    .First(
                        t => string.Equals(
                            t.AttributeClass?.Name,
                            "BatchDataLoaderAttribute",
                            StringComparison.Ordinal));

                var dataLoaderName = GetDataLoaderName(
                    batchDataLoader.MethodSymbol.Name,
                    dataLoaderAttribute);

                var isScoped = IsScoped(dataLoaderAttribute);
                var isPublic = IsPublic(dataLoaderAttribute);

                var keysIndex = -1;
                ITypeSymbol? keyType = null;
                var cancellationTokenIndex = -1;
                var serviceMap = new Dictionary<int, string>();

                for (var i = 0; i < batchDataLoader.MethodSymbol.Parameters.Length; i++)
                {
                    var argument = batchDataLoader.MethodSymbol.Parameters[i];
                    var argumentType = ToTypeName(argument.Type);

                    if (IsKeyArgument(argument.Type))
                    {
                        if (keysIndex != -1)
                        {
                            // report error
                            return;
                        }

                        keyType = ExtractKeyType(argument.Type);
                        keysIndex = i;
                    }
                    else if (IsCancellationToken(argumentType))
                    {
                        if (cancellationTokenIndex != -1)
                        {
                            // report error
                            return;
                        }

                        cancellationTokenIndex = i;
                    }
                    else
                    {
                        serviceMap[i] = argumentType;
                    }
                }

                if (keyType is null || keysIndex is -1)
                {
                    continue;
                }

                if (!IsReturnTypeDictionary(batchDataLoader.MethodSymbol.ReturnType, keyType))
                {
                    // error
                    continue;
                }

                var valueType = ExtractValueType(batchDataLoader.MethodSymbol.ReturnType);

                dataLoaders.Add(dataLoaderName);

                GenerateBatchDataLoader(
                    dataLoaderName,
                    isPublic,
                    isScoped,
                    batchDataLoader.MethodSymbol,
                    keyType,
                    valueType,
                    batchDataLoader.MethodSymbol.Parameters.Length,
                    keysIndex,
                    cancellationTokenIndex,
                    serviceMap,
                    sourceText);
            }
        }

        GenerateDataLoaderRegistrations(module, dataLoaders, sourceText);

        sourceText.AppendLine("}");

        context.AddSource(
            WellKnownFileNames.DataLoaderFile,
            SourceText.From(sourceText.ToString(), Encoding.UTF8));
    }

    private static void GenerateBatchDataLoader(
        string name,
        bool isPublic,
        bool isScoped,
        IMethodSymbol method,
        ITypeSymbol keyType,
        ITypeSymbol valueType,
        int parameterCount,
        int keyIndex,
        int cancelIndex,
        Dictionary<int, string> services,
        StringBuilder sourceText)
    {
        if (isPublic)
        {
            sourceText.Append("    public sealed class ");
        }
        else
        {
            sourceText.Append("    internal sealed class ");
        }

        sourceText.Append(name);
        sourceText.Append(" : global::GreenDonut.BatchDataLoader<");
        sourceText.Append("global::");
        sourceText.Append(ToTypeName(keyType));
        sourceText.Append(", ");
        sourceText.Append("global::");
        sourceText.Append(ToTypeName(valueType));
        sourceText.AppendLine(">");

        sourceText.AppendLine("    {");

        sourceText.AppendLine("        private readonly IServiceProvider _services;");
        sourceText.AppendLine();
        sourceText.AppendLine($"        public {name}(");
        sourceText.AppendLine("            IServiceProvider services,");
        sourceText.AppendLine("            global::GreenDonut.IBatchScheduler batchScheduler,");
        sourceText.AppendLine("            global::GreenDonut.DataLoaderOptions? options = null)");
        sourceText.AppendLine("            : base(batchScheduler, options)");
        sourceText.AppendLine("        {");
        sourceText.AppendLine("            _services = services ??");
        sourceText.AppendLine("                throw new ArgumentNullException(nameof(services));");
        sourceText.AppendLine("        }");
        sourceText.AppendLine();
        sourceText.Append($"        protected override async {WellKnownTypes.Task}<");
        sourceText.Append("global::System.Collections.Generic.IReadOnlyDictionary<");
        sourceText.Append("global::");
        sourceText.Append(ToTypeName(keyType));
        sourceText.Append(", global::");
        sourceText.Append(ToTypeName(valueType));
        sourceText.Append(">> ");
        sourceText.AppendLine("LoadBatchAsync(");
        sourceText.Append($"            global::{ReadOnlyList}<");
        sourceText.AppendLine($"global::{ToTypeName(keyType)}> keys,");
        sourceText.AppendLine($"            global::{WellKnownTypes.CancellationToken} ct)");
        sourceText.AppendLine("        {");

        if (isScoped)
        {
            sourceText.AppendLine("await using var scope = _services.CreateAsyncScope();");

            foreach (var item in services.OrderBy(t => t.Key))
            {
                sourceText.Append($"            var p{item.Key} = ");
                sourceText.Append("scope.ServiceProvider.GetRequiredService<");
                sourceText.Append(item.Value);
                sourceText.AppendLine(">();");
            }
        }
        else
        {
            foreach (var item in services.OrderBy(t => t.Key))
            {
                sourceText.Append($"            var p{item.Key} = _services.GetRequiredService<");
                sourceText.Append(item.Value);
                sourceText.AppendLine(">();");
            }
        }

        sourceText.Append("            return await global::");
        sourceText.Append(ToTypeName(method.ContainingType));
        sourceText.Append(".");
        sourceText.Append(method.Name);
        sourceText.Append("(");

        for (var i = 0; i < parameterCount; i++)
        {
            if (i > 0)
            {
                sourceText.Append(", ");
            }

            if (i == keyIndex)
            {
                sourceText.Append("keys");
            }
            else if (i == cancelIndex)
            {
                sourceText.Append("ct");
            }
            else
            {
                sourceText.Append("p");
                sourceText.Append(i);
            }
        }
        sourceText.AppendLine(").ConfigureAwait(false);");

        sourceText.AppendLine("        }");
        sourceText.AppendLine("    }");
    }

    private static void GenerateDataLoaderRegistrations(
        ModuleInfo module,
        List<string> dataLoaders,
        StringBuilder sourceText)
    {
        sourceText.Append(Indent)
            .Append("public static partial class ")
            .Append(module.ModuleName)
            .AppendLine("RequestExecutorBuilderExtensions");

        sourceText
            .Append(Indent)
            .AppendLine("{");

        sourceText
            .Append(Indent)
            .Append(Indent)
            .Append("static partial void RegisterGeneratedDataLoader(")
            .AppendLine("IRequestExecutorBuilder builder)");

        sourceText
            .Append(Indent)
            .Append(Indent)
            .AppendLine("{");

        foreach (var dataLoader in dataLoaders)
        {
            sourceText
                .Append(Indent)
                .Append(Indent)
                .Append(Indent)
                .Append("builder.AddDataLoader<")
                .Append(dataLoader)
                .AppendLine(">();");
        }

        sourceText
            .Append(Indent)
            .Append(Indent)
            .AppendLine("}");

        sourceText
            .Append(Indent)
            .AppendLine("}");
    }

    private static bool IsScoped(AttributeData attribute)
    {
        var scoped = attribute.NamedArguments.FirstOrDefault(
            t => t.Key.Equals("IsScoped", StringComparison.Ordinal));

        if (scoped.Value.Value is bool b)
        {
            return b;
        }

        return false;
    }

    private static bool IsPublic(AttributeData attribute)
    {
        var scoped = attribute.NamedArguments.FirstOrDefault(
            t => t.Key.Equals("IsInternal", StringComparison.Ordinal));

        if (scoped.Value.Value is bool b)
        {
            return !b;
        }

        return true;
    }

    private static string GetDataLoaderName(string name, AttributeData attribute)
    {
        if (attribute.ConstructorArguments.Length > 0 &&
            attribute.ConstructorArguments[0].Value is string s)
        {
            return s;
        }

        if (name.StartsWith("Get"))
        {
            name = name.Substring(3);
        }

        if (name.EndsWith("Async"))
        {
            name = name.Substring(0, name.Length - 5);
        }

        if (name.EndsWith("DataLoader"))
        {
            return name;
        }

        return name + "DataLoader";
    }

    private static bool IsKeyArgument(ITypeSymbol type)
    {
        if (type is INamedTypeSymbol { IsGenericType: true, TypeArguments.Length: 1 } namedType &&
            ReadOnlyList.Equals(ToTypeName(namedType), StringComparison.Ordinal))
        {
            return true;
        }

        return false;
    }

    private static ITypeSymbol ExtractKeyType(ITypeSymbol type)
    {
        if (type is INamedTypeSymbol { IsGenericType: true, TypeArguments.Length: 1 } namedType &&
            ReadOnlyList.Equals(ToTypeName(namedType), StringComparison.Ordinal))
        {
            return namedType.TypeArguments[0];
        }

        throw new InvalidOperationException();
    }

    private static bool IsCancellationToken(string typeName)
        => string.Equals(typeName, WellKnownTypes.CancellationToken);

    private static string ToTypeName(ITypeSymbol type)
        => $"{type.ContainingNamespace}.{type.Name}";

    private static bool IsReturnTypeDictionary(ITypeSymbol returnType, ITypeSymbol keyType)
    {
        if (returnType is INamedTypeSymbol { TypeArguments.Length: 1 } namedType)
        {
            var resultType = namedType.TypeArguments[0];

            if (IsReadOnlyDictionary(resultType) &&
                resultType is INamedTypeSymbol { TypeArguments.Length: 2 } dictionaryType &&
                dictionaryType.TypeArguments[0].Equals(keyType, SymbolEqualityComparer.Default))
            {
                return true;
            }
        }
        return false;
    }

    private static bool IsReadOnlyDictionary(ITypeSymbol type)
    {
        if (!ToTypeName(type).Equals(ReadOnlyDictionary, StringComparison.Ordinal))
        {
            foreach (var interfaceSymbol in type.Interfaces)
            {
                if (ToTypeName(interfaceSymbol).Equals(
                    ReadOnlyDictionary,
                    StringComparison.Ordinal))
                {
                    return true;
                }
            }

            return false;
        }

        return true;
    }

    private static ITypeSymbol ExtractValueType(ITypeSymbol returnType)
    {
        if (returnType is INamedTypeSymbol { TypeArguments.Length: 1 } namedType &&
            namedType.TypeArguments[0] is INamedTypeSymbol { TypeArguments.Length: 2 } dict)
        {
            return dict.TypeArguments[1];
        }

        throw new InvalidOperationException();
    }
}
