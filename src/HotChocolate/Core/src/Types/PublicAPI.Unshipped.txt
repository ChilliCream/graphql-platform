abstract HotChocolate.Internal.CustomParameterExpressionBuilder.Build(System.Reflection.ParameterInfo! parameter, System.Linq.Expressions.Expression! context) -> System.Linq.Expressions.Expression!
abstract HotChocolate.Internal.CustomParameterExpressionBuilder.CanHandle(System.Reflection.ParameterInfo! parameter) -> bool
abstract HotChocolate.Types.FieldBase<TDefinition>.RuntimeType.get -> System.Type!
abstract HotChocolate.Types.ScalarType.ParseLiteral(HotChocolate.Language.IValueNode! valueSyntax) -> object?
const HotChocolate.Types.Pagination.PagingDefaults.InferConnectionNameFromField = true -> bool
const HotChocolate.Types.Pagination.PagingDefaults.RequirePagingBoundaries = false -> bool
HotChocolate.Configuration.DelegateTypeInitializationInterceptor<T>.OnValidateType(HotChocolate.Configuration.ITypeSystemObjectContext! validationContext, HotChocolate.Types.Descriptors.Definitions.DefinitionBase? definition, System.Collections.Generic.IDictionary<string!, object?>! contextData) -> void
HotChocolate.Configuration.DelegateTypeInitializationInterceptor<T>.RegisterMoreTypes(System.Collections.Generic.IReadOnlyCollection<HotChocolate.Configuration.ITypeDiscoveryContext!>! discoveryContexts) -> System.Collections.Generic.IEnumerable<HotChocolate.Types.Descriptors.ITypeReference!>!
HotChocolate.Configuration.DelegateTypeInterceptor.OnValidateType(HotChocolate.Configuration.ITypeSystemObjectContext! validationContext, HotChocolate.Types.Descriptors.Definitions.DefinitionBase? definition, System.Collections.Generic.IDictionary<string!, object?>! contextData) -> void
HotChocolate.Configuration.DelegateTypeInterceptor.RegisterMoreTypes(System.Collections.Generic.IReadOnlyCollection<HotChocolate.Configuration.ITypeDiscoveryContext!>! discoveryContexts) -> System.Collections.Generic.IEnumerable<HotChocolate.Types.Descriptors.ITypeReference!>!
HotChocolate.Configuration.ITypeCompletionContext.GetNamedTypeReference(HotChocolate.Types.Descriptors.ITypeReference! typeRef) -> HotChocolate.Types.Descriptors.ITypeReference!
HotChocolate.Configuration.ITypeCompletionContext.TryGetType<T>(HotChocolate.Types.Descriptors.ITypeReference! typeRef, out T? type) -> bool
HotChocolate.Configuration.ITypeInitializationInterceptor.OnValidateType(HotChocolate.Configuration.ITypeSystemObjectContext! validationContext, HotChocolate.Types.Descriptors.Definitions.DefinitionBase? definition, System.Collections.Generic.IDictionary<string!, object?>! contextData) -> void
HotChocolate.Configuration.ITypeInitializationInterceptor.RegisterMoreTypes(System.Collections.Generic.IReadOnlyCollection<HotChocolate.Configuration.ITypeDiscoveryContext!>! discoveryContexts) -> System.Collections.Generic.IEnumerable<HotChocolate.Types.Descriptors.ITypeReference!>!
HotChocolate.Configuration.ReadOnlySchemaOptions.ReadOnlySchemaOptions(HotChocolate.IReadOnlySchemaOptions! options) -> void
HotChocolate.Configuration.ReadOnlySchemaOptions.StrictRuntimeTypeValidation.get -> bool
HotChocolate.Configuration.ReadOnlySchemaOptions.ValidatePipelineOrder.get -> bool
HotChocolate.Configuration.Validation.InterfaceTypeValidationRule.Validate(System.Collections.Generic.IReadOnlyList<HotChocolate.Types.ITypeSystemObject!>! typeSystemObjects, HotChocolate.IReadOnlySchemaOptions! options, System.Collections.Generic.ICollection<HotChocolate.ISchemaError!>! errors) -> void
HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.Argument = 0 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.CancellationToken = 11 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.Context = 10 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.Custom = 16 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.DocumentSyntax = 6 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.EventMessage = 15 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.Field = 5 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.FieldSyntax = 8 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.GlobalState = 12 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.LocalState = 14 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.ObjectType = 4 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.OperationDefinitionSyntax = 7 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.Schema = 3 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.ScopedState = 13 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.Selection = 9 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.Service = 2 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.ArgumentKind.Source = 1 -> HotChocolate.Internal.ArgumentKind
HotChocolate.Internal.CustomParameterExpressionBuilder
HotChocolate.Internal.CustomParameterExpressionBuilder.CustomParameterExpressionBuilder() -> void
HotChocolate.Internal.CustomParameterExpressionBuilder<TArg>
HotChocolate.Internal.CustomParameterExpressionBuilder<TArg>.CustomParameterExpressionBuilder(System.Linq.Expressions.Expression<System.Func<HotChocolate.Resolvers.IResolverContext!, TArg>!>! expression) -> void
HotChocolate.Internal.CustomParameterExpressionBuilder<TArg>.CustomParameterExpressionBuilder(System.Linq.Expressions.Expression<System.Func<HotChocolate.Resolvers.IResolverContext!, TArg>!>! expression, System.Func<System.Reflection.ParameterInfo!, bool>! canHandle) -> void
HotChocolate.Internal.CustomServiceParameterExpressionBuilder<TService>
HotChocolate.Internal.CustomServiceParameterExpressionBuilder<TService>.CustomServiceParameterExpressionBuilder() -> void
HotChocolate.Internal.FieldInitHelper
HotChocolate.Internal.IParameterExpressionBuilder
HotChocolate.Internal.IParameterExpressionBuilder.Build(System.Reflection.ParameterInfo! parameter, System.Linq.Expressions.Expression! context) -> System.Linq.Expressions.Expression!
HotChocolate.Internal.IParameterExpressionBuilder.CanHandle(System.Reflection.ParameterInfo! parameter) -> bool
HotChocolate.Internal.IParameterExpressionBuilder.IsPure.get -> bool
HotChocolate.Internal.IParameterExpressionBuilder.Kind.get -> HotChocolate.Internal.ArgumentKind
HotChocolate.IReadOnlySchemaOptions
HotChocolate.IReadOnlySchemaOptions.AllowInlining.get -> bool
HotChocolate.IReadOnlySchemaOptions.DefaultBindingBehavior.get -> HotChocolate.Types.BindingBehavior
HotChocolate.IReadOnlySchemaOptions.DefaultDirectiveVisibility.get -> HotChocolate.Configuration.DirectiveVisibility
HotChocolate.IReadOnlySchemaOptions.DefaultResolverStrategy.get -> HotChocolate.Execution.ExecutionStrategy
HotChocolate.IReadOnlySchemaOptions.EnableDirectiveIntrospection.get -> bool
HotChocolate.IReadOnlySchemaOptions.FieldMiddleware.get -> HotChocolate.Configuration.FieldMiddlewareApplication
HotChocolate.IReadOnlySchemaOptions.MutationTypeName.get -> string?
HotChocolate.IReadOnlySchemaOptions.PreserveSyntaxNodes.get -> bool
HotChocolate.IReadOnlySchemaOptions.QueryTypeName.get -> string?
HotChocolate.IReadOnlySchemaOptions.RemoveUnreachableTypes.get -> bool
HotChocolate.IReadOnlySchemaOptions.ResolveXmlDocumentationFileName.get -> System.Func<System.Reflection.Assembly!, string!>?
HotChocolate.IReadOnlySchemaOptions.SortFieldsByName.get -> bool
HotChocolate.IReadOnlySchemaOptions.StrictRuntimeTypeValidation.get -> bool
HotChocolate.IReadOnlySchemaOptions.StrictValidation.get -> bool
HotChocolate.IReadOnlySchemaOptions.SubscriptionTypeName.get -> string?
HotChocolate.IReadOnlySchemaOptions.UseXmlDocumentation.get -> bool
HotChocolate.IReadOnlySchemaOptions.ValidatePipelineOrder.get -> bool
HotChocolate.ISchemaBuilder.AddRootType(HotChocolate.Types.ObjectType! rootType, HotChocolate.Language.OperationType operation) -> HotChocolate.ISchemaBuilder!
HotChocolate.ISchemaBuilder.AddRootType(System.Type! rootType, HotChocolate.Language.OperationType operation) -> HotChocolate.ISchemaBuilder!
HotChocolate.ISchemaBuilder.AddType(HotChocolate.Types.INamedType! namedType) -> HotChocolate.ISchemaBuilder!
HotChocolate.ISchemaBuilder.AddType(HotChocolate.Types.INamedTypeExtension! typeExtension) -> HotChocolate.ISchemaBuilder!
HotChocolate.ISchemaBuilder.BindRuntimeType(System.Type! runtimeType, System.Type! schemaType) -> HotChocolate.ISchemaBuilder!
HotChocolate.ISchemaBuilder.ContextData.get -> System.Collections.Generic.IDictionary<string!, object?>!
HotChocolate.ISchemaBuilder.Create(HotChocolate.Types.Descriptors.IDescriptorContext! context) -> HotChocolate.ISchema!
HotChocolate.ISchemaBuilder.CreateContext() -> HotChocolate.Types.Descriptors.IDescriptorContext!
HotChocolate.ISchemaBuilder.ModifyOptions(System.Action<HotChocolate.ISchemaOptions!>! configure) -> HotChocolate.ISchemaBuilder!
HotChocolate.ISchemaBuilder.SetOptions(HotChocolate.IReadOnlySchemaOptions! options) -> HotChocolate.ISchemaBuilder!
HotChocolate.ISchemaOptions
HotChocolate.ISchemaOptions.AllowInlining.get -> bool
HotChocolate.ISchemaOptions.AllowInlining.set -> void
HotChocolate.ISchemaOptions.DefaultBindingBehavior.get -> HotChocolate.Types.BindingBehavior
HotChocolate.ISchemaOptions.DefaultBindingBehavior.set -> void
HotChocolate.ISchemaOptions.DefaultDirectiveVisibility.get -> HotChocolate.Configuration.DirectiveVisibility
HotChocolate.ISchemaOptions.DefaultDirectiveVisibility.set -> void
HotChocolate.ISchemaOptions.DefaultResolverStrategy.get -> HotChocolate.Execution.ExecutionStrategy
HotChocolate.ISchemaOptions.DefaultResolverStrategy.set -> void
HotChocolate.ISchemaOptions.EnableDirectiveIntrospection.get -> bool
HotChocolate.ISchemaOptions.EnableDirectiveIntrospection.set -> void
HotChocolate.ISchemaOptions.FieldMiddleware.get -> HotChocolate.Configuration.FieldMiddlewareApplication
HotChocolate.ISchemaOptions.FieldMiddleware.set -> void
HotChocolate.ISchemaOptions.MutationTypeName.get -> string?
HotChocolate.ISchemaOptions.MutationTypeName.set -> void
HotChocolate.ISchemaOptions.PreserveSyntaxNodes.get -> bool
HotChocolate.ISchemaOptions.PreserveSyntaxNodes.set -> void
HotChocolate.ISchemaOptions.QueryTypeName.get -> string?
HotChocolate.ISchemaOptions.QueryTypeName.set -> void
HotChocolate.ISchemaOptions.RemoveUnreachableTypes.get -> bool
HotChocolate.ISchemaOptions.RemoveUnreachableTypes.set -> void
HotChocolate.ISchemaOptions.ResolveXmlDocumentationFileName.get -> System.Func<System.Reflection.Assembly!, string!>?
HotChocolate.ISchemaOptions.ResolveXmlDocumentationFileName.set -> void
HotChocolate.ISchemaOptions.SortFieldsByName.get -> bool
HotChocolate.ISchemaOptions.SortFieldsByName.set -> void
HotChocolate.ISchemaOptions.StrictRuntimeTypeValidation.get -> bool
HotChocolate.ISchemaOptions.StrictRuntimeTypeValidation.set -> void
HotChocolate.ISchemaOptions.StrictValidation.get -> bool
HotChocolate.ISchemaOptions.StrictValidation.set -> void
HotChocolate.ISchemaOptions.SubscriptionTypeName.get -> string?
HotChocolate.ISchemaOptions.SubscriptionTypeName.set -> void
HotChocolate.ISchemaOptions.UseXmlDocumentation.get -> bool
HotChocolate.ISchemaOptions.UseXmlDocumentation.set -> void
HotChocolate.ISchemaOptions.ValidatePipelineOrder.get -> bool
HotChocolate.ISchemaOptions.ValidatePipelineOrder.set -> void
HotChocolate.RelaySchemaBuilderExtensions
HotChocolate.Resolvers.FieldResolver.FieldResolver(HotChocolate.NameString typeName, HotChocolate.NameString fieldName, HotChocolate.Resolvers.FieldResolverDelegate! resolver, HotChocolate.Resolvers.PureFieldDelegate? pureResolver = null) -> void
HotChocolate.Resolvers.FieldResolver.FieldResolver(HotChocolate.Resolvers.FieldReference! fieldReference, HotChocolate.Resolvers.FieldResolverDelegate! resolver, HotChocolate.Resolvers.PureFieldDelegate? pureResolver = null) -> void
HotChocolate.Resolvers.FieldResolver.PureResolver.get -> HotChocolate.Resolvers.PureFieldDelegate?
HotChocolate.Resolvers.FieldResolverDelegates
HotChocolate.Resolvers.FieldResolverDelegates.FieldResolverDelegates() -> void
HotChocolate.Resolvers.FieldResolverDelegates.FieldResolverDelegates(HotChocolate.Resolvers.FieldResolverDelegate? resolver = null, HotChocolate.Resolvers.PureFieldDelegate? pureResolver = null) -> void
HotChocolate.Resolvers.FieldResolverDelegates.HasResolvers.get -> bool
HotChocolate.Resolvers.FieldResolverDelegates.PureResolver.get -> HotChocolate.Resolvers.PureFieldDelegate?
HotChocolate.Resolvers.FieldResolverDelegates.Resolver.get -> HotChocolate.Resolvers.FieldResolverDelegate?
HotChocolate.Resolvers.IFieldSelection.TypeKind.get -> HotChocolate.Types.TypeKind
HotChocolate.Resolvers.IPureResolverContext
HotChocolate.Resolvers.IPureResolverContext.ArgumentKind(HotChocolate.NameString name) -> HotChocolate.Types.ValueKind
HotChocolate.Resolvers.IPureResolverContext.ArgumentLiteral<TValueNode>(HotChocolate.NameString name) -> TValueNode
HotChocolate.Resolvers.IPureResolverContext.ArgumentOptional<T>(HotChocolate.NameString name) -> HotChocolate.Optional<T>
HotChocolate.Resolvers.IPureResolverContext.ArgumentValue<T>(HotChocolate.NameString name) -> T
HotChocolate.Resolvers.IPureResolverContext.ObjectType.get -> HotChocolate.Types.IObjectType!
HotChocolate.Resolvers.IPureResolverContext.Parent<T>() -> T
HotChocolate.Resolvers.IPureResolverContext.Resolver<T>() -> T
HotChocolate.Resolvers.IPureResolverContext.RootType.get -> HotChocolate.Types.IObjectType!
HotChocolate.Resolvers.IPureResolverContext.Schema.get -> HotChocolate.ISchema!
HotChocolate.Resolvers.IPureResolverContext.Selection.get -> HotChocolate.Resolvers.IFieldSelection!
HotChocolate.Resolvers.IPureResolverContext.Service<T>() -> T
HotChocolate.Resolvers.IPureResolverContext.Variables.get -> HotChocolate.Execution.IVariableValueCollection!
HotChocolate.Resolvers.IResolverCompiler
HotChocolate.Resolvers.IResolverCompiler.CompileResolve(System.Linq.Expressions.LambdaExpression! lambda, System.Type! sourceType, System.Type? resolverType = null) -> HotChocolate.Resolvers.FieldResolverDelegates
HotChocolate.Resolvers.IResolverCompiler.CompileResolve(System.Reflection.MemberInfo! member, System.Type? sourceType = null, System.Type? resolverType = null, HotChocolate.Internal.IParameterExpressionBuilder![]? parameterExpressionBuilders = null) -> HotChocolate.Resolvers.FieldResolverDelegates
HotChocolate.Resolvers.IResolverCompiler.CompileResolve<TResolver>(System.Linq.Expressions.Expression<System.Func<TResolver, object?>!>! propertyOrMethod, System.Type? sourceType = null, HotChocolate.Internal.IParameterExpressionBuilder![]? parameterExpressionBuilders = null) -> HotChocolate.Resolvers.FieldResolverDelegates
HotChocolate.Resolvers.IResolverCompiler.CompileSubscribe(System.Reflection.MemberInfo! member, System.Type? sourceType = null, System.Type? resolverType = null) -> HotChocolate.Resolvers.SubscribeResolverDelegate!
HotChocolate.Resolvers.IResolverCompiler.GetArgumentParameters(System.Reflection.ParameterInfo![]! parameters, HotChocolate.Internal.IParameterExpressionBuilder![]? parameterExpressionBuilders = null) -> System.Collections.Generic.IEnumerable<System.Reflection.ParameterInfo!>!
HotChocolate.Resolvers.IResolverContext.ReportError(System.Exception! exception, System.Action<HotChocolate.IErrorBuilder!>? configure = null) -> void
HotChocolate.Resolvers.ResultConverterDelegate
HotChocolate.SchemaBuilder.AddRootType(HotChocolate.Types.ObjectType! rootType, HotChocolate.Language.OperationType operation) -> HotChocolate.ISchemaBuilder!
HotChocolate.SchemaBuilder.AddRootType(System.Type! rootType, HotChocolate.Language.OperationType operation) -> HotChocolate.ISchemaBuilder!
HotChocolate.SchemaBuilder.AddType(HotChocolate.Types.INamedType! namedType) -> HotChocolate.ISchemaBuilder!
HotChocolate.SchemaBuilder.AddType(HotChocolate.Types.INamedTypeExtension! typeExtension) -> HotChocolate.ISchemaBuilder!
HotChocolate.SchemaBuilder.BindClrType(System.Type! clrType, System.Type! schemaType) -> HotChocolate.ISchemaBuilder!
HotChocolate.SchemaBuilder.BindRuntimeType(System.Type! runtimeType, System.Type! schemaType) -> HotChocolate.ISchemaBuilder!
HotChocolate.SchemaBuilder.ContextData.get -> System.Collections.Generic.IDictionary<string!, object?>!
HotChocolate.SchemaBuilder.ModifyOptions(System.Action<HotChocolate.ISchemaOptions!>! configure) -> HotChocolate.ISchemaBuilder!
HotChocolate.SchemaBuilder.SetOptions(HotChocolate.IReadOnlySchemaOptions! options) -> HotChocolate.ISchemaBuilder!
HotChocolate.SchemaOptions
HotChocolate.SchemaOptions.AllowInlining.get -> bool
HotChocolate.SchemaOptions.AllowInlining.set -> void
HotChocolate.SchemaOptions.DefaultBindingBehavior.get -> HotChocolate.Types.BindingBehavior
HotChocolate.SchemaOptions.DefaultBindingBehavior.set -> void
HotChocolate.SchemaOptions.DefaultDirectiveVisibility.get -> HotChocolate.Configuration.DirectiveVisibility
HotChocolate.SchemaOptions.DefaultDirectiveVisibility.set -> void
HotChocolate.SchemaOptions.DefaultResolverStrategy.get -> HotChocolate.Execution.ExecutionStrategy
HotChocolate.SchemaOptions.DefaultResolverStrategy.set -> void
HotChocolate.SchemaOptions.EnableDirectiveIntrospection.get -> bool
HotChocolate.SchemaOptions.EnableDirectiveIntrospection.set -> void
HotChocolate.SchemaOptions.FieldMiddleware.get -> HotChocolate.Configuration.FieldMiddlewareApplication
HotChocolate.SchemaOptions.FieldMiddleware.set -> void
HotChocolate.SchemaOptions.MutationTypeName.get -> string?
HotChocolate.SchemaOptions.MutationTypeName.set -> void
HotChocolate.SchemaOptions.PreserveSyntaxNodes.get -> bool
HotChocolate.SchemaOptions.PreserveSyntaxNodes.set -> void
HotChocolate.SchemaOptions.QueryTypeName.get -> string?
HotChocolate.SchemaOptions.QueryTypeName.set -> void
HotChocolate.SchemaOptions.RemoveUnreachableTypes.get -> bool
HotChocolate.SchemaOptions.RemoveUnreachableTypes.set -> void
HotChocolate.SchemaOptions.ResolveXmlDocumentationFileName.get -> System.Func<System.Reflection.Assembly!, string!>?
HotChocolate.SchemaOptions.ResolveXmlDocumentationFileName.set -> void
HotChocolate.SchemaOptions.SchemaOptions() -> void
HotChocolate.SchemaOptions.SortFieldsByName.get -> bool
HotChocolate.SchemaOptions.SortFieldsByName.set -> void
HotChocolate.SchemaOptions.StrictRuntimeTypeValidation.get -> bool
HotChocolate.SchemaOptions.StrictRuntimeTypeValidation.set -> void
HotChocolate.SchemaOptions.StrictValidation.get -> bool
HotChocolate.SchemaOptions.StrictValidation.set -> void
HotChocolate.SchemaOptions.SubscriptionTypeName.get -> string?
HotChocolate.SchemaOptions.SubscriptionTypeName.set -> void
HotChocolate.SchemaOptions.UseXmlDocumentation.get -> bool
HotChocolate.SchemaOptions.UseXmlDocumentation.set -> void
HotChocolate.SchemaOptions.ValidatePipelineOrder.get -> bool
HotChocolate.SchemaOptions.ValidatePipelineOrder.set -> void
HotChocolate.Types.ApplyConfigurationOn.Completion = 2 -> HotChocolate.Types.ApplyConfigurationOn
HotChocolate.Types.ApplyConfigurationOn.Create = 0 -> HotChocolate.Types.ApplyConfigurationOn
HotChocolate.Types.ApplyConfigurationOn.Naming = 1 -> HotChocolate.Types.ApplyConfigurationOn
HotChocolate.Types.Argument.Argument(HotChocolate.Types.Descriptors.Definitions.ArgumentDefinition! definition, int index) -> void
HotChocolate.Types.Argument.DeclaringMember.get -> HotChocolate.Types.ITypeSystemMember!
HotChocolate.Types.Argument.Type.get -> HotChocolate.Types.IInputType!
HotChocolate.Types.Descriptors.DefaultTypeInspector.GetArgumentTypeRef(System.Reflection.ParameterInfo! parameter, string? scope = null, bool ignoreAttributes = false) -> HotChocolate.Types.Descriptors.ITypeReference!
HotChocolate.Types.Descriptors.Definitions.ArgumentDefinition.ArgumentDefinition(HotChocolate.NameString name, string? description = null, HotChocolate.Types.Descriptors.ITypeReference? type = null, HotChocolate.Language.IValueNode? defaultValue = null, object? runtimeDefaultValue = null) -> void
HotChocolate.Types.Descriptors.Definitions.ArgumentDefinition.RuntimeDefaultValue.get -> object?
HotChocolate.Types.Descriptors.Definitions.ArgumentDefinition.RuntimeDefaultValue.set -> void
HotChocolate.Types.Descriptors.Definitions.CompleteConfiguration
HotChocolate.Types.Descriptors.Definitions.CompleteConfiguration.AddDependency(HotChocolate.Types.Descriptors.Definitions.TypeDependency! dependency) -> void
HotChocolate.Types.Descriptors.Definitions.CompleteConfiguration.CompleteConfiguration(System.Action<HotChocolate.Configuration.ITypeCompletionContext!, HotChocolate.Types.Descriptors.Definitions.IDefinition!>! configure, HotChocolate.Types.Descriptors.Definitions.IDefinition! owner, HotChocolate.Types.ApplyConfigurationOn on, HotChocolate.Types.Descriptors.ITypeReference? typeReference = null, HotChocolate.Types.Descriptors.Definitions.TypeDependencyKind kind = HotChocolate.Types.Descriptors.Definitions.TypeDependencyKind.Default) -> void
HotChocolate.Types.Descriptors.Definitions.CompleteConfiguration.CompleteConfiguration(System.Action<HotChocolate.Configuration.ITypeCompletionContext!, HotChocolate.Types.Descriptors.Definitions.IDefinition!>! configure, HotChocolate.Types.Descriptors.Definitions.IDefinition! owner, HotChocolate.Types.ApplyConfigurationOn on, System.Collections.Generic.IEnumerable<HotChocolate.Types.Descriptors.Definitions.TypeDependency!>! dependencies) -> void
HotChocolate.Types.Descriptors.Definitions.CompleteConfiguration.Configure(HotChocolate.Configuration.ITypeCompletionContext! context) -> void
HotChocolate.Types.Descriptors.Definitions.CompleteConfiguration.Copy(HotChocolate.Types.Descriptors.Definitions.DefinitionBase! newOwner) -> HotChocolate.Types.Descriptors.Definitions.ITypeSystemMemberConfiguration!
HotChocolate.Types.Descriptors.Definitions.CompleteConfiguration.Dependencies.get -> System.Collections.Generic.IReadOnlyList<HotChocolate.Types.Descriptors.Definitions.TypeDependency!>!
HotChocolate.Types.Descriptors.Definitions.CompleteConfiguration.On.get -> HotChocolate.Types.ApplyConfigurationOn
HotChocolate.Types.Descriptors.Definitions.CompleteConfiguration.Owner.get -> HotChocolate.Types.Descriptors.Definitions.IDefinition!
HotChocolate.Types.Descriptors.Definitions.CompleteConfiguration<TDefinition>
HotChocolate.Types.Descriptors.Definitions.CompleteConfiguration<TDefinition>.CompleteConfiguration(System.Action<HotChocolate.Configuration.ITypeCompletionContext!, TDefinition>! configure, TDefinition owner, HotChocolate.Types.ApplyConfigurationOn on, HotChocolate.Types.Descriptors.ITypeReference? typeReference = null, HotChocolate.Types.Descriptors.Definitions.TypeDependencyKind kind = HotChocolate.Types.Descriptors.Definitions.TypeDependencyKind.Default) -> void
HotChocolate.Types.Descriptors.Definitions.CompleteConfiguration<TDefinition>.CompleteConfiguration(System.Action<HotChocolate.Configuration.ITypeCompletionContext!, TDefinition>! configure, TDefinition owner, HotChocolate.Types.ApplyConfigurationOn on, System.Collections.Generic.IEnumerable<HotChocolate.Types.Descriptors.Definitions.TypeDependency!>! dependencies) -> void
HotChocolate.Types.Descriptors.Definitions.CreateConfiguration
HotChocolate.Types.Descriptors.Definitions.CreateConfiguration.AddDependency(HotChocolate.Types.Descriptors.Definitions.TypeDependency! dependency) -> void
HotChocolate.Types.Descriptors.Definitions.CreateConfiguration.Configure(HotChocolate.Types.Descriptors.IDescriptorContext! context) -> void
HotChocolate.Types.Descriptors.Definitions.CreateConfiguration.Copy(HotChocolate.Types.Descriptors.Definitions.DefinitionBase! newOwner) -> HotChocolate.Types.Descriptors.Definitions.ITypeSystemMemberConfiguration!
HotChocolate.Types.Descriptors.Definitions.CreateConfiguration.CreateConfiguration(System.Action<HotChocolate.Types.Descriptors.IDescriptorContext!, HotChocolate.Types.Descriptors.Definitions.IDefinition!>! configure, HotChocolate.Types.Descriptors.Definitions.IDefinition! owner) -> void
HotChocolate.Types.Descriptors.Definitions.CreateConfiguration.Dependencies.get -> System.Collections.Generic.IReadOnlyList<HotChocolate.Types.Descriptors.Definitions.TypeDependency!>!
HotChocolate.Types.Descriptors.Definitions.CreateConfiguration.On.get -> HotChocolate.Types.ApplyConfigurationOn
HotChocolate.Types.Descriptors.Definitions.CreateConfiguration.Owner.get -> HotChocolate.Types.Descriptors.Definitions.IDefinition!
HotChocolate.Types.Descriptors.Definitions.DefinitionBase.BindTo.get -> string?
HotChocolate.Types.Descriptors.Definitions.DefinitionBase.BindTo.set -> void
HotChocolate.Types.Descriptors.Definitions.DefinitionBase.Configurations.get -> System.Collections.Generic.IList<HotChocolate.Types.Descriptors.Definitions.ITypeSystemMemberConfiguration!>!
HotChocolate.Types.Descriptors.Definitions.DefinitionBase.HasConfigurations.get -> bool
HotChocolate.Types.Descriptors.Definitions.DefinitionBase.HasDependencies.get -> bool
HotChocolate.Types.Descriptors.Definitions.DirectiveArgumentDefinition.DirectiveArgumentDefinition(HotChocolate.NameString name, string? description = null, HotChocolate.Types.Descriptors.ITypeReference? type = null, HotChocolate.Language.IValueNode? defaultValue = null, object? runtimeDefaultValue = null) -> void
HotChocolate.Types.Descriptors.Definitions.DirectiveTypeDefinition.DirectiveTypeDefinition(HotChocolate.NameString name, string? description = null, System.Type? runtimeType = null, bool isRepeatable = false) -> void
HotChocolate.Types.Descriptors.Definitions.DirectiveTypeDefinition.HasArguments.get -> bool
HotChocolate.Types.Descriptors.Definitions.EnumTypeDefinition.EnumTypeDefinition(HotChocolate.NameString name, string? description = null, System.Type? runtimeType = null) -> void
HotChocolate.Types.Descriptors.Definitions.EnumValueDefinition.EnumValueDefinition(HotChocolate.NameString name, string? description = null, object? runtimeValue = null) -> void
HotChocolate.Types.Descriptors.Definitions.EnumValueDefinition.Ignore.get -> bool
HotChocolate.Types.Descriptors.Definitions.EnumValueDefinition.Ignore.set -> void
HotChocolate.Types.Descriptors.Definitions.EnumValueDefinition.RuntimeValue.get -> object?
HotChocolate.Types.Descriptors.Definitions.EnumValueDefinition.RuntimeValue.set -> void
HotChocolate.Types.Descriptors.Definitions.FieldDefinitionBase.HasDirectives.get -> bool
HotChocolate.Types.Descriptors.Definitions.FieldMiddlewareDefinition
HotChocolate.Types.Descriptors.Definitions.FieldMiddlewareDefinition.FieldMiddlewareDefinition(HotChocolate.Resolvers.FieldMiddleware! middleware, bool isRepeatable = true, string? key = null) -> void
HotChocolate.Types.Descriptors.Definitions.FieldMiddlewareDefinition.IsRepeatable.get -> bool
HotChocolate.Types.Descriptors.Definitions.FieldMiddlewareDefinition.Key.get -> string?
HotChocolate.Types.Descriptors.Definitions.FieldMiddlewareDefinition.Middleware.get -> HotChocolate.Resolvers.FieldMiddleware!
HotChocolate.Types.Descriptors.Definitions.IBindableList<T>.Count.get -> int
HotChocolate.Types.Descriptors.Definitions.IBindableList<T>.this[int index].get -> T
HotChocolate.Types.Descriptors.Definitions.IBindableList<T>.this[int index].set -> void
HotChocolate.Types.Descriptors.Definitions.IDefinition
HotChocolate.Types.Descriptors.Definitions.IDefinition.AttributesAreApplied.get -> bool
HotChocolate.Types.Descriptors.Definitions.IDefinition.AttributesAreApplied.set -> void
HotChocolate.Types.Descriptors.Definitions.IDefinition.BindTo.get -> string?
HotChocolate.Types.Descriptors.Definitions.IDefinition.BindTo.set -> void
HotChocolate.Types.Descriptors.Definitions.IDefinition.Configurations.get -> System.Collections.Generic.IList<HotChocolate.Types.Descriptors.Definitions.ITypeSystemMemberConfiguration!>!
HotChocolate.Types.Descriptors.Definitions.IDefinition.ContextData.get -> HotChocolate.ExtensionData!
HotChocolate.Types.Descriptors.Definitions.IDefinition.Dependencies.get -> System.Collections.Generic.IList<HotChocolate.Types.Descriptors.Definitions.TypeDependency!>!
HotChocolate.Types.Descriptors.Definitions.IDefinition.Description.get -> string?
HotChocolate.Types.Descriptors.Definitions.IDefinition.Description.set -> void
HotChocolate.Types.Descriptors.Definitions.IDefinition.HasConfigurations.get -> bool
HotChocolate.Types.Descriptors.Definitions.IDefinition.HasDependencies.get -> bool
HotChocolate.Types.Descriptors.Definitions.IDefinition.Name.get -> HotChocolate.NameString
HotChocolate.Types.Descriptors.Definitions.IDefinition.Name.set -> void
HotChocolate.Types.Descriptors.Definitions.IMiddlewareDefinition
HotChocolate.Types.Descriptors.Definitions.IMiddlewareDefinition.IsRepeatable.get -> bool
HotChocolate.Types.Descriptors.Definitions.IMiddlewareDefinition.Key.get -> string?
HotChocolate.Types.Descriptors.Definitions.InputFieldDefinition.InputFieldDefinition(HotChocolate.NameString name, string? description = null, HotChocolate.Types.Descriptors.ITypeReference? type = null, HotChocolate.Language.IValueNode? defaultValue = null, object? runtimeDefaultValue = null) -> void
HotChocolate.Types.Descriptors.Definitions.InputObjectTypeDefinition.CopyTo(HotChocolate.Types.Descriptors.Definitions.InputObjectTypeDefinition! target) -> void
HotChocolate.Types.Descriptors.Definitions.InputObjectTypeDefinition.CreateInstance.get -> System.Func<object?[]!, object!>?
HotChocolate.Types.Descriptors.Definitions.InputObjectTypeDefinition.CreateInstance.set -> void
HotChocolate.Types.Descriptors.Definitions.InputObjectTypeDefinition.GetFieldData.get -> System.Action<object!, object?[]!>?
HotChocolate.Types.Descriptors.Definitions.InputObjectTypeDefinition.GetFieldData.set -> void
HotChocolate.Types.Descriptors.Definitions.InputObjectTypeDefinition.InputObjectTypeDefinition(HotChocolate.NameString name, string? description = null, System.Type? runtimeType = null) -> void
HotChocolate.Types.Descriptors.Definitions.InputObjectTypeDefinition.MergeInto(HotChocolate.Types.Descriptors.Definitions.InputObjectTypeDefinition! target) -> void
HotChocolate.Types.Descriptors.Definitions.InterfaceFieldDefinition.InterfaceFieldDefinition(HotChocolate.NameString name, string? description = null, HotChocolate.Types.Descriptors.ITypeReference? type = null) -> void
HotChocolate.Types.Descriptors.Definitions.InterfaceTypeDefinition.HasInterfaces.get -> bool
HotChocolate.Types.Descriptors.Definitions.InterfaceTypeDefinition.InterfaceTypeDefinition(HotChocolate.NameString name, string? description = null, System.Type? runtimeType = null) -> void
HotChocolate.Types.Descriptors.Definitions.ITypeDefinition.NeedsNameCompletion.get -> bool
HotChocolate.Types.Descriptors.Definitions.ITypeDefinition.NeedsNameCompletion.set -> void
HotChocolate.Types.Descriptors.Definitions.ITypeSystemMemberConfiguration
HotChocolate.Types.Descriptors.Definitions.ITypeSystemMemberConfiguration.AddDependency(HotChocolate.Types.Descriptors.Definitions.TypeDependency! dependency) -> void
HotChocolate.Types.Descriptors.Definitions.ITypeSystemMemberConfiguration.Copy(HotChocolate.Types.Descriptors.Definitions.DefinitionBase! newOwner) -> HotChocolate.Types.Descriptors.Definitions.ITypeSystemMemberConfiguration!
HotChocolate.Types.Descriptors.Definitions.ITypeSystemMemberConfiguration.Dependencies.get -> System.Collections.Generic.IReadOnlyList<HotChocolate.Types.Descriptors.Definitions.TypeDependency!>!
HotChocolate.Types.Descriptors.Definitions.ITypeSystemMemberConfiguration.On.get -> HotChocolate.Types.ApplyConfigurationOn
HotChocolate.Types.Descriptors.Definitions.ITypeSystemMemberConfiguration.Owner.get -> HotChocolate.Types.Descriptors.Definitions.IDefinition!
HotChocolate.Types.Descriptors.Definitions.ObjectFieldDefinition.BindToField.get -> HotChocolate.Types.Descriptors.Definitions.ObjectFieldBinding?
HotChocolate.Types.Descriptors.Definitions.ObjectFieldDefinition.BindToField.set -> void
HotChocolate.Types.Descriptors.Definitions.ObjectFieldDefinition.MiddlewareDefinitions.get -> System.Collections.Generic.IList<HotChocolate.Types.Descriptors.Definitions.FieldMiddlewareDefinition!>!
HotChocolate.Types.Descriptors.Definitions.ObjectFieldDefinition.ObjectFieldDefinition(HotChocolate.NameString name, string? description = null, HotChocolate.Types.Descriptors.ITypeReference? type = null, HotChocolate.Resolvers.FieldResolverDelegate? resolver = null, HotChocolate.Resolvers.PureFieldDelegate? pureResolver = null) -> void
HotChocolate.Types.Descriptors.Definitions.ObjectFieldDefinition.PureResolver.get -> HotChocolate.Resolvers.PureFieldDelegate?
HotChocolate.Types.Descriptors.Definitions.ObjectFieldDefinition.Resolvers.get -> HotChocolate.Resolvers.FieldResolverDelegates
HotChocolate.Types.Descriptors.Definitions.ObjectFieldDefinition.Resolvers.set -> void
HotChocolate.Types.Descriptors.Definitions.ObjectFieldDefinition.ResultConverters.get -> System.Collections.Generic.IList<HotChocolate.Types.Descriptors.Definitions.ResultConverterDefinition!>!
HotChocolate.Types.Descriptors.Definitions.ObjectTypeDefinition.HasInterfaces.get -> bool
HotChocolate.Types.Descriptors.Definitions.ObjectTypeDefinition.ObjectTypeDefinition(HotChocolate.NameString name, string? description = null, System.Type? runtimeType = null) -> void
HotChocolate.Types.Descriptors.Definitions.OutputFieldDefinitionBase.HasArguments.get -> bool
HotChocolate.Types.Descriptors.Definitions.ResultConverterDefinition
HotChocolate.Types.Descriptors.Definitions.ResultConverterDefinition.Converter.get -> HotChocolate.Resolvers.ResultConverterDelegate!
HotChocolate.Types.Descriptors.Definitions.ResultConverterDefinition.IsRepeatable.get -> bool
HotChocolate.Types.Descriptors.Definitions.ResultConverterDefinition.Key.get -> string?
HotChocolate.Types.Descriptors.Definitions.ResultConverterDefinition.ResultConverterDefinition(HotChocolate.Resolvers.ResultConverterDelegate! converter, bool isRepeatable = true, string? key = null) -> void
HotChocolate.Types.Descriptors.Definitions.SchemaTypeDefinition.HasDirectives.get -> bool
HotChocolate.Types.Descriptors.Definitions.TypeDefinitionBase<T>.HasDirectives.get -> bool
HotChocolate.Types.Descriptors.Definitions.TypeDefinitionBase<T>.NeedsNameCompletion.get -> bool
HotChocolate.Types.Descriptors.Definitions.TypeDefinitionBase<T>.NeedsNameCompletion.set -> void
HotChocolate.Types.Descriptors.Definitions.TypeDefinitionBase<T>.TypeDefinitionBase(System.Type! runtimeType) -> void
HotChocolate.Types.Descriptors.Definitions.UnionTypeDefinition.UnionTypeDefinition(HotChocolate.NameString name, string? description = null, System.Type? runtimeType = null) -> void
HotChocolate.Types.Descriptors.DependantFactoryTypeReference
HotChocolate.Types.Descriptors.DependantFactoryTypeReference.DependantFactoryTypeReference(HotChocolate.NameString name, HotChocolate.Types.Descriptors.ITypeReference! dependency, System.Func<HotChocolate.Types.Descriptors.IDescriptorContext!, HotChocolate.Types.TypeSystemObjectBase!>! factory, HotChocolate.Types.TypeContext context, string? scope = null) -> void
HotChocolate.Types.Descriptors.DependantFactoryTypeReference.Dependency.get -> HotChocolate.Types.Descriptors.ITypeReference!
HotChocolate.Types.Descriptors.DependantFactoryTypeReference.Equals(HotChocolate.Types.Descriptors.DependantFactoryTypeReference? other) -> bool
HotChocolate.Types.Descriptors.DependantFactoryTypeReference.Factory.get -> System.Func<HotChocolate.Types.Descriptors.IDescriptorContext!, HotChocolate.Types.TypeSystemObjectBase!>!
HotChocolate.Types.Descriptors.DependantFactoryTypeReference.Name.get -> HotChocolate.NameString
HotChocolate.Types.Descriptors.DescriptorContext.Dispose() -> void
HotChocolate.Types.Descriptors.DescriptorContext.InputFormatter.get -> HotChocolate.Types.InputFormatter!
HotChocolate.Types.Descriptors.DescriptorContext.InputParser.get -> HotChocolate.Types.InputParser!
HotChocolate.Types.Descriptors.DescriptorContext.Options.get -> HotChocolate.IReadOnlySchemaOptions!
HotChocolate.Types.Descriptors.DescriptorContext.ResolverCompiler.get -> HotChocolate.Resolvers.IResolverCompiler!
HotChocolate.Types.Descriptors.DescriptorExtensions
HotChocolate.Types.Descriptors.IDescriptorContext.InputFormatter.get -> HotChocolate.Types.InputFormatter!
HotChocolate.Types.Descriptors.IDescriptorContext.InputParser.get -> HotChocolate.Types.InputParser!
HotChocolate.Types.Descriptors.IDescriptorContext.Options.get -> HotChocolate.IReadOnlySchemaOptions!
HotChocolate.Types.Descriptors.IDescriptorContext.ResolverCompiler.get -> HotChocolate.Resolvers.IResolverCompiler!
HotChocolate.Types.Descriptors.ITypeInspector.GetArgumentTypeRef(System.Reflection.ParameterInfo! parameter, string? scope = null, bool ignoreAttributes = false) -> HotChocolate.Types.Descriptors.ITypeReference!
HotChocolate.Types.Descriptors.ITypeInspector.GetReturnTypeRef(System.Reflection.MemberInfo! member, HotChocolate.Types.TypeContext context = HotChocolate.Types.TypeContext.None, string? scope = null, bool ignoreAttributes = false) -> HotChocolate.Types.Descriptors.ITypeReference!
HotChocolate.Types.Descriptors.ITypeReference.Kind.get -> HotChocolate.Types.Descriptors.TypeReferenceKind
HotChocolate.Types.Descriptors.ObjectFieldDescriptor.ObjectFieldDescriptor(HotChocolate.Types.Descriptors.IDescriptorContext! context, System.Linq.Expressions.LambdaExpression! expression, System.Type! sourceType, System.Type? resolverType = null) -> void
HotChocolate.Types.Descriptors.ObjectFieldDescriptor.ObjectFieldDescriptor(HotChocolate.Types.Descriptors.IDescriptorContext! context, System.Reflection.MemberInfo! member, System.Type! sourceType, System.Type? resolverType = null) -> void
HotChocolate.Types.Descriptors.ObjectFieldDescriptor.Resolve(HotChocolate.Resolvers.FieldResolverDelegate! fieldResolver, System.Type? resultType) -> HotChocolate.Types.IObjectFieldDescriptor!
HotChocolate.Types.Descriptors.ObjectFieldDescriptor.Resolver(HotChocolate.Resolvers.FieldResolverDelegate! fieldResolver, System.Type? resultType) -> HotChocolate.Types.IObjectFieldDescriptor!
HotChocolate.Types.Descriptors.ObjectTypeDescriptor.Field<TResolver>(System.Linq.Expressions.Expression<System.Func<TResolver, object?>!>! propertyOrMethod) -> HotChocolate.Types.IObjectFieldDescriptor!
HotChocolate.Types.Descriptors.SyntaxTypeReference.Factory.get -> System.Func<HotChocolate.Types.Descriptors.IDescriptorContext!, HotChocolate.Types.TypeSystemObjectBase!>?
HotChocolate.Types.Descriptors.SyntaxTypeReference.Name.get -> string!
HotChocolate.Types.Descriptors.SyntaxTypeReference.SyntaxTypeReference(HotChocolate.Language.ITypeNode! type, HotChocolate.Types.TypeContext context, string? scope = null, System.Func<HotChocolate.Types.Descriptors.IDescriptorContext!, HotChocolate.Types.TypeSystemObjectBase!>? factory = null) -> void
HotChocolate.Types.Descriptors.SyntaxTypeReference.With(HotChocolate.Optional<HotChocolate.Language.ITypeNode!> type = default(HotChocolate.Optional<HotChocolate.Language.ITypeNode!>), HotChocolate.Optional<HotChocolate.Types.TypeContext> context = default(HotChocolate.Optional<HotChocolate.Types.TypeContext>), HotChocolate.Optional<string?> scope = default(HotChocolate.Optional<string?>), HotChocolate.Optional<System.Func<HotChocolate.Types.Descriptors.IDescriptorContext!, HotChocolate.Types.TypeSystemObjectBase!>?> factory = default(HotChocolate.Optional<System.Func<HotChocolate.Types.Descriptors.IDescriptorContext!, HotChocolate.Types.TypeSystemObjectBase!>?>)) -> HotChocolate.Types.Descriptors.SyntaxTypeReference!
HotChocolate.Types.Descriptors.SyntaxTypeReference.WithFactory(System.Func<HotChocolate.Types.Descriptors.IDescriptorContext!, HotChocolate.Types.TypeSystemObjectBase!>? factory = null) -> HotChocolate.Types.Descriptors.SyntaxTypeReference!
HotChocolate.Types.Descriptors.TypeReference.Kind.get -> HotChocolate.Types.Descriptors.TypeReferenceKind
HotChocolate.Types.Descriptors.TypeReference.TypeReference(HotChocolate.Types.Descriptors.TypeReferenceKind kind, HotChocolate.Types.TypeContext context, string? scope) -> void
HotChocolate.Types.Descriptors.TypeReferenceKind
HotChocolate.Types.Descriptors.TypeReferenceKind.DependantFactory = 4 -> HotChocolate.Types.Descriptors.TypeReferenceKind
HotChocolate.Types.Descriptors.TypeReferenceKind.ExtendedType = 0 -> HotChocolate.Types.Descriptors.TypeReferenceKind
HotChocolate.Types.Descriptors.TypeReferenceKind.Factory = 3 -> HotChocolate.Types.Descriptors.TypeReferenceKind
HotChocolate.Types.Descriptors.TypeReferenceKind.SchemaType = 1 -> HotChocolate.Types.Descriptors.TypeReferenceKind
HotChocolate.Types.Descriptors.TypeReferenceKind.Syntax = 2 -> HotChocolate.Types.Descriptors.TypeReferenceKind
HotChocolate.Types.Descriptors.XmlDocumentationFileResolver.XmlDocumentationFileResolver(System.Func<System.Reflection.Assembly!, string!>? resolveXmlDocumentationFileName) -> void
HotChocolate.Types.Descriptors.XmlDocumentationProvider.XmlDocumentationProvider(HotChocolate.Types.Descriptors.IXmlDocumentationFileResolver! fileResolver, Microsoft.Extensions.ObjectPool.ObjectPool<System.Text.StringBuilder!>! stringBuilderPool) -> void
HotChocolate.Types.EnumType.ParseLiteral(HotChocolate.Language.IValueNode! valueSyntax) -> object?
HotChocolate.Types.EnumTypeDescriptorExtensions
HotChocolate.Types.FieldBase<TDefinition>
HotChocolate.Types.FieldBase<TDefinition>.ContextData.get -> System.Collections.Generic.IReadOnlyDictionary<string!, object?>!
HotChocolate.Types.FieldBase<TDefinition>.Coordinate.get -> HotChocolate.FieldCoordinate
HotChocolate.Types.FieldBase<TDefinition>.DeclaringType.get -> HotChocolate.Types.ITypeSystemObject!
HotChocolate.Types.FieldBase<TDefinition>.Description.get -> string?
HotChocolate.Types.FieldBase<TDefinition>.Directives.get -> HotChocolate.Types.IDirectiveCollection!
HotChocolate.Types.FieldBase<TDefinition>.FieldBase(TDefinition! definition, int index) -> void
HotChocolate.Types.FieldBase<TDefinition>.Index.get -> int
HotChocolate.Types.FieldBase<TDefinition>.Name.get -> HotChocolate.NameString
HotChocolate.Types.FieldBase<TDefinition>.SyntaxNode.get -> HotChocolate.Language.ISyntaxNode?
HotChocolate.Types.Helpers.DirectiveUtils
HotChocolate.Types.Helpers.FieldDescriptorUtilities
HotChocolate.Types.Helpers.TypeNameHelper
HotChocolate.Types.IField.Index.get -> int
HotChocolate.Types.ILeafType.Deserialize(object? resultValue) -> object?
HotChocolate.Types.ILeafType.IsInstanceOfType(HotChocolate.Language.IValueNode! valueSyntax) -> bool
HotChocolate.Types.ILeafType.IsInstanceOfType(object? runtimeValue) -> bool
HotChocolate.Types.ILeafType.ParseLiteral(HotChocolate.Language.IValueNode! valueSyntax) -> object?
HotChocolate.Types.ILeafType.ParseResult(object? resultValue) -> HotChocolate.Language.IValueNode!
HotChocolate.Types.ILeafType.ParseValue(object? runtimeValue) -> HotChocolate.Language.IValueNode!
HotChocolate.Types.ILeafType.Serialize(object? runtimeValue) -> object?
HotChocolate.Types.ILeafType.TryDeserialize(object? resultValue, out object? runtimeValue) -> bool
HotChocolate.Types.InputField.InputField(HotChocolate.Types.Descriptors.Definitions.InputFieldDefinition! definition, int index) -> void
HotChocolate.Types.InputField.Type.get -> HotChocolate.Types.IInputType!
HotChocolate.Types.InputFormatter
HotChocolate.Types.InputFormatter.FormatResult(object? resultValue, HotChocolate.Types.IType! type, HotChocolate.Path? path = null) -> HotChocolate.Language.IValueNode!
HotChocolate.Types.InputFormatter.FormatValue(object? runtimeValue, HotChocolate.Types.IType! type, HotChocolate.Path? path = null) -> HotChocolate.Language.IValueNode!
HotChocolate.Types.InputFormatter.InputFormatter() -> void
HotChocolate.Types.InputFormatter.InputFormatter(HotChocolate.Utilities.ITypeConverter! converter) -> void
HotChocolate.Types.InputParser
HotChocolate.Types.InputParser.InputParser() -> void
HotChocolate.Types.InputParser.InputParser(HotChocolate.Utilities.ITypeConverter! converter) -> void
HotChocolate.Types.InputParser.ParseLiteral(HotChocolate.Language.IValueNode! value, HotChocolate.Types.IInputField! field, System.Type? targetType = null) -> object?
HotChocolate.Types.InputParser.ParseLiteral(HotChocolate.Language.IValueNode! value, HotChocolate.Types.IType! type, HotChocolate.Path? path = null) -> object?
HotChocolate.Types.InputParser.ParseResult(object? resultValue, HotChocolate.Types.IType! type, HotChocolate.Path? path = null) -> object?
HotChocolate.Types.InterfaceType.IsImplementing(HotChocolate.NameString typeName) -> bool
HotChocolate.Types.IObjectField.MaybeStream.get -> bool
HotChocolate.Types.IObjectFieldDescriptor.Resolve(HotChocolate.Resolvers.FieldResolverDelegate! fieldResolver, System.Type? resultType) -> HotChocolate.Types.IObjectFieldDescriptor!
HotChocolate.Types.IObjectType.IsInstanceOfType(HotChocolate.Resolvers.IResolverContext! context, object! resolverResult) -> bool
HotChocolate.Types.ObjectField.MaybeStream.get -> bool
HotChocolate.Types.OutputFieldBase<TDefinition>.Type.get -> HotChocolate.Types.IOutputType!
HotChocolate.Types.Pagination.PagingOptions.InferConnectionNameFromField.get -> bool?
HotChocolate.Types.Pagination.PagingOptions.InferConnectionNameFromField.set -> void
HotChocolate.Types.Pagination.PagingOptions.ProviderName.get -> string?
HotChocolate.Types.Pagination.PagingOptions.ProviderName.set -> void
HotChocolate.Types.Pagination.PagingOptions.RequirePagingBoundaries.get -> bool?
HotChocolate.Types.Pagination.PagingOptions.RequirePagingBoundaries.set -> void
HotChocolate.Types.Relay.Descriptors.NodeDescriptorBase.ConverterHelper
HotChocolate.Types.Relay.MutationPayloadOptions.MutationPayloadOptions() -> void
HotChocolate.Types.ResolveWithObjectFieldDescriptorExtensions
HotChocolate.Types.StreamDirective
HotChocolate.Types.StreamDirective.If.get -> bool
HotChocolate.Types.StreamDirective.InitialCount.get -> int
HotChocolate.Types.StreamDirective.Label.get -> string?
HotChocolate.Types.StreamDirective.StreamDirective(bool if, int initialCount, string? label = null) -> void
HotChocolate.Types.TypeNamePrinter
HotChocolate.Types.TypeSystemObjectBase<TDefinition>.Definition.get -> TDefinition?
HotChocolate.Types.TypeSystemObjectBase<TDefinition>.Definition.set -> void
HotChocolate.Types.UseServiceScopeAttribute
HotChocolate.Types.UseServiceScopeAttribute.UseServiceScopeAttribute() -> void
override HotChocolate.Internal.CustomParameterExpressionBuilder<TArg>.Build(System.Reflection.ParameterInfo! parameter, System.Linq.Expressions.Expression! context) -> System.Linq.Expressions.Expression!
override HotChocolate.Internal.CustomParameterExpressionBuilder<TArg>.CanHandle(System.Reflection.ParameterInfo! parameter) -> bool
override HotChocolate.Types.AnyType.ParseLiteral(HotChocolate.Language.IValueNode! literal) -> object?
override HotChocolate.Types.Argument.OnCompleteField(HotChocolate.Configuration.ITypeCompletionContext! context, HotChocolate.Types.ITypeSystemMember! declaringMember, HotChocolate.Types.Descriptors.Definitions.ArgumentDefinition! definition) -> void
override HotChocolate.Types.Argument.RuntimeType.get -> System.Type!
override HotChocolate.Types.Argument.ToString() -> string!
override HotChocolate.Types.Descriptors.Definitions.DefinitionBase.ToString() -> string!
override HotChocolate.Types.Descriptors.DependantFactoryTypeReference.Equals(HotChocolate.Types.Descriptors.ITypeReference? other) -> bool
override HotChocolate.Types.Descriptors.DependantFactoryTypeReference.Equals(object? obj) -> bool
override HotChocolate.Types.Descriptors.DependantFactoryTypeReference.GetHashCode() -> int
override HotChocolate.Types.Descriptors.DependantFactoryTypeReference.ToString() -> string!
override HotChocolate.Types.FloatTypeBase<TRuntimeType>.ParseLiteral(HotChocolate.Language.IValueNode! valueSyntax) -> object?
override HotChocolate.Types.IdType.ParseLiteral(HotChocolate.Language.IValueNode! literal) -> object?
override HotChocolate.Types.InputField.OnCompleteField(HotChocolate.Configuration.ITypeCompletionContext! context, HotChocolate.Types.ITypeSystemMember! declaringMember, HotChocolate.Types.Descriptors.Definitions.InputFieldDefinition! definition) -> void
override HotChocolate.Types.InputField.ToString() -> string!
override HotChocolate.Types.OutputFieldBase<TDefinition>.RuntimeType.get -> System.Type!
override HotChocolate.Types.OutputFieldBase<TDefinition>.ToString() -> string!
override HotChocolate.Types.StreamDirectiveType.Configure(HotChocolate.Types.IDirectiveTypeDescriptor<HotChocolate.Types.StreamDirective!>! descriptor) -> void
override sealed HotChocolate.Types.ScalarType<TRuntimeType, TLiteral>.ParseLiteral(HotChocolate.Language.IValueNode! valueSyntax) -> object?
static HotChocolate.Internal.FieldInitHelper.CompleteFields<TField>(HotChocolate.Configuration.ITypeCompletionContext! context, HotChocolate.Types.ITypeSystemMember! declaringMember, TField![]! fields) -> HotChocolate.Types.FieldCollection<TField!>!
static HotChocolate.Internal.FieldInitHelper.CompleteFields<TFieldDefinition, TField>(HotChocolate.Configuration.ITypeCompletionContext! context, HotChocolate.Types.ITypeSystemMember! declaringMember, System.Collections.Generic.IEnumerable<TFieldDefinition!>! fieldDefs, System.Func<TFieldDefinition!, int, TField!>! fieldFactory, int maxFieldCount) -> HotChocolate.Types.FieldCollection<TField!>!
static HotChocolate.Internal.FieldInitHelper.CompleteFields<TFieldDefinition, TField>(HotChocolate.Configuration.ITypeCompletionContext! context, HotChocolate.Types.ITypeSystemMember! declaringMember, System.Collections.Generic.IReadOnlyList<TFieldDefinition!>! fieldDefs, System.Func<TFieldDefinition!, int, TField!>! fieldFactory) -> HotChocolate.Types.FieldCollection<TField!>!
static HotChocolate.Internal.FieldInitHelper.CompleteFieldsInternal<TFieldDefinition, TField>(HotChocolate.Configuration.ITypeCompletionContext! context, HotChocolate.Types.ITypeSystemMember! declaringMember, System.Collections.Generic.IEnumerable<TFieldDefinition!>! fieldDefinitions, System.Func<TFieldDefinition!, int, TField!>! fieldFactory, int fieldCount) -> HotChocolate.Types.FieldCollection<TField!>!
static HotChocolate.Internal.TypeExtensionHelper.MergeConfigurations(System.Collections.Generic.ICollection<HotChocolate.Types.Descriptors.Definitions.ITypeSystemMemberConfiguration!>! extensionConfigurations, System.Collections.Generic.ICollection<HotChocolate.Types.Descriptors.Definitions.ITypeSystemMemberConfiguration!>! typeConfigurations) -> void
static HotChocolate.RelaySchemaBuilderExtensions.AddGlobalObjectIdentification(this HotChocolate.ISchemaBuilder! schemaBuilder) -> HotChocolate.ISchemaBuilder!
static HotChocolate.RelaySchemaBuilderExtensions.AddQueryFieldToMutationPayloads(this HotChocolate.ISchemaBuilder! schemaBuilder, System.Action<HotChocolate.Types.Relay.MutationPayloadOptions!>? configureOptions = null) -> HotChocolate.ISchemaBuilder!
static HotChocolate.RelaySchemaBuilderExtensions.EnableRelaySupport(this HotChocolate.ISchemaBuilder! schemaBuilder, HotChocolate.Types.Relay.RelayOptions? options = null) -> HotChocolate.ISchemaBuilder!
static HotChocolate.SchemaBuilderExtensions.AddResolver(this HotChocolate.ISchemaBuilder! builder, HotChocolate.FieldCoordinate field, HotChocolate.Resolvers.FieldResolverDelegate! resolver, System.Type? resultType = null) -> HotChocolate.ISchemaBuilder!
static HotChocolate.SchemaBuilderExtensions.AddResolver(this HotChocolate.ISchemaBuilder! builder, System.Type! resolverType, HotChocolate.NameString? typeName = null) -> HotChocolate.ISchemaBuilder!
static HotChocolate.SchemaBuilderExtensions.AddResolver<T>(this HotChocolate.ISchemaBuilder! builder, HotChocolate.NameString? typeName = null) -> HotChocolate.ISchemaBuilder!
static HotChocolate.SchemaBuilderExtensions.AddRootResolver(this HotChocolate.ISchemaBuilder! builder, System.Type! resolverType) -> HotChocolate.ISchemaBuilder!
static HotChocolate.SchemaBuilderExtensions.AddRootResolver<T>(this HotChocolate.ISchemaBuilder! builder) -> HotChocolate.ISchemaBuilder!
static HotChocolate.SchemaBuilderExtensions.AddRootResolver<T>(this HotChocolate.ISchemaBuilder! builder, T! root) -> HotChocolate.ISchemaBuilder!
static HotChocolate.SchemaOptions.FromOptions(HotChocolate.IReadOnlySchemaOptions! options) -> HotChocolate.SchemaOptions!
static HotChocolate.Types.Descriptors.ObjectFieldDescriptor.New(HotChocolate.Types.Descriptors.IDescriptorContext! context, System.Linq.Expressions.LambdaExpression! expression, System.Type! sourceType, System.Type? resolverType = null) -> HotChocolate.Types.Descriptors.ObjectFieldDescriptor!
static HotChocolate.Types.Descriptors.ObjectFieldDescriptor.New(HotChocolate.Types.Descriptors.IDescriptorContext! context, System.Reflection.MemberInfo! member, System.Type! sourceType, System.Type? resolverType = null) -> HotChocolate.Types.Descriptors.ObjectFieldDescriptor!
static HotChocolate.Types.Descriptors.TypeReference.Create(HotChocolate.Language.ITypeNode! type, HotChocolate.Types.TypeContext context = HotChocolate.Types.TypeContext.None, string? scope = null, System.Func<HotChocolate.Types.Descriptors.IDescriptorContext!, HotChocolate.Types.TypeSystemObjectBase!>? factory = null) -> HotChocolate.Types.Descriptors.SyntaxTypeReference!
static HotChocolate.Types.Descriptors.TypeReference.Create(HotChocolate.NameString name, HotChocolate.Types.Descriptors.ITypeReference! dependency, System.Func<HotChocolate.Types.Descriptors.IDescriptorContext!, HotChocolate.Types.TypeSystemObjectBase!>! factory, HotChocolate.Types.TypeContext context = HotChocolate.Types.TypeContext.None, string? scope = null) -> HotChocolate.Types.Descriptors.DependantFactoryTypeReference!
static HotChocolate.Types.Descriptors.TypeReference.Create(HotChocolate.NameString typeName, HotChocolate.Types.TypeContext context = HotChocolate.Types.TypeContext.None, string? scope = null, System.Func<HotChocolate.Types.Descriptors.IDescriptorContext!, HotChocolate.Types.TypeSystemObjectBase!>? factory = null) -> HotChocolate.Types.Descriptors.SyntaxTypeReference!
static HotChocolate.Types.Descriptors.TypeReference.Parse(string! sourceText, HotChocolate.Types.TypeContext context = HotChocolate.Types.TypeContext.None, string? scope = null, System.Func<HotChocolate.Types.Descriptors.IDescriptorContext!, HotChocolate.Types.TypeSystemObjectBase!>? factory = null) -> HotChocolate.Types.Descriptors.SyntaxTypeReference!
static HotChocolate.Types.DirectiveType.CreateUnsafe(HotChocolate.Types.Descriptors.Definitions.DirectiveTypeDefinition! definition) -> HotChocolate.Types.DirectiveType!
static HotChocolate.Types.EnumType.CreateUnsafe(HotChocolate.Types.Descriptors.Definitions.EnumTypeDefinition! definition) -> HotChocolate.Types.EnumType!
static HotChocolate.Types.EnumTypeExtension.CreateUnsafe(HotChocolate.Types.Descriptors.Definitions.EnumTypeDefinition! definition) -> HotChocolate.Types.EnumTypeExtension!
static HotChocolate.Types.Helpers.FieldDescriptorUtilities.AddExplicitFields<TMember, TField>(System.Collections.Generic.IEnumerable<TField!>! fieldDefinitions, System.Func<TField!, TMember?>! resolveMember, System.Collections.Generic.IDictionary<HotChocolate.NameString, TField!>! fields, System.Collections.Generic.ISet<TMember!>! handledMembers) -> void
static HotChocolate.Types.Helpers.FieldDescriptorUtilities.AddImplicitFields<TDescriptor, TMember, TField>(TDescriptor descriptor, System.Func<TMember!, TField!>! createdFieldDefinition, System.Collections.Generic.IDictionary<HotChocolate.NameString, TField!>! fields, System.Collections.Generic.ISet<TMember!>! handledMembers) -> void
static HotChocolate.Types.Helpers.FieldDescriptorUtilities.AddImplicitFields<TDescriptor, TMember, TField>(TDescriptor descriptor, System.Type! fieldBindingType, System.Func<TMember!, TField!>! createdFieldDefinition, System.Collections.Generic.IDictionary<HotChocolate.NameString, TField!>! fields, System.Collections.Generic.ISet<TMember!>! handledMembers, System.Func<System.Collections.Generic.IReadOnlyList<TMember!>!, TMember!, bool>? include = null, bool includeIgnoredMembers = false) -> void
static HotChocolate.Types.Helpers.FieldDescriptorUtilities.DiscoverArguments(HotChocolate.Types.Descriptors.IDescriptorContext! context, System.Collections.Generic.ICollection<HotChocolate.Types.Descriptors.Definitions.ArgumentDefinition!>! arguments, System.Reflection.MemberInfo? member) -> void
static HotChocolate.Types.InputObjectType.CreateUnsafe(HotChocolate.Types.Descriptors.Definitions.InputObjectTypeDefinition! definition) -> HotChocolate.Types.InputObjectType!
static HotChocolate.Types.InputObjectTypeExtension.CreateUnsafe(HotChocolate.Types.Descriptors.Definitions.InputObjectTypeDefinition! definition) -> HotChocolate.Types.InputObjectTypeExtension!
static HotChocolate.Types.InterfaceType.CreateUnsafe(HotChocolate.Types.Descriptors.Definitions.InterfaceTypeDefinition! definition) -> HotChocolate.Types.InterfaceType!
static HotChocolate.Types.InterfaceTypeExtension.CreateUnsafe(HotChocolate.Types.Descriptors.Definitions.InterfaceTypeDefinition! definition) -> HotChocolate.Types.InterfaceTypeExtension!
static HotChocolate.Types.ObjectType.CreateUnsafe(HotChocolate.Types.Descriptors.Definitions.ObjectTypeDefinition! definition) -> HotChocolate.Types.ObjectType!
static HotChocolate.Types.ObjectTypeExtension.CreateUnsafe(HotChocolate.Types.Descriptors.Definitions.ObjectTypeDefinition! definition) -> HotChocolate.Types.ObjectTypeExtension!
static HotChocolate.Types.Pagination.PagingHelper.GetSchemaType(HotChocolate.Types.Descriptors.ITypeInspector! typeInspector, System.Reflection.MemberInfo? member, System.Type? type = null) -> HotChocolate.Internal.IExtendedType!
static HotChocolate.Types.Pagination.PagingHelper.TryGetNamedType(HotChocolate.Types.Descriptors.ITypeInspector! typeInspector, System.Reflection.MemberInfo? member, out System.Type? namedType) -> bool
static HotChocolate.Types.Pagination.PagingHelper.UsePaging(HotChocolate.Types.IObjectFieldDescriptor! descriptor, System.Type? entityType = null, HotChocolate.Types.Pagination.GetPagingProvider? resolvePagingProvider = null, HotChocolate.Types.Pagination.PagingOptions options = default(HotChocolate.Types.Pagination.PagingOptions)) -> HotChocolate.Types.IObjectFieldDescriptor!
static HotChocolate.Types.Relay.Descriptors.NodeDescriptorBase.ConverterHelper.TryAdd(HotChocolate.Types.IObjectFieldDescriptor! descriptor) -> HotChocolate.Types.IObjectFieldDescriptor!
static HotChocolate.Types.ResolveWithObjectFieldDescriptorExtensions.ResolveWith<TResolver, TResult>(this HotChocolate.Types.IObjectFieldDescriptor! descriptor, System.Linq.Expressions.Expression<System.Func<TResolver, System.Threading.Tasks.Task<TResult?>!>!>! propertyOrMethod) -> HotChocolate.Types.IObjectFieldDescriptor!
static HotChocolate.Types.ResolveWithObjectFieldDescriptorExtensions.ResolveWith<TResolver, TResult>(this HotChocolate.Types.IObjectFieldDescriptor! descriptor, System.Linq.Expressions.Expression<System.Func<TResolver, TResult?>!>! propertyOrMethod) -> HotChocolate.Types.IObjectFieldDescriptor!
static HotChocolate.Types.UnionType.CreateUnsafe(HotChocolate.Types.Descriptors.Definitions.UnionTypeDefinition! definition) -> HotChocolate.Types.UnionType!
static HotChocolate.Types.UnionTypeExtension.CreateUnsafe(HotChocolate.Types.Descriptors.Definitions.UnionTypeDefinition! definition) -> HotChocolate.Types.UnionTypeExtension!
virtual HotChocolate.Configuration.TypeInterceptor.OnValidateType(HotChocolate.Configuration.ITypeSystemObjectContext! validationContext, HotChocolate.Types.Descriptors.Definitions.DefinitionBase? definition, System.Collections.Generic.IDictionary<string!, object?>! contextData) -> void
virtual HotChocolate.Configuration.TypeInterceptor.RegisterMoreTypes(System.Collections.Generic.IReadOnlyCollection<HotChocolate.Configuration.ITypeDiscoveryContext!>! discoveryContexts) -> System.Collections.Generic.IEnumerable<HotChocolate.Types.Descriptors.ITypeReference!>!
virtual HotChocolate.Types.Descriptors.DefaultNamingConventions.IsDeprecated(System.Reflection.MemberInfo! member, out string? reason) -> bool
virtual HotChocolate.Types.Descriptors.DefaultTypeInspector.GetReturnTypeRef(System.Reflection.MemberInfo! member, HotChocolate.Types.TypeContext context = HotChocolate.Types.TypeContext.None, string? scope = null, bool ignoreAttributes = false) -> HotChocolate.Types.Descriptors.ITypeReference!
virtual HotChocolate.Types.DirectiveType.OnCompleteFields(HotChocolate.Configuration.ITypeCompletionContext! context, HotChocolate.Types.Descriptors.Definitions.DirectiveTypeDefinition! definition) -> HotChocolate.Types.FieldCollection<HotChocolate.Types.Argument!>!
virtual HotChocolate.Types.FieldBase<TDefinition>.OnCompleteField(HotChocolate.Configuration.ITypeCompletionContext! context, HotChocolate.Types.ITypeSystemMember! declaringMember, TDefinition! definition) -> void
virtual HotChocolate.Types.InputObjectType.OnCompleteCreateInstance(HotChocolate.Configuration.ITypeCompletionContext! context, HotChocolate.Types.Descriptors.Definitions.InputObjectTypeDefinition! definition) -> System.Func<object?[]!, object!>!
virtual HotChocolate.Types.InputObjectType.OnCompleteFields(HotChocolate.Configuration.ITypeCompletionContext! context, HotChocolate.Types.Descriptors.Definitions.InputObjectTypeDefinition! definition) -> HotChocolate.Types.FieldCollection<HotChocolate.Types.InputField!>!
virtual HotChocolate.Types.InputObjectType.OnCompleteGetFieldValues(HotChocolate.Configuration.ITypeCompletionContext! context, HotChocolate.Types.Descriptors.Definitions.InputObjectTypeDefinition! definition) -> System.Action<object!, object?[]!>!
virtual HotChocolate.Types.InterfaceType.OnCompleteFields(HotChocolate.Configuration.ITypeCompletionContext! context, HotChocolate.Types.Descriptors.Definitions.InterfaceTypeDefinition! definition) -> HotChocolate.Types.FieldCollection<HotChocolate.Types.InterfaceField!>!
virtual HotChocolate.Types.ObjectType.IsInstanceOfType(HotChocolate.Resolvers.IResolverContext! context, object! resolverResult) -> bool
virtual HotChocolate.Types.ObjectType.OnCompleteFields(HotChocolate.Configuration.ITypeCompletionContext! context, HotChocolate.Types.Descriptors.Definitions.ObjectTypeDefinition! definition) -> HotChocolate.Types.FieldCollection<HotChocolate.Types.ObjectField!>!
virtual HotChocolate.Types.TypeSystemObjectBase<TDefinition>.OnValidateType(HotChocolate.Configuration.ITypeSystemObjectContext! context, HotChocolate.Types.Descriptors.Definitions.DefinitionBase! definition, System.Collections.Generic.IDictionary<string!, object?>! contextData) -> void
~HotChocolate.Configuration.ITypeDiscoveryContext.Dependencies.get -> System.Collections.Generic.IList<HotChocolate.Types.Descriptors.Definitions.TypeDependency>
~HotChocolate.Internal.CustomServiceParameterExpressionBuilder<TService>.Build(System.Reflection.ParameterInfo parameter, System.Linq.Expressions.Expression context) -> System.Linq.Expressions.Expression
~HotChocolate.Internal.CustomServiceParameterExpressionBuilder<TService>.CanHandle(System.Reflection.ParameterInfo parameter) -> bool
~HotChocolate.Resolvers.IFieldSelection.Type.get -> HotChocolate.Types.IType
~HotChocolate.SchemaBuilder.Create(HotChocolate.Types.Descriptors.IDescriptorContext context) -> HotChocolate.Schema
~HotChocolate.SchemaBuilder.CreateContext() -> HotChocolate.Types.Descriptors.DescriptorContext
~HotChocolate.Types.Descriptors.Definitions.ITypeDefinition.RuntimeType.get -> System.Type
~HotChocolate.Types.Descriptors.Definitions.ITypeDefinition.RuntimeType.set -> void
~HotChocolate.Types.Descriptors.EnumValueDescriptor.EnumValueDescriptor(HotChocolate.Types.Descriptors.IDescriptorContext context, object runtimeValue) -> void
~HotChocolate.Types.Descriptors.EnumValueDescriptor.Ignore(bool ignore = true) -> HotChocolate.Types.IEnumValueDescriptor
~HotChocolate.Types.Descriptors.InputObjectTypeDescriptor.InputObjectTypeDescriptor(HotChocolate.Types.Descriptors.IDescriptorContext context, System.Type runtimeType) -> void
~HotChocolate.Types.IEnumValueDescriptor.Ignore(bool ignore = true) -> HotChocolate.Types.IEnumValueDescriptor
~HotChocolate.Types.InterfaceField.DeclaringType.get -> HotChocolate.Types.InterfaceType
~HotChocolate.Types.InterfaceField.InterfaceField(HotChocolate.Types.Descriptors.Definitions.InterfaceFieldDefinition definition, int index) -> void
~override HotChocolate.Types.UseServiceScopeAttribute.OnConfigure(HotChocolate.Types.Descriptors.IDescriptorContext context, HotChocolate.Types.IObjectFieldDescriptor descriptor, System.Reflection.MemberInfo member) -> void
~static HotChocolate.Internal.TypeDependencyHelper.CollectDependencies(HotChocolate.Types.Descriptors.Definitions.DirectiveTypeDefinition definition, System.Collections.Generic.ICollection<HotChocolate.Types.Descriptors.Definitions.TypeDependency> dependencies) -> void
~static HotChocolate.Internal.TypeDependencyHelper.CollectDependencies(HotChocolate.Types.Descriptors.Definitions.EnumTypeDefinition definition, System.Collections.Generic.ICollection<HotChocolate.Types.Descriptors.Definitions.TypeDependency> dependencies) -> void
~static HotChocolate.Internal.TypeDependencyHelper.CollectDependencies(HotChocolate.Types.Descriptors.Definitions.InputObjectTypeDefinition definition, System.Collections.Generic.ICollection<HotChocolate.Types.Descriptors.Definitions.TypeDependency> dependencies) -> void
~static HotChocolate.Internal.TypeDependencyHelper.CollectDependencies(HotChocolate.Types.Descriptors.Definitions.InterfaceTypeDefinition definition, System.Collections.Generic.ICollection<HotChocolate.Types.Descriptors.Definitions.TypeDependency> dependencies) -> void
~static HotChocolate.Internal.TypeDependencyHelper.CollectDependencies(HotChocolate.Types.Descriptors.Definitions.ObjectTypeDefinition definition, System.Collections.Generic.ICollection<HotChocolate.Types.Descriptors.Definitions.TypeDependency> dependencies) -> void
~static HotChocolate.SchemaBuilderExtensions.BindRuntimeType(this HotChocolate.ISchemaBuilder builder, System.Type runtimeType, HotChocolate.NameString? typeName = null) -> HotChocolate.ISchemaBuilder
~static HotChocolate.SchemaBuilderExtensions.BindRuntimeType<TRuntimeType>(this HotChocolate.ISchemaBuilder builder, HotChocolate.NameString? typeName = null) -> HotChocolate.ISchemaBuilder
~static HotChocolate.SchemaBuilderExtensions.TryBindRuntimeType(this HotChocolate.Types.Descriptors.IDescriptorContext context, HotChocolate.NameString typeName, System.Type runtimeType) -> void
~static HotChocolate.SchemaSerializer.SerializeSchema(HotChocolate.ISchema schema, bool includeSpecScalars = false, bool printResolverKind = false) -> HotChocolate.Language.DocumentNode
~static HotChocolate.Types.Descriptors.DescriptorExtensions.ToDefinition<T>(this HotChocolate.Types.IDescriptor<T> descriptor) -> T
~static HotChocolate.Types.Descriptors.DescriptorExtensions.ToDescriptor(this HotChocolate.Types.Descriptors.Definitions.ArgumentDefinition definition, HotChocolate.Types.Descriptors.IDescriptorContext context) -> HotChocolate.Types.Descriptors.ArgumentDescriptor
~static HotChocolate.Types.Descriptors.DescriptorExtensions.ToDescriptor(this HotChocolate.Types.Descriptors.Definitions.EnumTypeDefinition definition, HotChocolate.Types.Descriptors.IDescriptorContext context) -> HotChocolate.Types.Descriptors.EnumTypeDescriptor
~static HotChocolate.Types.Descriptors.DescriptorExtensions.ToDescriptor(this HotChocolate.Types.Descriptors.Definitions.EnumValueDefinition definition, HotChocolate.Types.Descriptors.IDescriptorContext context) -> HotChocolate.Types.Descriptors.EnumValueDescriptor
~static HotChocolate.Types.Descriptors.DescriptorExtensions.ToDescriptor(this HotChocolate.Types.Descriptors.Definitions.ObjectFieldDefinition definition, HotChocolate.Types.Descriptors.IDescriptorContext context) -> HotChocolate.Types.Descriptors.ObjectFieldDescriptor
~static HotChocolate.Types.Descriptors.DescriptorExtensions.ToDescriptor(this HotChocolate.Types.Descriptors.Definitions.ObjectTypeDefinition definition, HotChocolate.Types.Descriptors.IDescriptorContext context) -> HotChocolate.Types.Descriptors.ObjectTypeDescriptor
~static HotChocolate.Types.DirectiveTypeDescriptorExtensions.Type(this HotChocolate.Types.IDirectiveArgumentDescriptor descriptor, string typeSyntax) -> HotChocolate.Types.IDirectiveArgumentDescriptor
~static HotChocolate.Types.EnumTypeDescriptorExtensions.Ignore<T>(this HotChocolate.Types.IEnumTypeDescriptor descriptor, T value) -> HotChocolate.Types.IEnumTypeDescriptor
~static HotChocolate.Types.EnumTypeDescriptorExtensions.Ignore<T>(this HotChocolate.Types.IEnumTypeDescriptor<T> descriptor, T value) -> HotChocolate.Types.IEnumTypeDescriptor<T>
~static HotChocolate.Types.Helpers.DirectiveUtils.AddDirective(this HotChocolate.Types.Descriptors.Definitions.IHasDirectiveDefinition directivesContainer, HotChocolate.NameString name, System.Collections.Generic.IEnumerable<HotChocolate.Language.ArgumentNode> arguments) -> void
~static HotChocolate.Types.Helpers.DirectiveUtils.AddDirective<T>(this HotChocolate.Types.Descriptors.Definitions.IHasDirectiveDefinition directivesContainer, T directive, HotChocolate.Types.Descriptors.ITypeInspector typeInspector) -> void
~static HotChocolate.Types.Helpers.TypeNameHelper.AddNameFunction<TDefinition>(HotChocolate.Types.IDescriptor<TDefinition> descriptor, System.Func<HotChocolate.Types.INamedType, HotChocolate.NameString> createName, System.Type dependency) -> void
~static HotChocolate.Types.InputObjectTypeDescriptorExtensions.Type(this HotChocolate.Types.IInputFieldDescriptor descriptor, string typeSyntax) -> HotChocolate.Types.IInputFieldDescriptor
~static HotChocolate.Types.InterfaceTypeDescriptorExtensions.Type(this HotChocolate.Types.IInterfaceFieldDescriptor descriptor, string typeSyntax) -> HotChocolate.Types.IInterfaceFieldDescriptor
~static HotChocolate.Types.ObjectFieldDescriptorExtensions.Type(this HotChocolate.Types.IArgumentDescriptor descriptor, string typeSyntax) -> HotChocolate.Types.IArgumentDescriptor
~static HotChocolate.Types.ObjectFieldDescriptorExtensions.Type(this HotChocolate.Types.IObjectFieldDescriptor descriptor, string typeSyntax) -> HotChocolate.Types.IObjectFieldDescriptor
~static HotChocolate.Types.ObjectFieldDescriptorExtensions.UseServiceScope(this HotChocolate.Types.IObjectFieldDescriptor descriptor) -> HotChocolate.Types.IObjectFieldDescriptor
~static HotChocolate.Types.Relay.IdMiddleware.Create() -> HotChocolate.Types.Descriptors.Definitions.ResultConverterDefinition
~static HotChocolate.Types.TypeExtensions.IsInstanceOfType(this HotChocolate.Types.IInputType type, HotChocolate.Language.IValueNode literal) -> bool
~static HotChocolate.Types.TypeNamePrinter.Print(this HotChocolate.Types.IType type) -> string
~static HotChocolate.Utilities.TypeConverterServiceProviderExtensions.GetServiceOrDefault<T>(this System.IServiceProvider services, System.Func<T> defaultService) -> T