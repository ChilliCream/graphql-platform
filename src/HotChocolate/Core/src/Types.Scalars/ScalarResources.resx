<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root"
              xmlns=""
              xmlns:xsd="http://www.w3.org/2001/XMLSchema"
              xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral,
      PublicKeyToken=b77a5c561934e089
    </value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral,
      PublicKeyToken=b77a5c561934e089
    </value>
  </resheader>
  <data name="EmailAddressType_Description" xml:space="preserve">
    <value>The EmailAddress scalar type represents a email address, represented as UTF-8 character sequences. The scalar follows the specification defined in RFC 5322</value>
  </data>
  <data name="EmailAddressType_IsInvalid_ParseLiteral" xml:space="preserve">
    <value>EmailAddressType cannot parse the provided literal. The provided value does not meet the RFC 5322 specification.</value>
  </data>
  <data name="EmailAddressType_IsInvalid_ParseValue" xml:space="preserve">
    <value>EmailAddressType cannot parse the provided value. The provided value does not meet the RFC 5322 specification.</value>
  </data>
  <data name="EmailAddressType_ValidationPattern" xml:space="preserve">
    <value>(?:[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])</value>
  </data>
  <data name="HexColorType_Description" xml:space="preserve">
    <value>The HexColor scalar type represents a valid HexColor color code.</value>
  </data>
  <data name="HexColorType_IsInvalid_ParseLiteral" xml:space="preserve">
    <value>HexColorType cannot parse the provided literal. The provided value is not a valid HEX color code.</value>
  </data>
  <data name="HexColorType_IsInvalid_ParseValue" xml:space="preserve">
    <value>HexColorType cannot parse the provided value. The provided value is not a valid HEX color code.</value>
  </data>
  <data name="HexColorType_ValidationPattern" xml:space="preserve">
    <value>(^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3}|[A-Fa-f0-9]{8})$)</value>
  </data>
  <data name="HslType_Description" xml:space="preserve">
    <value>The Hsl scalar type represents a a valid a CSS HSL color defined in https://www.w3.org/TR/css-color-3/#hsl-color.</value>
  </data>
  <data name="HslType_IsInvalid_ParseLiteral" xml:space="preserve">
    <value>HslType cannot parse the provided literal. The provided value is not a valid CSS HSL color code.</value>
  </data>
  <data name="HslType_IsInvalid_ParseValue" xml:space="preserve">
    <value>HslType cannot parse the provided value. The provided value is not a valid CSS HSL color code.</value>
  </data>
  <data name="HslType_ValidationPattern" xml:space="preserve">
    <value>(^(?:hsla?)\((?:\d+%?(?:deg|rad|grad|turn)?(?:,|\s)+){2,3}[\s\/]*[\d\.]+%?\))</value>
  </data>
  <data name="HslaType_Description" xml:space="preserve">
    <value>The Hsla scalar type represents a a valid a CSS HSLA color as defined in https://www.w3.org/TR/css-color-3/#hsla-color.</value>
  </data>
  <data name="HslaType_IsInvalid_ParseLiteral" xml:space="preserve">
    <value>HslaType cannot parse the provided literal. The provided value is not a valid CSS HSLA color code.</value>
  </data>
  <data name="HslaType_IsInvalid_ParseValue" xml:space="preserve">
    <value>HslaType cannot parse the provided value. The provided value is not a valid CSS HSLA color code.</value>
  </data>
  <data name="NegativeFloatType_Description" xml:space="preserve">
    <value>The NegativeFloat scalar type represents a double‚Äêprecision fractional value less than 0.</value>
  </data>
  <data name="NegativeFloatType_IsNotNegative_ParseLiteral" xml:space="preserve">
    <value>NegativeFloatType cannot parse the provided literal. The provided value was not negative.</value>
  </data>
  <data name="NegativeFloatType_IsNotNegative_ParseValue" xml:space="preserve">
    <value>NegativeFloatType cannot parse the provided value. The provided value was not negative.</value>
  </data>
  <data name="NegativeIntType_Description" xml:space="preserve">
    <value>The NegativeInt scalar type represents a signed 32-bit numeric non-fractional with a maximum of -1.</value>
  </data>
  <data name="NegativeIntType_IsNotNegative_ParseLiteral" xml:space="preserve">
    <value>NegativeIntType cannot parse the provided literal. The provided value was not negative.</value>
  </data>
  <data name="NegativeIntType_IsNotNegative_ParseValue" xml:space="preserve">
    <value>NegativeIntType cannot parse the provided value. The provided value was not negative.</value>
  </data>
  <data name="NonEmptyStringType_Description" xml:space="preserve">
    <value>The NonEmptyString scalar type represents non empty textual data, represented as UTF‚Äê8 character sequences with at least one character</value>
  </data>
  <data name="NonEmptyStringType_IsEmpty_ParseLiteral" xml:space="preserve">
    <value>NonEmptyStringType cannot parse the provided literal. The provided string was empty.</value>
  </data>
  <data name="NonEmptyStringType_IsEmpty_ParseValue" xml:space="preserve">
    <value>NonEmptyStringType cannot parse the provided value. The provided string was empty.</value>
  </data>
  <data name="NonNegativeIntType_Description" xml:space="preserve">
    <value>The NonNegativeInt scalar type represents a unsigned 32-bit numeric non-fractional value equal to or greater than 0.</value>
  </data>
  <data name="NonNegativeIntType_IsNotNonNegative_ParseLiteral" xml:space="preserve">
    <value>NonNegativeIntType cannot parse the provided literal. The provided value was not greater than or equal to 0.</value>
  </data>
  <data name="NonNegativeIntType_IsNotNonNegative_ParseValue" xml:space="preserve">
    <value>NonNegativeIntType cannot parse the provided value. The provided value was not greater than or equal to 0.</value>
  </data>
  <data name="NonPositiveFloatType_Description" xml:space="preserve">
    <value>The NonPositiveFloat scalar type represents a double‚Äêprecision fractional value less than or equal to 0.</value>
  </data>
  <data name="NonPositiveFloatType_IsNotNonPositive_ParseLiteral" xml:space="preserve">
    <value>NonPositiveFloatType cannot parse the provided literal. The provided value was not less than or equal to 0.</value>
  </data>
  <data name="NonPositiveFloatType_IsNotNonPositive_ParseValue" xml:space="preserve">
    <value>NonPositiveFloatType cannot parse the provided value. The provided value was not less than or equal to 0.</value>
  </data>
  <data name="NonPositiveIntType_Description" xml:space="preserve">
    <value>The NonPositiveInt scalar type represents a signed 32-bit numeric non-fractional value less than or equal to 0.</value>
  </data>
  <data name="NonPositiveIntType_IsNotNonPositive_ParseLiteral" xml:space="preserve">
    <value>NonPositiveIntType cannot parse the provided literal. The provided value was not less than or equal to 0.</value>
  </data>
  <data name="NonPositiveIntType_IsNotNonPositive_ParseValue" xml:space="preserve">
    <value>NonPositiveIntType cannot parse the provided value. The provided value was not less than or equal to 0.</value>
  </data>
  <data name="NonNegativeFloatType_Description" xml:space="preserve">
    <value>The NonNegativeFloat scalar type represents a double‚Äêprecision fractional value greater than or equal to 0.</value>
  </data>
  <data name="NonNegativeFloatType_IsNotNonNegative_ParseLiteral" xml:space="preserve">
    <value>NonNegativeFloatType cannot parse the provided literal. The provided value was not greater than or equal to 0.</value>
  </data>
  <data name="NonNegativeFloatType_IsNotNonNegative_ParseValue" xml:space="preserve">
    <value>NonNegativeFloatType cannot parse the provided value. The provided value was not greater than or equal to 0.</value>
  </data>
  <data name="PhoneNumberType_Description" xml:space="preserve">
    <value>The PhoneNumber scalar type represents a value that conforms to the standard E.164 format.</value>
  </data>
  <data name="PhoneNumberType_IsInvalid_ParseLiteral" xml:space="preserve">
    <value>PhoneNumberType cannot parse the provided literal. The provided value does not meet the standard E.164 format.</value>
  </data>
  <data name="PhoneNumberType_IsInvalid_ParseValue" xml:space="preserve">
    <value>PhoneNumberType cannot parse the provided value. The provided value does not meet the standard E.164 format.</value>
  </data>
  <data name="PhoneNumber_ValidationPattern" xml:space="preserve">
    <value>(^\+[1-9]\d{1,14}$)</value>
  </data>
  <data name="PositiveIntType_Description" xml:space="preserve">
    <value>The PositiveInt scalar type represents a signed 32-bit numeric non-fractional value of at least the value 1.</value>
  </data>
  <data name="PositiveIntType_ZeroOrLess_ParseLiteral" xml:space="preserve">
    <value>PositiveIntType cannot parse the provided literal. The provided value is 0 or less.</value>
  </data>
  <data name="PositiveIntType_ZeroOrLess_ParseValue" xml:space="preserve">
    <value>PositiveIntType cannot parse the provided value. The provided value is 0 or less.</value>
  </data>
  <data name="PostalCodeType_Description" xml:space="preserve">
    <value>The PostalCode scalar type represents a valid postal code.</value>
  </data>
  <data name="PostalCodeType_IsInvalid_ParseLiteral" xml:space="preserve">
    <value>PostalCodeType cannot parse the provided literal. The provided value is a invalid postal code.</value>
  </data>
  <data name="PostalCodeType_IsInvalid_ParseValue" xml:space="preserve">
    <value>PostalCodeType cannot parse the provided value. The provided value is a invalid postal code.</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_US" xml:space="preserve">
    <value>(^\d{5}([-]?\d{4})?$)</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_UK" xml:space="preserve">
    <value>(^(GIR|[A-Z]\d[A-Z\d]??|[A-Z]{2}\d[A-Z\d]??)[ ]??(\d[A-Z]{2})$)</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_DE" xml:space="preserve">
    <value>(\b((?:0[1-46-9]\d{3})|(?:[1-357-9]\d{4})|(?:[4][0-24-9]\d{3})|(?:[6][013-9]\d{3}))\b)</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_CA" xml:space="preserve">
    <value>(^([ABCEGHJKLMNPRSTVXY]\d[ABCEGHJKLMNPRSTVWXYZ]) {0,1}(\d[ABCEGHJKLMNPRSTVWXYZ]\d)$)</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_FR" xml:space="preserve">
    <value>(^(F-)?((2[A|B])|[0-9]{2})[0-9]{3}$)</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_IT" xml:space="preserve">
    <value>(^(V-|I-)?[0-9]{5}$)</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_AU" xml:space="preserve">
    <value>(^(0[289][0-9]{2})|([1345689][0-9]{3})|(2[0-8][0-9]{2})|(290[0-9])|(291[0-4])|(7[0-4][0-9]{2})|(7[8-9][0-9]{2})$)</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_NL" xml:space="preserve">
    <value>(^[1-9][0-9]{3}\s?([a-zA-Z]{2})?$)</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_ES" xml:space="preserve">
    <value>(^([1-9]{2}|[0-9][1-9]|[1-9][0-9])[0-9]{3}$)</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_DK" xml:space="preserve">
    <value>(^([D|d][K|k]( |-))?[1-9]{1}[0-9]{3}$)</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_SE" xml:space="preserve">
    <value>(^(s-|S-){0,1}[0-9]{3}\s?[0-9]{2}$)</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_BE" xml:space="preserve">
    <value>(^[1-9]{1}[0-9]{3}$)</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_IN" xml:space="preserve">
    <value>(^\d{6}$)</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_AT" xml:space="preserve">
    <value>(^\d{4}$)</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_PT" xml:space="preserve">
    <value>(^\d{4}([\-]\d{3})?$)</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_CH" xml:space="preserve">
    <value>(^\d{4}$)</value>
  </data>
  <data name="PostalCodeType_ValidationPattern_LU" xml:space="preserve">
    <value>(^\d{4}$)</value>
  </data>
  <data name="RegexType_IsInvalid_ParseLiteral" xml:space="preserve">
    <value>{0}Type cannot parse the provided literal. The provided value does not match the regular expression pattern.</value>
  </data>
  <data name="RegexType_IsInvalid_ParseValue" xml:space="preserve">
    <value>{0}Type cannot parse the provided value. The provided value does not match the regular expression pattern.</value>
  </data>
  <data name="UnsignedIntType_Description" xml:space="preserve">
    <value>The UnsignedInt scalar type represents a unsigned 32-bit numeric non-fractional value greater than or equal to 0.</value>
  </data>
  <data name="UnsignedIntType_IsNotUnsigned_ParseLiteral" xml:space="preserve">
    <value>UnsignedIntType cannot parse the provided literal. The provided value is not greater than or equal to 0.</value>
  </data>
  <data name="UnsignedIntType_IsNotUnsigned_ParseValue" xml:space="preserve">
    <value>UnsignedIntType cannot parse the provided value. The provided value is not greater than or equal to 0.</value>
  </data>
  <data name="IPv4Type_Description" xml:space="preserve">
    <value>The IPv4 scalar type represents a valid a IPv4 address as defined in RFC791</value>
  </data>
  <data name="IPv4Type_IsInvalid_ParseLiteral" xml:space="preserve">
    <value>IPv4Type cannot parse the provided literal. The provided value is not a valid IPv4 address.</value>
  </data>
  <data name="IPv4Type_IsInvalid_ParseValue" xml:space="preserve">
    <value>IPv4Type cannot parse the provided value. The provided value is not a valid IPv4 address.</value>
  </data>
</root>
