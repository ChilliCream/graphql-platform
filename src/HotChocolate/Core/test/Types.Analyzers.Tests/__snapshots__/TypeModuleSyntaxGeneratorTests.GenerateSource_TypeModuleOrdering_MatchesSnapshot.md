# GenerateSource_TypeModuleOrdering_MatchesSnapshot

## GreenDonutDataLoader.735550c.g.cs

```csharp
// <auto-generated/>

#nullable enable
#pragma warning disable

using System;
using System.Runtime.CompilerServices;
using Microsoft.Extensions.DependencyInjection;
using GreenDonut;

namespace TestNamespace
{
    public interface IObjectByIdBDataLoader
        : global::GreenDonut.IDataLoader<int, object>
    {
    }

    public sealed partial class ObjectByIdBDataLoader
        : global::GreenDonut.DataLoaderBase<int, object>
        , IObjectByIdBDataLoader
    {
        private readonly global::System.IServiceProvider _services;

        public ObjectByIdBDataLoader(
            global::System.IServiceProvider services,
            global::GreenDonut.IBatchScheduler batchScheduler,
            global::GreenDonut.DataLoaderOptions options)
            : base(batchScheduler, options)
        {
            _services = services ??
                throw new global::System.ArgumentNullException(nameof(services));
        }

        protected override async global::System.Threading.Tasks.ValueTask FetchAsync(
            global::System.Collections.Generic.IReadOnlyList<int> keys,
            global::System.Memory<GreenDonut.Result<object?>> results,
            global::GreenDonut.DataLoaderFetchContext<object> context,
            global::System.Threading.CancellationToken ct)
        {
            var temp = await global::TestNamespace.TestBDataLoaderAttr.GetObjectByIdBAsync(keys, ct).ConfigureAwait(false);
            CopyResults(keys, results.Span, temp);
        }

        private void CopyResults(
            global::System.Collections.Generic.IReadOnlyList<int> keys,
            global::System.Span<GreenDonut.Result<object?>> results,
            global::System.Collections.Generic.IReadOnlyDictionary<int, object> resultMap)
        {
            for (var i = 0; i < keys.Count; i++)
            {
                var key = keys[i];
                if (resultMap.TryGetValue(key, out var value))
                {
                    results[i] = global::GreenDonut.Result<object?>.Resolve(value);
                }
                else
                {
                    results[i] = global::GreenDonut.Result<object?>.Resolve(default(object));
                }
            }
        }
    }

    public interface IObjectByIdADataLoader
        : global::GreenDonut.IDataLoader<int, object>
    {
    }

    public sealed partial class ObjectByIdADataLoader
        : global::GreenDonut.DataLoaderBase<int, object>
        , IObjectByIdADataLoader
    {
        private readonly global::System.IServiceProvider _services;

        public ObjectByIdADataLoader(
            global::System.IServiceProvider services,
            global::GreenDonut.IBatchScheduler batchScheduler,
            global::GreenDonut.DataLoaderOptions options)
            : base(batchScheduler, options)
        {
            _services = services ??
                throw new global::System.ArgumentNullException(nameof(services));
        }

        protected override async global::System.Threading.Tasks.ValueTask FetchAsync(
            global::System.Collections.Generic.IReadOnlyList<int> keys,
            global::System.Memory<GreenDonut.Result<object?>> results,
            global::GreenDonut.DataLoaderFetchContext<object> context,
            global::System.Threading.CancellationToken ct)
        {
            var temp = await global::TestNamespace.TestADataLoaderAttr.GetObjectByIdAAsync(keys, ct).ConfigureAwait(false);
            CopyResults(keys, results.Span, temp);
        }

        private void CopyResults(
            global::System.Collections.Generic.IReadOnlyList<int> keys,
            global::System.Span<GreenDonut.Result<object?>> results,
            global::System.Collections.Generic.IReadOnlyDictionary<int, object> resultMap)
        {
            for (var i = 0; i < keys.Count; i++)
            {
                var key = keys[i];
                if (resultMap.TryGetValue(key, out var value))
                {
                    results[i] = global::GreenDonut.Result<object?>.Resolve(value);
                }
                else
                {
                    results[i] = global::GreenDonut.Result<object?>.Resolve(default(object));
                }
            }
        }
    }
}


```

## HotChocolateResolvers.735550c.g.cs

```csharp
// <auto-generated/>

#nullable enable
#pragma warning disable

using System;
using System.Runtime.CompilerServices;
using HotChocolate;
using HotChocolate.Types;
using HotChocolate.Execution.Configuration;
using HotChocolate.Internal;

namespace TestNamespace
{
    internal static class ATestBAttrTypeResolvers
    {
        private static readonly object _sync = new object();
        private static bool _bindingsInitialized;
        public static void InitializeBindings(global::HotChocolate.Internal.IParameterBindingResolver bindingResolver)
        {
        }
    }

    internal static class ATestAAttrTypeResolvers
    {
        private static readonly object _sync = new object();
        private static bool _bindingsInitialized;
        public static void InitializeBindings(global::HotChocolate.Internal.IParameterBindingResolver bindingResolver)
        {
        }
    }
}


```

## HotChocolateTypeModule.735550c.g.cs

```csharp
// <auto-generated/>

#nullable enable
#pragma warning disable

using System;
using System.Runtime.CompilerServices;
using HotChocolate;
using HotChocolate.Types;
using HotChocolate.Execution.Configuration;

namespace Microsoft.Extensions.DependencyInjection
{
    public static partial class TestsTypesRequestExecutorBuilderExtensions
    {
        public static IRequestExecutorBuilder AddTestsTypes(this IRequestExecutorBuilder builder)
        {
            AddObjectTypeExtension_8734371<global::TestNamespace.ATestAAttr>(builder, global::TestNamespace.ATestAAttrType.Initialize);
            AddObjectTypeExtension_8734371<global::TestNamespace.ATestBAttr>(builder, global::TestNamespace.ATestBAttrType.Initialize);
            builder.AddTypeExtension<global::TestNamespace.ATestAExtAttrType>();
            builder.AddTypeExtension<global::TestNamespace.ATestAExtType>();
            builder.AddType<global::TestNamespace.ATestAType>();
            builder.AddTypeExtension<global::TestNamespace.ATestBExtAttrType>();
            builder.AddTypeExtension<global::TestNamespace.ATestBExtType>();
            builder.AddType<global::TestNamespace.ATestBType>();
            builder.AddDataLoader<global::TestNamespace.IObjectByIdADataLoader, global::TestNamespace.ObjectByIdADataLoader>();
            builder.AddDataLoader<global::TestNamespace.IObjectByIdBDataLoader, global::TestNamespace.ObjectByIdBDataLoader>();
            builder.AddDataLoader<global::TestNamespace.TestADataLoader>();
            builder.AddDataLoader<global::TestNamespace.TestBDataLoader>();
            return builder;
        }

        private static void AddObjectTypeExtension_8734371<T>(
            global::HotChocolate.Execution.Configuration.IRequestExecutorBuilder builder,
            Action<IObjectTypeDescriptor<T>> initialize)
        {
            builder.ConfigureSchema(sb =>
            {
                string typeName = typeof(T).FullName!;
                string typeKey = $"8734371_Type_ObjectType<{typeName}>";
                string hooksKey = $"8734371_Hooks_ObjectType<{typeName}>";

                if (!sb.ContextData.ContainsKey(typeKey))
                {
                    sb.AddObjectType<T>(
                        descriptor =>
                        {
                            var hooks = (global::System.Collections.Generic.List<Action<IObjectTypeDescriptor<T>>>)descriptor.Extend().Context.ContextData[hooksKey]!;
                            foreach (var configure in hooks)
                            {
                                configure(descriptor);
                            };
                        });
                    sb.ContextData.Add(typeKey, null);
                }

                if (!sb.ContextData.TryGetValue(hooksKey, out var value))
                {
                    value = new System.Collections.Generic.List<Action<IObjectTypeDescriptor<T>>>();
                    sb.ContextData.Add(hooksKey, value);
                }

                ((System.Collections.Generic.List<Action<IObjectTypeDescriptor<T>>>)value!).Add(initialize);
            });
        }
    }
}

```

## HotChocolateTypes.735550c.g.cs

```csharp
// <auto-generated/>

#nullable enable
#pragma warning disable

using System;
using System.Runtime.CompilerServices;
using HotChocolate;
using HotChocolate.Types;
using HotChocolate.Execution.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace TestNamespace
{
public static partial class ATestBAttrType
{
    internal static void Initialize(global::HotChocolate.Types.IObjectTypeDescriptor<global::TestNamespace.ATestBAttr> descriptor)
    {

        Configure(descriptor);
    }

    static partial void Configure(global::HotChocolate.Types.IObjectTypeDescriptor<global::TestNamespace.ATestBAttr> descriptor);
}

public static partial class ATestAAttrType
{
    internal static void Initialize(global::HotChocolate.Types.IObjectTypeDescriptor<global::TestNamespace.ATestAAttr> descriptor)
    {

        Configure(descriptor);
    }

    static partial void Configure(global::HotChocolate.Types.IObjectTypeDescriptor<global::TestNamespace.ATestAAttr> descriptor);
}
}


```

