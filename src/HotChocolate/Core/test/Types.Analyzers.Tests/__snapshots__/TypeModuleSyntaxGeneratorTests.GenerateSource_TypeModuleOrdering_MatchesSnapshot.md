# GenerateSource_TypeModuleOrdering_MatchesSnapshot

## GreenDonutDataLoader.735550c.g.cs

```csharp
// <auto-generated/>

#nullable enable
#pragma warning disable

using System;
using System.Runtime.CompilerServices;
using Microsoft.Extensions.DependencyInjection;
using GreenDonut;

namespace TestNamespace
{
    public interface IObjectByIdBDataLoader
        : global::GreenDonut.IDataLoader<int, object>
    {
    }

    public sealed partial class ObjectByIdBDataLoader
        : global::GreenDonut.DataLoaderBase<int, object>
        , IObjectByIdBDataLoader
    {
        private readonly global::System.IServiceProvider _services;

        public ObjectByIdBDataLoader(
            global::System.IServiceProvider services,
            global::GreenDonut.IBatchScheduler batchScheduler,
            global::GreenDonut.DataLoaderOptions options)
            : base(batchScheduler, options)
        {
            _services = services ??
                throw new global::System.ArgumentNullException(nameof(services));
        }

        protected override async global::System.Threading.Tasks.ValueTask FetchAsync(
            global::System.Collections.Generic.IReadOnlyList<int> keys,
            global::System.Memory<GreenDonut.Result<object?>> results,
            global::GreenDonut.DataLoaderFetchContext<object> context,
            global::System.Threading.CancellationToken ct)
        {
            var temp = await global::TestNamespace.TestBDataLoaderAttr.GetObjectByIdBAsync(keys, ct).ConfigureAwait(false);
            CopyResults(keys, results.Span, temp);
        }

        private void CopyResults(
            global::System.Collections.Generic.IReadOnlyList<int> keys,
            global::System.Span<GreenDonut.Result<object?>> results,
            global::System.Collections.Generic.IReadOnlyDictionary<int, object> resultMap)
        {
            for (var i = 0; i < keys.Count; i++)
            {
                var key = keys[i];
                if (resultMap.TryGetValue(key, out var value))
                {
                    results[i] = global::GreenDonut.Result<object?>.Resolve(value);
                }
                else
                {
                    results[i] = global::GreenDonut.Result<object?>.Resolve(default(object));
                }
            }
        }
    }

    public interface IObjectByIdADataLoader
        : global::GreenDonut.IDataLoader<int, object>
    {
    }

    public sealed partial class ObjectByIdADataLoader
        : global::GreenDonut.DataLoaderBase<int, object>
        , IObjectByIdADataLoader
    {
        private readonly global::System.IServiceProvider _services;

        public ObjectByIdADataLoader(
            global::System.IServiceProvider services,
            global::GreenDonut.IBatchScheduler batchScheduler,
            global::GreenDonut.DataLoaderOptions options)
            : base(batchScheduler, options)
        {
            _services = services ??
                throw new global::System.ArgumentNullException(nameof(services));
        }

        protected override async global::System.Threading.Tasks.ValueTask FetchAsync(
            global::System.Collections.Generic.IReadOnlyList<int> keys,
            global::System.Memory<GreenDonut.Result<object?>> results,
            global::GreenDonut.DataLoaderFetchContext<object> context,
            global::System.Threading.CancellationToken ct)
        {
            var temp = await global::TestNamespace.TestADataLoaderAttr.GetObjectByIdAAsync(keys, ct).ConfigureAwait(false);
            CopyResults(keys, results.Span, temp);
        }

        private void CopyResults(
            global::System.Collections.Generic.IReadOnlyList<int> keys,
            global::System.Span<GreenDonut.Result<object?>> results,
            global::System.Collections.Generic.IReadOnlyDictionary<int, object> resultMap)
        {
            for (var i = 0; i < keys.Count; i++)
            {
                var key = keys[i];
                if (resultMap.TryGetValue(key, out var value))
                {
                    results[i] = global::GreenDonut.Result<object?>.Resolve(value);
                }
                else
                {
                    results[i] = global::GreenDonut.Result<object?>.Resolve(default(object));
                }
            }
        }
    }
}


```

## HotChocolateResolvers.735550c.g.cs

```csharp
// <auto-generated/>

#nullable enable
#pragma warning disable

using System;
using System.Runtime.CompilerServices;
using HotChocolate;
using HotChocolate.Types;
using HotChocolate.Execution.Configuration;
using HotChocolate.Internal;

namespace TestNamespace
{
    internal static class ATestBAttrTypeResolvers
    {
        private static readonly object _sync = new object();
        private static bool _bindingsInitialized;
        public static void InitializeBindings(global::HotChocolate.Internal.IParameterBindingResolver bindingResolver)
        {
        }
    }

    internal static class ATestAAttrTypeResolvers
    {
        private static readonly object _sync = new object();
        private static bool _bindingsInitialized;
        public static void InitializeBindings(global::HotChocolate.Internal.IParameterBindingResolver bindingResolver)
        {
        }
    }
}


```

## HotChocolateTypeModule.735550c.g.cs

```csharp
// <auto-generated/>

#nullable enable
#pragma warning disable

using System;
using System.Runtime.CompilerServices;
using HotChocolate;
using HotChocolate.Types;
using HotChocolate.Execution.Configuration;

namespace Microsoft.Extensions.DependencyInjection
{
    public static partial class TestsTypesRequestExecutorBuilderExtensions
    {
        public static IRequestExecutorBuilder AddTestsTypes(this IRequestExecutorBuilder builder)
        {
            builder.ConfigureDescriptorContext(ctx => ctx.TypeConfiguration.TryAdd<global::TestNamespace.ATestAAttr>(
                "Tests::TestNamespace.ATestAAttrType",
                () => global::TestNamespace.ATestAAttrType.Initialize));
            builder.ConfigureDescriptorContext(ctx => ctx.TypeConfiguration.TryAdd<global::TestNamespace.ATestBAttr>(
                "Tests::TestNamespace.ATestBAttrType",
                () => global::TestNamespace.ATestBAttrType.Initialize));
            builder.AddTypeExtension<global::TestNamespace.ATestAExtAttrType>();
            builder.AddTypeExtension<global::TestNamespace.ATestAExtType>();
            builder.AddType<global::TestNamespace.ATestAType>();
            builder.AddTypeExtension<global::TestNamespace.ATestBExtAttrType>();
            builder.AddTypeExtension<global::TestNamespace.ATestBExtType>();
            builder.AddType<global::TestNamespace.ATestBType>();
            builder.AddDataLoader<global::TestNamespace.IObjectByIdADataLoader, global::TestNamespace.ObjectByIdADataLoader>();
            builder.AddDataLoader<global::TestNamespace.IObjectByIdBDataLoader, global::TestNamespace.ObjectByIdBDataLoader>();
            builder.AddDataLoader<global::TestNamespace.TestADataLoader>();
            builder.AddDataLoader<global::TestNamespace.TestBDataLoader>();
            builder.AddType<ObjectType<global::TestNamespace.ATestAAttr>>();
            builder.AddType<ObjectType<global::TestNamespace.ATestBAttr>>();
            return builder;
        }
    }
}

```

## HotChocolateTypes.735550c.g.cs

```csharp
// <auto-generated/>

#nullable enable
#pragma warning disable

using System;
using System.Runtime.CompilerServices;
using HotChocolate;
using HotChocolate.Types;
using HotChocolate.Execution.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace TestNamespace
{
public static partial class ATestBAttrType
{
    internal static void Initialize(global::HotChocolate.Types.IObjectTypeDescriptor<global::TestNamespace.ATestBAttr> descriptor)
    {

        Configure(descriptor);
    }

    static partial void Configure(global::HotChocolate.Types.IObjectTypeDescriptor<global::TestNamespace.ATestBAttr> descriptor);
}

public static partial class ATestAAttrType
{
    internal static void Initialize(global::HotChocolate.Types.IObjectTypeDescriptor<global::TestNamespace.ATestAAttr> descriptor)
    {

        Configure(descriptor);
    }

    static partial void Configure(global::HotChocolate.Types.IObjectTypeDescriptor<global::TestNamespace.ATestAAttr> descriptor);
}
}


```

