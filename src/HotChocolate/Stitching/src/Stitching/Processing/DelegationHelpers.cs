using System;
using System.Buffers;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.Linq;
using HotChocolate.Execution;
using HotChocolate.Language;
using HotChocolate.Resolvers;
using HotChocolate.Stitching.Execution;
using HotChocolate.Stitching.Processing.ScopedVariables;
using HotChocolate.Stitching.Properties;
using HotChocolate.Stitching.Utilities;
using HotChocolate.Types;
using static HotChocolate.Stitching.WellKnownContextData;

namespace HotChocolate.Stitching.Processing;

internal static class DelegationHelpers
{
    private static readonly RootScopedVariableResolver _resolvers = new();

    public static IQueryRequest CreateQuery(
        IResolverContext context,
        NameString schemaName,
        IImmutableStack<SelectionPathComponent> path,
        IImmutableStack<SelectionPathComponent> reversePath)
    {
        var fieldRewriter = new ExtractFieldQuerySyntaxRewriter(
            context.Schema,
            context.Service<IEnumerable<IQueryDelegationRewriter>>());

        OperationType operationType =
            context.Schema.IsRootType(context.ObjectType)
                ? context.Operation.Operation
                : OperationType.Query;

        ExtractedField extractedField = fieldRewriter.ExtractField(
            schemaName, context.Document, context.Operation,
            context.Selection, context.ObjectType);

        IEnumerable<ScopedVariableValue> scopedVariables =
            ResolveScopedVariables(
                context, schemaName, operationType,
                reversePath, fieldRewriter);

        IReadOnlyCollection<ScopedVariableValue> variableValues =
            CreateVariableValues(
                context, schemaName, scopedVariables,
                extractedField, fieldRewriter);

        RemoteQueryBuilder builder =
            RemoteQueryBuilder.New()
                .SetRequestField(extractedField.SyntaxNodes[0])
                .SetOperation(context.Operation.Name, operationType)
                .SetSelectionPath(path)
                .AddVariables(CreateVariableDefs(variableValues))
                .AddFragmentDefinitions(extractedField.Fragments);

        if (extractedField.SyntaxNodes.Count > 1)
        {
            for (var i = 1; i < extractedField.SyntaxNodes.Count; i++)
            {
                builder.AddAdditionalField(extractedField.SyntaxNodes[i]);
            }
        }

        DocumentNode query = builder.Build(schemaName, context.Schema.GetNameLookup());

        var requestBuilder = QueryRequestBuilder.New();

        AddVariables(requestBuilder, query, variableValues);

        OperationDefinitionNode operation =
            query.Definitions.OfType<OperationDefinitionNode>().First();

        requestBuilder
            .SetQuery(query)
            .SetOperation(operation.Name?.Value)
            .AddGlobalState(IsAutoGenerated, true);

        if (operationType is OperationType.Subscription)
        {
            requestBuilder.AddGlobalState(IsSubscription, true);
        }

        ObjectType rootType = context.Schema.GetOperationType(operationType)!;
        if (IsBatchableRequest(rootType, extractedField, path))
        {
            requestBuilder.TryAddGlobalState(IsBatchable, true);
        }

        return requestBuilder.Create();
    }

    private static bool IsBatchableRequest(
        ObjectType rootType,
        ExtractedField extractedField,
        IImmutableStack<SelectionPathComponent> path)
    {
        if (path.IsEmpty)
        {
            foreach (FieldNode field in extractedField.SyntaxNodes)
            {
                if (rootType.Fields.TryGetField(field.Name.Value, out ObjectField? rootField) &&
                    rootField.Type.Kind == TypeKind.NonNull)
                {
                    return false;
                }
            }
        }
        else
        {
            if (rootType.Fields.TryGetField(path.Peek().Name.Value, out ObjectField? rootField) &&
                rootField.Type.Kind == TypeKind.NonNull)
            {
                return false;
            }
        }

        return true;
    }

    public static object? ExtractData(
        IReadOnlyDictionary<string, object?>? data,
        IImmutableStack<SelectionPathComponent> reversePath,
        NameString fieldName)
    {
        if (data is null || data.Count == 0)
        {
            return null;
        }

        if (reversePath.IsEmpty)
        {
            return data.First().Value;
        }

        object? current = data;

        while (!reversePath.IsEmpty && current is not null)
        {
            reversePath = reversePath.Pop(out SelectionPathComponent component);

            if (current is IReadOnlyDictionary<string, object?> obj)
            {
                if (reversePath.IsEmpty)
                {
                    current = obj.First().Value;
                }
                else
                {
                    obj.TryGetValue(component.Name.Value, out current);
                }
            }
            else if (current is IList list)
            {
                var aggregated = new List<object?>();
                for (var i = 0; i < list.Count; i++)
                {
                    NameString key = reversePath.IsEmpty
                        ? fieldName
                        : component.Name.Value;

                    if (list[i] is IReadOnlyDictionary<string, object?> listObj &&
                        listObj.TryGetValue(key, out var item))
                    {
                        aggregated.Add(item);
                    }
                    else
                    {
                        aggregated.Add(null);
                    }
                }

                current = aggregated;
            }
            else
            {
                current = null;
            }
        }

        return current;
    }

    public static void ReportErrors(
        NameString schemaName,
        IResolverContext context,
        IImmutableStack<SelectionPathComponent> fetchPath,
        IEnumerable<IError> errors)
    {
        foreach (IError error in errors)
        {
            IErrorBuilder builder = ErrorBuilder
                .FromError(error)
                .SetExtension(RemoteErrorField, error.RemoveException())
                .SetExtension(SchemaNameField, schemaName.Value);

            if (error.Path is not null)
            {
                builder
                    .SetPath(RewriteErrorPath(error.Path, context.Path, fetchPath))
                    .ClearLocations()
                    .AddLocation(context.Selection.SyntaxNode);
            }
            else if (IsHttpError(error))
            {
                builder
                    .SetPath(context.Path)
                    .ClearLocations()
                    .AddLocation(context.Selection.SyntaxNode);
            }

            context.ReportError(builder.Build());
        }
    }

    private static Path RewriteErrorPath(
        Path errorPath,
        Path fieldPath,
        IImmutableStack<SelectionPathComponent> fetchPath)
    {
        var depth = errorPath.Depth + 1;
        Path[] buffer = ArrayPool<Path>.Shared.Rent(depth);
#if NET5_0_OR_GREATER
        Span<Path> paths = buffer.AsSpan()[..depth];
#else
        Span<Path> paths = buffer.AsSpan().Slice(0, depth);
#endif

        try
        {
            Path current = errorPath;

            do
            {
                paths[--depth] = current;
                current = current.Parent;
            } while (!current.IsRoot);

            depth = 0;
            while (!fetchPath.IsEmpty)
            {
                fetchPath = fetchPath.Pop(out SelectionPathComponent fp);
                if (paths[depth] is NamePathSegment np && np.Name.Equals(fp.Name.Value))
                {
                    depth++;
                }
                else
                {
                    return fieldPath;
                }
            }

#if NET5_0_OR_GREATER
            paths = depth == 0 ? paths[1..] : paths[depth..];
#else
            paths = depth == 0 ? paths.Slice(1) : paths.Slice(depth);
#endif

            if (paths.Length == 0)
            {
                return fieldPath;
            }

            current = fieldPath;

            for (var i = 0; i < paths.Length; i++)
            {
                if (paths[i] is IndexerPathSegment index)
                {
                    current = PathFactory.Instance.Append(current, index.Index);
                }
                else if (paths[i] is NamePathSegment name)
                {
                    current = PathFactory.Instance.Append(current, name.Name);
                }
            }

            return current;
        }
        finally
        {
            ArrayPool<Path>.Shared.Return(buffer);
        }
    }

    private static bool IsHttpError(IError error) =>
        error.Code == ErrorCodes.Stitching.HttpRequestException;

    public static IReadOnlyCollection<ScopedVariableValue> CreateVariableValues(
        IResolverContext context,
        NameString schemaName,
        IEnumerable<ScopedVariableValue> scopedVariables,
        ExtractedField extractedField,
        ExtractFieldQuerySyntaxRewriter rewriter)
    {
        var values = new Dictionary<string, ScopedVariableValue>();

        foreach (ScopedVariableValue value in scopedVariables)
        {
            values[value.Name] = value;
        }

        foreach (ScopedVariableValue value in ResolveUsedRequestVariables(
                     context.Schema, schemaName, extractedField,
                     context.Variables, rewriter))
        {
            values[value.Name] = value;
        }

        return values.Values;
    }

    public static IReadOnlyList<ScopedVariableValue> ResolveScopedVariables(
        IResolverContext context,
        NameString schemaName,
        OperationType operationType,
        IImmutableStack<SelectionPathComponent> reversePath,
        ExtractFieldQuerySyntaxRewriter rewriter)
    {
        var variables = new List<ScopedVariableValue>();

        IStitchingContext stitchingContext = context.Service<IStitchingContext>();
        ISchema remoteSchema = stitchingContext.GetRemoteSchema(schemaName);
        IComplexOutputType type = remoteSchema.GetOperationType(operationType)!;
        IImmutableStack<SelectionPathComponent> path = reversePath;

        while (!path.IsEmpty)
        {
            path = path.Pop(out SelectionPathComponent component);
            IOutputField field = ResolveFieldFromComponent(type, component);
            ResolveScopedVariableArguments(
                context, schemaName, component,
                field, variables, rewriter);

            if (!path.IsEmpty)
            {
                if (field.Type.NamedType() is not IComplexOutputType complexOutputType)
                {
                    throw new GraphQLException(
                        new Error(StitchingResources.DelegationMiddleware_PathElementTypeUnexpected));
                }

                type = complexOutputType;
            }
        }

        return variables;
    }

    private static IOutputField ResolveFieldFromComponent(
        IComplexOutputType type,
        SelectionPathComponent component)
    {
        if (!type.Fields.TryGetField(component.Name.Value, out IOutputField? field))
        {
            // throw helper
            throw new GraphQLException(new Error
            (
                string.Format(
                    CultureInfo.InvariantCulture,
                    StitchingResources.DelegationMiddleware_PathElementInvalid,
                    component.Name.Value,
                    type.Name)
            ));
        }

        return field;
    }

    private static void ResolveScopedVariableArguments(
        IResolverContext context,
        NameString schemaName,
        SelectionPathComponent component,
        IOutputField field,
        ICollection<ScopedVariableValue> variables,
        ExtractFieldQuerySyntaxRewriter rewriter)
    {
        foreach (ArgumentNode argument in component.Arguments)
        {
            if (!field.Arguments.TryGetField(argument.Name.Value, out IInputField? arg))
            {
                throw new QueryException(
                    ErrorBuilder.New()
                        .SetMessage(
                            StitchingResources.DelegationMiddleware_ArgumentNotFound,
                            argument.Name.Value)
                        .SetExtension("argument", argument.Name.Value)
                        .SetCode(ErrorCodes.Stitching.ArgumentNotFound)
                        .Build());
            }

            if (argument.Value is ScopedVariableNode sv)
            {
                ScopedVariableValue variable = _resolvers.Resolve(context, sv, arg.Type);
                IValueNode value = rewriter.RewriteValueNode(
                    schemaName, arg.Type, variable.Value!);
                variables.Add(variable.WithValue(value));
            }
        }
    }

    private static IEnumerable<ScopedVariableValue> ResolveUsedRequestVariables(
        ISchema schema,
        NameString schemaName,
        ExtractedField extractedField,
        IVariableValueCollection requestVariables,
        ExtractFieldQuerySyntaxRewriter rewriter)
    {
        foreach (VariableDefinitionNode variable in extractedField.Variables)
        {
            var name = variable.Variable.Name.Value;
            INamedInputType namedType = schema.GetType<INamedInputType>(
                variable.Type.NamedType().Name.Value);

            if (!requestVariables.TryGetVariable(name, out IValueNode? value))
            {
                value = NullValueNode.Default;
            }

            value = rewriter.RewriteValueNode(
                schemaName,
                (IInputType)variable.Type.ToType(namedType),
                value!);

            yield return new ScopedVariableValue
            (
                name,
                variable.Type,
                value,
                variable.DefaultValue
            );
        }
    }

    public static void AddVariables(
        IQueryRequestBuilder builder,
        DocumentNode query,
        IEnumerable<ScopedVariableValue> variableValues)
    {
        OperationDefinitionNode operation =
            query.Definitions.OfType<OperationDefinitionNode>().First();

        var usedVariables = new HashSet<string>(
            operation.VariableDefinitions.Select(t =>
                t.Variable.Name.Value));

        foreach (ScopedVariableValue variableValue in variableValues)
        {
            if (usedVariables.Contains(variableValue.Name))
            {
                builder.AddVariableValue(variableValue.Name, variableValue.Value);
            }
        }
    }

    public static IReadOnlyList<VariableDefinitionNode> CreateVariableDefs(
        IReadOnlyCollection<ScopedVariableValue> variableValues)
    {
        var definitions = new List<VariableDefinitionNode>();

        foreach (ScopedVariableValue variableValue in variableValues)
        {
            definitions.Add(new VariableDefinitionNode(
                null,
                new VariableNode(new NameNode(variableValue.Name)),
                variableValue.Type,
                variableValue.DefaultValue,
                Array.Empty<DirectiveNode>()));
        }

        return definitions;
    }
}
