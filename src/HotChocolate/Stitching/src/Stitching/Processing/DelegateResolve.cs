using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading.Tasks;
using HotChocolate.Execution;
using HotChocolate.Language;
using HotChocolate.Resolvers;
using HotChocolate.Stitching.Execution;
using HotChocolate.Stitching.Processing.ScopedVariables;
using HotChocolate.Stitching.Utilities;
using HotChocolate.Types;
using static HotChocolate.Stitching.Properties.StitchingResources;
using static HotChocolate.Stitching.WellKnownContextData;
using static HotChocolate.Stitching.Processing.DelegationHelpers;

namespace HotChocolate.Stitching.Processing;

internal sealed class DelegateResolve
{
    private readonly FieldDelegate _next;

    public DelegateResolve(FieldDelegate next)
    {
        _next = next ?? throw new ArgumentNullException(nameof(next));
    }

    public async Task InvokeAsync(IMiddlewareContext context)
    {
        DelegateDirective? delegateDirective = context.Selection.Field
            .Directives[DirectiveNames.Delegate]
            .FirstOrDefault()?.ToObject<DelegateDirective>();

        if (delegateDirective is not null)
        {
            IImmutableStack<SelectionPathComponent> path;
            IImmutableStack<SelectionPathComponent> reversePath;
            NameString targetSchema = delegateDirective.Schema;

            if (delegateDirective.Path is null)
            {
                path = ImmutableStack<SelectionPathComponent>.Empty;
                reversePath = ImmutableStack<SelectionPathComponent>.Empty;
            }
            else
            {
                path = SelectionPathParser.Parse(delegateDirective.Path);
                reversePath = ImmutableStack.CreateRange(path);
            }

            IQueryRequest request =
                CreateQuery(context, targetSchema, path, reversePath);

            IQueryResult result =
                await ExecuteQueryAsync(context, request, targetSchema).ConfigureAwait(false);

            context.SetScopedState(SchemaName, targetSchema);
            context.SetScopedState(WellKnownContextData.Path, path);
            context.SetScopedState(ReversePath, reversePath);

            context.Result = result;
        }

        await _next.Invoke(context).ConfigureAwait(false);
    }

    private static IQueryRequest CreateQuery(
        IMiddlewareContext context,
        NameString schemaName,
        IImmutableStack<SelectionPathComponent> path,
        IImmutableStack<SelectionPathComponent> reversePath)
    {
        var fieldRewriter = new ExtractFieldQuerySyntaxRewriter(
            context.Schema,
            context.Service<IEnumerable<IQueryDelegationRewriter>>());

        OperationType operationType =
            context.Schema.IsRootType(context.ObjectType)
                ? context.Operation.Operation
                : OperationType.Query;

        ExtractedField extractedField = fieldRewriter.ExtractField(
            schemaName, context.Document, context.Operation,
            context.Selection, context.ObjectType);

        IEnumerable<ScopedVariableValue> scopedVariables =
            ResolveScopedVariables(
                context, schemaName, operationType,
                reversePath, fieldRewriter);

        IReadOnlyCollection<ScopedVariableValue> variableValues =
            CreateVariableValues(
                context, schemaName, scopedVariables,
                extractedField, fieldRewriter);

        RemoteQueryBuilder builder =
            RemoteQueryBuilder.New()
                .SetRequestField(extractedField.SyntaxNodes[0])
                .SetOperation(context.Operation.Name, operationType)
                .SetSelectionPath(path)
                .AddVariables(CreateVariableDefs(variableValues))
                .AddFragmentDefinitions(extractedField.Fragments);

        if (extractedField.SyntaxNodes.Count > 1)
        {
            for (var i = 1; i < extractedField.SyntaxNodes.Count; i++)
            {
                builder.AddAdditionalField(extractedField.SyntaxNodes[i]);
            }
        }

        DocumentNode query = builder.Build(schemaName, context.Schema.GetNameLookup());

        var requestBuilder = QueryRequestBuilder.New();

        AddVariables(requestBuilder, query, variableValues);

        requestBuilder
            .SetQuery(query)
            .AddGlobalState(IsAutoGenerated, true);

        ObjectType rootType = context.Schema.GetOperationType(operationType)!;
        if (IsBatchableRequest(rootType, extractedField, path))
        {
            requestBuilder.TryAddGlobalState(IsBatchable, true);
        }

        return requestBuilder.Create();
    }

    private static bool IsBatchableRequest(
        ObjectType rootType,
        ExtractedField extractedField,
        IImmutableStack<SelectionPathComponent> path)
    {
        if (path.IsEmpty)
        {
            foreach (FieldNode field in extractedField.SyntaxNodes)
            {
                if (rootType.Fields.TryGetField(field.Name.Value, out ObjectField? rootField) &&
                    rootField.Type.Kind == TypeKind.NonNull)
                {
                    return false;
                }
            }
        }
        else
        {
            if (rootType.Fields.TryGetField(path.Peek().Name.Value, out ObjectField? rootField) &&
                rootField.Type.Kind == TypeKind.NonNull)
            {
                return false;
            }
        }

        return true;
    }

    private static async Task<IReadOnlyQueryResult> ExecuteQueryAsync(
        IResolverContext context,
        IQueryRequest request,
        string schemaName)
    {
        IExecutionResult result =
            await context.Service<IStitchingContext>().ScheduleRequestAsync(
                schemaName,
                request,
                context.RequestAborted)
                .ConfigureAwait(false);

        if (result is IReadOnlyQueryResult queryResult)
        {
            return queryResult;
        }

        throw new GraphQLException(DelegationMiddleware_OnlyQueryResults);
    }
}
