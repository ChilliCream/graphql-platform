// <auto-generated/>

#nullable enable

using System;
using System.Runtime.CompilerServices;
using System.Buffers;
using System.Diagnostics;
using System.Net.Mime;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using HotChocolate.Execution.Configuration;
using HotChocolate.Fusion;
using HotChocolate.Fusion.Composition;
using HotChocolate.Fusion.Composition.Features;
using HotChocolate.Fusion.Composition.Tooling;
using HotChocolate.Language;
using HotChocolate.Language.Visitors;
using HotChocolate.Skimmed.Serialization;
using Microsoft.Extensions.DependencyInjection;

namespace HotChocolate.Fusion.Composition.Tooling
{

    internal static class FusionGatewayConfgHelper
    {
        public static async Task ConfigureAsync(CancellationToken cancellationToken = default)
        {
            ExportSubgraphSchemaDocs();
            await EnsureSubgraphHasConfigAsync(cancellationToken);
            await ComposeAsync(cancellationToken);
        }

        private static void ExportSubgraphSchemaDocs()
        {
            var processed = new HashSet<string>();

            foreach (var gateway in new GatewayList())
            {
                foreach (var subgraph in gateway.Subgraphs)
                {
                    if (!processed.Add(subgraph.Path))
                    {
                        continue;
                    }

                    Console.WriteLine("Expoorting schema document for subgraph {0} ...", subgraph.Name);

                    var workingDirectory = System.IO.Path.GetDirectoryName(subgraph.Path)!;

                    var processStartInfo = new ProcessStartInfo
                    {
                        FileName = "dotnet",
                        Arguments = "dotnet run --no-build --no-restore -- schema export --output schema.graphql",
                        WorkingDirectory = workingDirectory,
                        UseShellExecute = false,
                        RedirectStandardOutput = true,
                        RedirectStandardError = true,
                    };

                    using (var process = Process.Start(processStartInfo)!)
                    {
                        string output = process.StandardOutput.ReadToEnd();
                        string errors = process.StandardError.ReadToEnd();

                        process.WaitForExit();

                        if (!string.IsNullOrEmpty(output))
                        {
                            Console.WriteLine(output);
                        }

                        if (!string.IsNullOrEmpty(errors))
                        {
                            Console.WriteLine(errors);
                        }

                        if (process.ExitCode != 0)
                        {
                            Console.WriteLine(
                                "{0}(1,1): error HF1002: ; Failed to export schema document for subgraph {1} ...",
                                subgraph.Path,
                                subgraph.Name);
                            Environment.Exit(-255);
                        }
                    }
                }
            }
        }

        private static async Task EnsureSubgraphHasConfigAsync(CancellationToken cancellationToken = default)
        {
            foreach (var gateway in new GatewayList())
            {
                foreach (var project in gateway.Subgraphs)
                {
                    var projectRoot = System.IO.Path.GetDirectoryName(project.Path)!;
                    var configFile = System.IO.Path.Combine(projectRoot, Defaults.ConfigFile);

                    if (File.Exists(configFile))
                    {
                        continue;
                    }

                    var config = new SubgraphConfigurationDto(project.Name);
                    var configJson = PackageHelper.FormatSubgraphConfig(config);
                    await File.WriteAllTextAsync(configFile, configJson, cancellationToken);
                }
            }
        }

        private static async Task ComposeAsync(CancellationToken cancellationToken = default)
        {
            foreach (var gateway in new GatewayList())
            {
                await ComposeGatewayAsync(gateway.Path, gateway.Subgraphs.Select(t => t.Path), cancellationToken);
            }
        }

        private static async Task ComposeGatewayAsync(
            string gatewayProject,
            IEnumerable<string> subgraphProjects,
            CancellationToken cancellationToken = default)
        {
            var gatewayDirectory = System.IO.Path.GetDirectoryName(gatewayProject)!;
            var packageFileName = System.IO.Path.Combine(gatewayDirectory, $"gateway{Extensions.FusionPackage}");
            var packageFile = new FileInfo(packageFileName);
            var settingsFileName = System.IO.Path.Combine(gatewayDirectory, "gateway-settings.json");
            var settingsFile = new FileInfo(settingsFileName);
            var subgraphDirectories = subgraphProjects.Select(t => System.IO.Path.GetDirectoryName(t)!).ToArray();

            // Ensure Gateway Project Directory Exists.
            if (!Directory.Exists(gatewayDirectory))
            {
                Directory.CreateDirectory(gatewayDirectory);
            }

            await using var package = FusionGraphPackage.Open(packageFile.FullName);
            var subgraphConfigs =
                (await package.GetSubgraphConfigurationsAsync(cancellationToken)).ToDictionary(t => t.Name);
            await ResolveSubgraphPackagesAsync(subgraphDirectories, subgraphConfigs, cancellationToken);

            using var settingsJson = settingsFile.Exists
                ? JsonDocument.Parse(await File.ReadAllTextAsync(settingsFile.FullName, cancellationToken))
                : await package.GetFusionGraphSettingsAsync(cancellationToken);
            var settings = settingsJson.Deserialize<PackageSettings>() ?? new PackageSettings();

            var features = settings.CreateFeatures();

            var composer = new FusionGraphComposer(
                settings.FusionTypePrefix,
                settings.FusionTypeSelf,
                () => new ConsoleLog());

            var fusionGraph = await composer.TryComposeAsync(subgraphConfigs.Values, features, cancellationToken);

            if (fusionGraph is null)
            {
                Console.WriteLine("Fusion graph composition failed.");
                return;
            }

            var fusionGraphDoc = Utf8GraphQLParser.Parse(SchemaFormatter.FormatAsString(fusionGraph));
            var typeNames = FusionTypeNames.From(fusionGraphDoc);
            var rewriter = new FusionGraphConfigurationToSchemaRewriter();
            var schemaDoc = (DocumentNode)rewriter.Rewrite(fusionGraphDoc, typeNames)!;

            using var updateSettingsJson = JsonSerializer.SerializeToDocument(
                settings,
                new JsonSerializerOptions(JsonSerializerDefaults.Web));

            await package.SetFusionGraphAsync(fusionGraphDoc, cancellationToken);
            await package.SetFusionGraphSettingsAsync(updateSettingsJson, cancellationToken);
            await package.SetSchemaAsync(schemaDoc, cancellationToken);

            foreach (var config in subgraphConfigs.Values)
            {
                await package.SetSubgraphConfigurationAsync(config, cancellationToken);
            }

            Console.WriteLine("Fusion graph composed.");
        }

        private static async Task ResolveSubgraphPackagesAsync(
            IReadOnlyList<string> subgraphDirectories,
            IDictionary<string, SubgraphConfiguration> subgraphConfigs,
            CancellationToken cancellationToken)
        {
            for (var i = 0; i < subgraphDirectories.Count; i++)
            {
                var path = subgraphDirectories[i];

                if (!Directory.Exists(path))
                {
                    continue;
                }

                var configFile = System.IO.Path.Combine(path, Defaults.ConfigFile);
                var schemaFile = System.IO.Path.Combine(path, Defaults.SchemaFile);
                var extensionFile = System.IO.Path.Combine(path, Defaults.ExtensionFile);

                if (!File.Exists(configFile) || !File.Exists(schemaFile))
                {
                    continue;
                }

                var conf = await PackageHelper.LoadSubgraphConfigAsync(configFile, cancellationToken);
                var schema = await File.ReadAllTextAsync(schemaFile, cancellationToken);
                var extensions = Array.Empty<string>();

                if (File.Exists(extensionFile))
                {
                    extensions = [await File.ReadAllTextAsync(extensionFile, cancellationToken),];
                }

                subgraphConfigs[conf.Name] =
                    new SubgraphConfiguration(
                        conf.Name,
                        schema,
                        extensions,
                        conf.Clients,
                        conf.Extensions);
            }
        }
    }

    file static class Defaults
    {
        public const string SchemaFile = "schema.graphql";
        public const string ExtensionFile = "schema.extensions.graphql";
        public const string ConfigFile = "subgraph-config.json";
    }

    file static class Extensions
    {
        public const string FusionPackage = ".fgp";
    }

    file class PackageSettings
    {
        private Feature? _reEncodeIds;
        private Feature? _nodeField;
        private TagDirective? _tagDirective;
        private Transport? _transport;

        [JsonPropertyName("fusionTypePrefix")]
        [JsonPropertyOrder(10)]
        public string? FusionTypePrefix { get; set; }

        [JsonPropertyName("fusionTypeSelf")]
        [JsonPropertyOrder(11)]
        public bool FusionTypeSelf { get; set; }

        public Transport Transport
        {
            get => _transport ??= new();
            set => _transport = value;
        }

        [JsonPropertyName("nodeField")]
        [JsonPropertyOrder(12)]
        public Feature NodeField
        {
            get => _nodeField ??= new();
            set => _nodeField = value;
        }

        [JsonPropertyName("reEncodeIds")]
        [JsonPropertyOrder(13)]
        public Feature ReEncodeIds
        {
            get => _reEncodeIds ??= new();
            set => _reEncodeIds = value;
        }

        [JsonPropertyName("tagDirective")]
        [JsonPropertyOrder(14)]
        public TagDirective TagDirective
        {
            get => _tagDirective ??= new();
            set => _tagDirective = value;
        }

        public FusionFeatureCollection CreateFeatures()
        {
            var features = new List<IFusionFeature>
            {
                new TransportFeature
                {
                    DefaultClientName = Transport.DefaultClientName,
                },
            };

            if (NodeField.Enabled)
            {
                features.Add(FusionFeatures.NodeField);
            }

            if (ReEncodeIds.Enabled)
            {
                features.Add(FusionFeatures.ReEncodeIds);
            }

            if (TagDirective.Enabled)
            {
                features.Add(
                    FusionFeatures.TagDirective(
                        TagDirective.Exclude,
                        TagDirective.MakePublic));
            }

            return new FusionFeatureCollection(features);
        }
    }

    file class Feature
    {
        [JsonPropertyName("enabled")]
        [JsonPropertyOrder(10)]
        public bool Enabled { get; set; }
    }

    file sealed class TagDirective : Feature
    {
        private string[]? _exclude;

        [JsonPropertyName("makePublic")]
        [JsonPropertyOrder(100)]
        public bool MakePublic { get; set; }

        [JsonPropertyName("exclude")]
        [JsonPropertyOrder(101)]
        public string[] Exclude
        {
            get => _exclude ?? Array.Empty<string>();
            set => _exclude = value;
        }
    }

    file sealed class Transport
    {
        [JsonPropertyName("defaultClientName")]
        [JsonPropertyOrder(10)]
        public string? DefaultClientName { get; set; } = "Fusion";
    }

    file sealed class ConsoleLog : ICompositionLog
    {
        public bool HasErrors { get; private set; }

        public void Write(LogEntry e)
        {
            if (e.Severity is LogSeverity.Error)
            {
                HasErrors = true;
            }

            if (e.Code is null)
            {
                Console.WriteLine($"{e.Severity}: {e.Message}");
            }
            else if (e.Coordinate is null)
            {
                Console.WriteLine($"{e.Severity}: {e.Code} {e.Message}");
            }
            else
            {
                Console.WriteLine($"{e.Severity}: {e.Code} {e.Message} {e.Coordinate}");
            }
        }
    }

    file sealed class SubgraphConfigurationDto(
        string name,
        IReadOnlyList<IClientConfiguration>? clients = null,
        JsonElement? extensions = null)
    {
        public string Name { get; } = name;

        public IReadOnlyList<IClientConfiguration> Clients { get; } = clients ?? Array.Empty<IClientConfiguration>();

        public JsonElement? Extensions { get; } = extensions;
    }

    file static class PackageHelper
    {
        public static async Task<SubgraphConfigurationDto> LoadSubgraphConfigAsync(
            string filename,
            CancellationToken ct)
        {
            await using var stream = File.OpenRead(filename);
            return await ParseSubgraphConfigAsync(stream, ct);
        }

        private static async Task<SubgraphConfigurationDto> ParseSubgraphConfigAsync(
            Stream stream,
            CancellationToken ct)
        {
            using var document = await JsonDocument.ParseAsync(stream, cancellationToken: ct);
            var configs = new List<IClientConfiguration>();
            var subgraph = default(string?);
            var extensions = default(JsonElement?);

            foreach (var property in document.RootElement.EnumerateObject())
            {
                switch (property.Name)
                {
                    case "subgraph":
                        subgraph = property.Value.GetString();
                        break;

                    case "http":
                        configs.Add(ReadHttpClientConfiguration(property.Value));
                        break;

                    case "websocket":
                        configs.Add(ReadWebSocketClientConfiguration(property.Value));
                        break;

                    case "extensions":
                        extensions = property.Value.SafeClone();
                        break;

                    default:
                        throw new NotSupportedException(
                            $"Configuration property `{property.Value}` is not supported.");
                }
            }

            if (string.IsNullOrEmpty(subgraph))
            {
                throw new InvalidOperationException("No subgraph name was specified.");
            }

            return new SubgraphConfigurationDto(subgraph, configs, extensions);
        }

        private static HttpClientConfiguration ReadHttpClientConfiguration(
            JsonElement element)
        {
            var baseAddress = new Uri(element.GetProperty("baseAddress").GetString()!);
            var clientName = default(string?);

            if (element.TryGetProperty("clientName", out var clientNameElement))
            {
                clientName = clientNameElement.GetString();
            }

            return new HttpClientConfiguration(baseAddress, clientName);
        }

        private static WebSocketClientConfiguration ReadWebSocketClientConfiguration(
            JsonElement element)
        {
            var baseAddress = new Uri(element.GetProperty("baseAddress").GetString()!);
            var clientName = default(string?);

            if (element.TryGetProperty("clientName", out var clientNameElement))
            {
                clientName = clientNameElement.GetString();
            }

            return new WebSocketClientConfiguration(baseAddress, clientName);
        }

        private static JsonElement SafeClone(this JsonElement element)
        {
            var writer = new ArrayBufferWriter<byte>();
            using var jsonWriter = new Utf8JsonWriter(writer);

            element.WriteTo(jsonWriter);
            jsonWriter.Flush();
            var reader = new Utf8JsonReader(writer.WrittenSpan, true, default);

            return JsonElement.ParseValue(ref reader);
        }

        public static string FormatSubgraphConfig(
            SubgraphConfigurationDto subgraphConfig)
        {
            var buffer = new ArrayBufferWriter<byte>();
            using var writer = new Utf8JsonWriter(buffer);

            writer.WriteStartObject();
            writer.WriteString("subgraph", subgraphConfig.Name);

            foreach (var client in subgraphConfig.Clients)
            {
                switch (client)
                {
                    case HttpClientConfiguration config:
                        writer.WriteStartObject("http");
                        writer.WriteString("baseAddress", config.BaseAddress.ToString());

                        if (config.ClientName is not null)
                        {
                            writer.WriteString("clientName", config.ClientName);
                        }

                        writer.WriteEndObject();
                        break;

                    case WebSocketClientConfiguration config:
                        writer.WriteStartObject("websocket");
                        writer.WriteString("baseAddress", config.BaseAddress.ToString());

                        if (config.ClientName is not null)
                        {
                            writer.WriteString("clientName", config.ClientName);
                        }

                        writer.WriteEndObject();
                        break;

                    default:
                        throw new ArgumentOutOfRangeException(nameof(client));
                }
            }

            if (subgraphConfig.Extensions is not null)
            {
                writer.WritePropertyName("extensions");
                subgraphConfig.Extensions.Value.WriteTo(writer);
            }

            writer.WriteEndObject();
            writer.Flush();

            return Encoding.UTF8.GetString(buffer.WrittenSpan);
        }
    }

    file sealed class FusionGraphConfigurationToSchemaRewriter
        : SyntaxRewriter<FusionTypeNames>
    {
        public DocumentNode Rewrite(DocumentNode fusionGraph)
        {
            var typeNames = FusionTypeNames.From(fusionGraph);
            var schemaDoc = (DocumentNode?)Rewrite(fusionGraph, typeNames);

            if (schemaDoc is null)
            {
                throw new InvalidOperationException();
            }

            return schemaDoc;
        }

        protected override DirectiveNode? RewriteDirective(DirectiveNode node, FusionTypeNames context)
            => context.IsFusionDirective(node.Name.Value)
                ? null
                : base.RewriteDirective(node, context);
    }

    file sealed class SubgraphInfo(string name, string path, string variableName)
    {
        public string Name { get; } = name;

        public string Path { get; } = path;

        public string VariableName { get; } = variableName;

        public static SubgraphInfo Create<TProject>(string name, string variableName)
            where TProject : IProjectMetadata, new()
            => new(name, new TProject().ProjectPath, variableName);
    }

    file sealed class GatewayInfo(string name, string path, IReadOnlyList<SubgraphInfo> subgraphs)
    {
        public string Name { get; } = name;

        public string Path { get; } = path;

        public IReadOnlyList<SubgraphInfo> Subgraphs { get; } = subgraphs;

        public static GatewayInfo Create<TProject>(string name, params SubgraphInfo[] projects)
            where TProject : IProjectMetadata, new()
            => new(name, new TProject().ProjectPath, projects);
    }
}

namespace Aspire.Hosting
{
    public static class Extensions
    {
        public static DistributedApplication Compose(this DistributedApplication application)
        {
            var options = application.Services.GetRequiredService<DistributedApplicationOptions>();

            if (options.Args is ["compose"])
            {
                FusionGatewayConfgHelper.ConfigureAsync().Wait();
                Environment.Exit(0);
            }

            return application;
        }
    }
}

namespace HotChocolate.Fusion.Composition.Tooling
{
file class GatewayList : List<GatewayInfo>
{
    public GatewayList()
        : base(
        [
            GatewayInfo.Create<global::Projects.eShop_Gateway>(
                "gateway",
                SubgraphInfo.Create<global::Projects.eShop_Purchase_API>("purchase-api", "purchaseApi"),
                SubgraphInfo.Create<global::Projects.eShop_Ordering_API>("ordering-api", "orderingApi"),
                SubgraphInfo.Create<global::Projects.eShop_Catalog_API>("catalog-api", "catalogApi"),
                SubgraphInfo.Create<global::Projects.eShop_Identity_API>("identity-api", "identityApi"),
                SubgraphInfo.Create<global::Projects.eShop_Basket_API>("basket-api", "basketApi"))
        ]) { }
}
}