<?xml version="1.0" encoding="utf-8"?>

<root>
    <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
        <xsd:element name="root" msdata:IsDataSet="true">
            
        </xsd:element>
    </xsd:schema>
    <resheader name="resmimetype">
        <value>text/microsoft-resx</value>
    </resheader>
    <resheader name="version">
        <value>1.3</value>
    </resheader>
    <resheader name="reader">
        <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
    </resheader>
    <resheader name="writer">
        <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
    </resheader>
    <data name="CliCode" xml:space="preserve">
        <value>using System;
using System.Runtime.CompilerServices;
using System.Buffers;
using System.Diagnostics;
using System.Net.Mime;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using HotChocolate.Execution.Configuration;
using HotChocolate.Fusion;
using HotChocolate.Fusion.Composition;
using HotChocolate.Fusion.Composition.Features;
using HotChocolate.Fusion.Composition.Tooling;
using HotChocolate.Language;
using HotChocolate.Language.Visitors;
using HotChocolate.Skimmed.Serialization;
using Microsoft.Extensions.DependencyInjection;

namespace HotChocolate.Fusion.Composition.Tooling
{

    internal static class FusionGatewayConfgHelper
    {
        public static async Task ConfigureAsync(CancellationToken cancellationToken = default)
        {
            ExportSubgraphSchemaDocs();
            await EnsureSubgraphHasConfigAsync(cancellationToken);
            await ComposeAsync(cancellationToken);
        }

        private static void ExportSubgraphSchemaDocs()
        {
            var processed = new HashSet&lt;string&gt;();

            foreach (var gateway in new GatewayList())
            {
                foreach (var subgraph in gateway.Subgraphs)
                {
                    if (!processed.Add(subgraph.Path))
                    {
                        continue;
                    }

                    Console.WriteLine("Expoorting schema document for subgraph {0} ...", subgraph.Name);

                    var workingDirectory = System.IO.Path.GetDirectoryName(subgraph.Path)!;

                    var processStartInfo = new ProcessStartInfo
                    {
                        FileName = "dotnet",
                        Arguments = "dotnet run --no-build --no-restore -- schema export --output schema.graphql",
                        WorkingDirectory = workingDirectory,
                        UseShellExecute = false,
                        RedirectStandardOutput = true,
                        RedirectStandardError = true,
                    };

                    using (var process = Process.Start(processStartInfo)!)
                    {
                        string output = process.StandardOutput.ReadToEnd();
                        string errors = process.StandardError.ReadToEnd();

                        process.WaitForExit();

                        if (!string.IsNullOrEmpty(output))
                        {
                            Console.WriteLine(output);
                        }

                        if (!string.IsNullOrEmpty(errors))
                        {
                            Console.WriteLine(errors);
                        }

                        if (process.ExitCode != 0)
                        {
                            Console.WriteLine(
                                "{0}(1,1): error HF1002: ; Failed to export schema document for subgraph {1} ...",
                                subgraph.Path,
                                subgraph.Name);
                            Environment.Exit(-255);
                        }
                    }
                }
            }
        }

        private static async Task EnsureSubgraphHasConfigAsync(CancellationToken cancellationToken = default)
        {
            foreach (var gateway in new GatewayList())
            {
                foreach (var project in gateway.Subgraphs)
                {
                    var projectRoot = System.IO.Path.GetDirectoryName(project.Path)!;
                    var configFile = System.IO.Path.Combine(projectRoot, Defaults.ConfigFile);

                    if (File.Exists(configFile))
                    {
                        continue;
                    }

                    var config = new SubgraphConfigurationDto(project.Name);
                    var configJson = PackageHelper.FormatSubgraphConfig(config);
                    await File.WriteAllTextAsync(configFile, configJson, cancellationToken);
                }
            }
        }

        private static async Task ComposeAsync(CancellationToken cancellationToken = default)
        {
            foreach (var gateway in new GatewayList())
            {
                await ComposeGatewayAsync(gateway.Path, gateway.Subgraphs.Select(t =&gt; t.Path), cancellationToken);
            }
        }

        private static async Task ComposeGatewayAsync(
            string gatewayProject,
            IEnumerable&lt;string&gt; subgraphProjects,
            CancellationToken cancellationToken = default)
        {
            var gatewayDirectory = System.IO.Path.GetDirectoryName(gatewayProject)!;
            var packageFileName = System.IO.Path.Combine(gatewayDirectory, $"gateway{Extensions.FusionPackage}");
            var packageFile = new FileInfo(packageFileName);
            var settingsFileName = System.IO.Path.Combine(gatewayDirectory, "gateway-settings.json");
            var settingsFile = new FileInfo(settingsFileName);
            var subgraphDirectories = subgraphProjects.Select(t =&gt; System.IO.Path.GetDirectoryName(t)!).ToArray();

            // Ensure Gateway Project Directory Exists.
            if (!Directory.Exists(gatewayDirectory))
            {
                Directory.CreateDirectory(gatewayDirectory);
            }

            await using var package = FusionGraphPackage.Open(packageFile.FullName);
            var subgraphConfigs =
                (await package.GetSubgraphConfigurationsAsync(cancellationToken)).ToDictionary(t =&gt; t.Name);
            await ResolveSubgraphPackagesAsync(subgraphDirectories, subgraphConfigs, cancellationToken);

            using var settingsJson = settingsFile.Exists
                ? JsonDocument.Parse(await File.ReadAllTextAsync(settingsFile.FullName, cancellationToken))
                : await package.GetFusionGraphSettingsAsync(cancellationToken);
            var settings = settingsJson.Deserialize&lt;PackageSettings&gt;() ?? new PackageSettings();

            var features = settings.CreateFeatures();

            var composer = new FusionGraphComposer(
                settings.FusionTypePrefix,
                settings.FusionTypeSelf,
                () =&gt; new ConsoleLog());

            var fusionGraph = await composer.TryComposeAsync(subgraphConfigs.Values, features, cancellationToken);

            if (fusionGraph is null)
            {
                Console.WriteLine("Fusion graph composition failed.");
                return;
            }

            var fusionGraphDoc = Utf8GraphQLParser.Parse(SchemaFormatter.FormatAsString(fusionGraph));
            var typeNames = FusionTypeNames.From(fusionGraphDoc);
            var rewriter = new FusionGraphConfigurationToSchemaRewriter();
            var schemaDoc = (DocumentNode)rewriter.Rewrite(fusionGraphDoc, typeNames)!;

            using var updateSettingsJson = JsonSerializer.SerializeToDocument(
                settings,
                new JsonSerializerOptions(JsonSerializerDefaults.Web));

            await package.SetFusionGraphAsync(fusionGraphDoc, cancellationToken);
            await package.SetFusionGraphSettingsAsync(updateSettingsJson, cancellationToken);
            await package.SetSchemaAsync(schemaDoc, cancellationToken);

            foreach (var config in subgraphConfigs.Values)
            {
                await package.SetSubgraphConfigurationAsync(config, cancellationToken);
            }

            Console.WriteLine("Fusion graph composed.");
        }

        private static async Task ResolveSubgraphPackagesAsync(
            IReadOnlyList&lt;string&gt; subgraphDirectories,
            IDictionary&lt;string, SubgraphConfiguration&gt; subgraphConfigs,
            CancellationToken cancellationToken)
        {
            for (var i = 0; i &lt; subgraphDirectories.Count; i++)
            {
                var path = subgraphDirectories[i];

                if (!Directory.Exists(path))
                {
                    continue;
                }

                var configFile = System.IO.Path.Combine(path, Defaults.ConfigFile);
                var schemaFile = System.IO.Path.Combine(path, Defaults.SchemaFile);
                var extensionFile = System.IO.Path.Combine(path, Defaults.ExtensionFile);

                if (!File.Exists(configFile) || !File.Exists(schemaFile))
                {
                    continue;
                }

                var conf = await PackageHelper.LoadSubgraphConfigAsync(configFile, cancellationToken);
                var schema = await File.ReadAllTextAsync(schemaFile, cancellationToken);
                var extensions = Array.Empty&lt;string&gt;();

                if (File.Exists(extensionFile))
                {
                    extensions = [await File.ReadAllTextAsync(extensionFile, cancellationToken),];
                }

                subgraphConfigs[conf.Name] =
                    new SubgraphConfiguration(
                        conf.Name,
                        schema,
                        extensions,
                        conf.Clients,
                        conf.Extensions);
            }
        }
    }

    file static class Defaults
    {
        public const string SchemaFile = "schema.graphql";
        public const string ExtensionFile = "schema.extensions.graphql";
        public const string ConfigFile = "subgraph-config.json";
    }

    file static class Extensions
    {
        public const string FusionPackage = ".fgp";
    }

    file class PackageSettings
    {
        private Feature? _reEncodeIds;
        private Feature? _nodeField;
        private TagDirective? _tagDirective;
        private Transport? _transport;

        [JsonPropertyName("fusionTypePrefix")]
        [JsonPropertyOrder(10)]
        public string? FusionTypePrefix { get; set; }

        [JsonPropertyName("fusionTypeSelf")]
        [JsonPropertyOrder(11)]
        public bool FusionTypeSelf { get; set; }

        public Transport Transport
        {
            get =&gt; _transport ??= new();
            set =&gt; _transport = value;
        }

        [JsonPropertyName("nodeField")]
        [JsonPropertyOrder(12)]
        public Feature NodeField
        {
            get =&gt; _nodeField ??= new();
            set =&gt; _nodeField = value;
        }

        [JsonPropertyName("reEncodeIds")]
        [JsonPropertyOrder(13)]
        public Feature ReEncodeIds
        {
            get =&gt; _reEncodeIds ??= new();
            set =&gt; _reEncodeIds = value;
        }

        [JsonPropertyName("tagDirective")]
        [JsonPropertyOrder(14)]
        public TagDirective TagDirective
        {
            get =&gt; _tagDirective ??= new();
            set =&gt; _tagDirective = value;
        }

        public FusionFeatureCollection CreateFeatures()
        {
            var features = new List&lt;IFusionFeature&gt;
            {
                new TransportFeature
                {
                    DefaultClientName = Transport.DefaultClientName,
                },
            };

            if (NodeField.Enabled)
            {
                features.Add(FusionFeatures.NodeField);
            }

            if (ReEncodeIds.Enabled)
            {
                features.Add(FusionFeatures.ReEncodeIds);
            }

            if (TagDirective.Enabled)
            {
                features.Add(
                    FusionFeatures.TagDirective(
                        TagDirective.Exclude,
                        TagDirective.MakePublic));
            }

            return new FusionFeatureCollection(features);
        }
    }

    file class Feature
    {
        [JsonPropertyName("enabled")]
        [JsonPropertyOrder(10)]
        public bool Enabled { get; set; }
    }

    file sealed class TagDirective : Feature
    {
        private string[]? _exclude;

        [JsonPropertyName("makePublic")]
        [JsonPropertyOrder(100)]
        public bool MakePublic { get; set; }

        [JsonPropertyName("exclude")]
        [JsonPropertyOrder(101)]
        public string[] Exclude
        {
            get =&gt; _exclude ?? Array.Empty&lt;string&gt;();
            set =&gt; _exclude = value;
        }
    }

    file sealed class Transport
    {
        [JsonPropertyName("defaultClientName")]
        [JsonPropertyOrder(10)]
        public string? DefaultClientName { get; set; } = "Fusion";
    }

    file sealed class ConsoleLog : ICompositionLog
    {
        public bool HasErrors { get; private set; }

        public void Write(LogEntry e)
        {
            if (e.Severity is LogSeverity.Error)
            {
                HasErrors = true;
            }

            if (e.Code is null)
            {
                Console.WriteLine($"{e.Severity}: {e.Message}");
            }
            else if (e.Coordinate is null)
            {
                Console.WriteLine($"{e.Severity}: {e.Code} {e.Message}");
            }
            else
            {
                Console.WriteLine($"{e.Severity}: {e.Code} {e.Message} {e.Coordinate}");
            }
        }
    }

    file sealed class SubgraphConfigurationDto(
        string name,
        IReadOnlyList&lt;IClientConfiguration&gt;? clients = null,
        JsonElement? extensions = null)
    {
        public string Name { get; } = name;

        public IReadOnlyList&lt;IClientConfiguration&gt; Clients { get; } = clients ?? Array.Empty&lt;IClientConfiguration&gt;();

        public JsonElement? Extensions { get; } = extensions;
    }

    file static class PackageHelper
    {
        public static async Task&lt;SubgraphConfigurationDto&gt; LoadSubgraphConfigAsync(
            string filename,
            CancellationToken ct)
        {
            await using var stream = File.OpenRead(filename);
            return await ParseSubgraphConfigAsync(stream, ct);
        }

        private static async Task&lt;SubgraphConfigurationDto&gt; ParseSubgraphConfigAsync(
            Stream stream,
            CancellationToken ct)
        {
            using var document = await JsonDocument.ParseAsync(stream, cancellationToken: ct);
            var configs = new List&lt;IClientConfiguration&gt;();
            var subgraph = default(string?);
            var extensions = default(JsonElement?);

            foreach (var property in document.RootElement.EnumerateObject())
            {
                switch (property.Name)
                {
                    case "subgraph":
                        subgraph = property.Value.GetString();
                        break;

                    case "http":
                        configs.Add(ReadHttpClientConfiguration(property.Value));
                        break;

                    case "websocket":
                        configs.Add(ReadWebSocketClientConfiguration(property.Value));
                        break;

                    case "extensions":
                        extensions = property.Value.SafeClone();
                        break;

                    default:
                        throw new NotSupportedException(
                            $"Configuration property `{property.Value}` is not supported.");
                }
            }

            if (string.IsNullOrEmpty(subgraph))
            {
                throw new InvalidOperationException("No subgraph name was specified.");
            }

            return new SubgraphConfigurationDto(subgraph, configs, extensions);
        }

        private static HttpClientConfiguration ReadHttpClientConfiguration(
            JsonElement element)
        {
            var baseAddress = new Uri(element.GetProperty("baseAddress").GetString()!);
            var clientName = default(string?);

            if (element.TryGetProperty("clientName", out var clientNameElement))
            {
                clientName = clientNameElement.GetString();
            }

            return new HttpClientConfiguration(baseAddress, clientName);
        }

        private static WebSocketClientConfiguration ReadWebSocketClientConfiguration(
            JsonElement element)
        {
            var baseAddress = new Uri(element.GetProperty("baseAddress").GetString()!);
            var clientName = default(string?);

            if (element.TryGetProperty("clientName", out var clientNameElement))
            {
                clientName = clientNameElement.GetString();
            }

            return new WebSocketClientConfiguration(baseAddress, clientName);
        }

        private static JsonElement SafeClone(this JsonElement element)
        {
            var writer = new ArrayBufferWriter&lt;byte&gt;();
            using var jsonWriter = new Utf8JsonWriter(writer);

            element.WriteTo(jsonWriter);
            jsonWriter.Flush();
            var reader = new Utf8JsonReader(writer.WrittenSpan, true, default);

            return JsonElement.ParseValue(ref reader);
        }

        public static string FormatSubgraphConfig(
            SubgraphConfigurationDto subgraphConfig)
        {
            var buffer = new ArrayBufferWriter&lt;byte&gt;();
            using var writer = new Utf8JsonWriter(buffer);

            writer.WriteStartObject();
            writer.WriteString("subgraph", subgraphConfig.Name);

            foreach (var client in subgraphConfig.Clients)
            {
                switch (client)
                {
                    case HttpClientConfiguration config:
                        writer.WriteStartObject("http");
                        writer.WriteString("baseAddress", config.BaseAddress.ToString());

                        if (config.ClientName is not null)
                        {
                            writer.WriteString("clientName", config.ClientName);
                        }

                        writer.WriteEndObject();
                        break;

                    case WebSocketClientConfiguration config:
                        writer.WriteStartObject("websocket");
                        writer.WriteString("baseAddress", config.BaseAddress.ToString());

                        if (config.ClientName is not null)
                        {
                            writer.WriteString("clientName", config.ClientName);
                        }

                        writer.WriteEndObject();
                        break;

                    default:
                        throw new ArgumentOutOfRangeException(nameof(client));
                }
            }

            if (subgraphConfig.Extensions is not null)
            {
                writer.WritePropertyName("extensions");
                subgraphConfig.Extensions.Value.WriteTo(writer);
            }

            writer.WriteEndObject();
            writer.Flush();

            return Encoding.UTF8.GetString(buffer.WrittenSpan);
        }
    }

    file sealed class FusionGraphConfigurationToSchemaRewriter
        : SyntaxRewriter&lt;FusionTypeNames&gt;
    {
        public DocumentNode Rewrite(DocumentNode fusionGraph)
        {
            var typeNames = FusionTypeNames.From(fusionGraph);
            var schemaDoc = (DocumentNode?)Rewrite(fusionGraph, typeNames);

            if (schemaDoc is null)
            {
                throw new InvalidOperationException();
            }

            return schemaDoc;
        }

        protected override DirectiveNode? RewriteDirective(DirectiveNode node, FusionTypeNames context)
            =&gt; context.IsFusionDirective(node.Name.Value)
                ? null
                : base.RewriteDirective(node, context);
    }

    file sealed class SubgraphInfo(string name, string path, string variableName)
    {
        public string Name { get; } = name;

        public string Path { get; } = path;

        public string VariableName { get; } = variableName;

        public static SubgraphInfo Create&lt;TProject&gt;(string name, string variableName)
            where TProject : IProjectMetadata, new()
            =&gt; new(name, new TProject().ProjectPath, variableName);
    }

    file sealed class GatewayInfo(string name, string path, IReadOnlyList&lt;SubgraphInfo&gt; subgraphs)
    {
        public string Name { get; } = name;

        public string Path { get; } = path;

        public IReadOnlyList&lt;SubgraphInfo&gt; Subgraphs { get; } = subgraphs;

        public static GatewayInfo Create&lt;TProject&gt;(string name, params SubgraphInfo[] projects)
            where TProject : IProjectMetadata, new()
            =&gt; new(name, new TProject().ProjectPath, projects);
    }
}</value>
    </data>
    <data name="Extensions" xml:space="preserve">
        <value>using Microsoft.Extensions.DependencyInjection;

namespace Aspire.Hosting
{
    internal static class FusionExtensions
    {
        public static DistributedApplication Compose(this DistributedApplication application)
        {
            var options = application.Services.GetRequiredService&lt;DistributedApplicationOptions&gt;();

            if (options.Args is ["compose"])
            {
                global::HotChocolate.Fusion.Composition.Tooling.FusionGatewayConfgHelper.ConfigureAsync().Wait();
                Environment.Exit(0);
            }

            return application;
        }

        public static IResourceBuilder&lt;FusionGatewayResource&gt; AddFusionGateway&lt;TProject&gt;(
            this IDistributedApplicationBuilder builder,
            string name)
            where TProject : IProjectMetadata, new()
            =&gt; new FusionGatewayResourceBuilder(builder.AddProject&lt;TProject&gt;(name));

        public static IResourceBuilder&lt;FusionGatewayResource&gt; WithSubgraph(
            this IResourceBuilder&lt;FusionGatewayResource&gt; builder,
            IResourceBuilder&lt;ProjectResource&gt; subgraphProject)
            =&gt; builder.WithReference(subgraphProject.GetEndpoint("http"));

        public static IResourceBuilder&lt;FusionGatewayResource&gt; WithSubgraph(
            this IResourceBuilder&lt;FusionGatewayResource&gt; builder,
            EndpointReference subgraphEndpoint)
            =&gt; builder.WithReference(subgraphEndpoint);
    }

    internal sealed class FusionGatewayResource(ProjectResource projectResource)
        : Resource(projectResource.Name)
            , IResourceWithEnvironment
            , IResourceWithServiceDiscovery
    {
        public ProjectResource ProjectResource { get; } = projectResource;
    }

    internal sealed class FusionGatewayResourceBuilder(
        IResourceBuilder&lt;ProjectResource&gt; projectResourceBuilder)
        : IResourceBuilder&lt;FusionGatewayResource&gt;
    {
        public IResourceBuilder&lt;FusionGatewayResource&gt; WithAnnotation&lt;TAnnotation&gt;(TAnnotation annotation)
            where TAnnotation : IResourceAnnotation
        {
            projectResourceBuilder.WithAnnotation(annotation);
            return this;
        }

        public IDistributedApplicationBuilder ApplicationBuilder =&gt; projectResourceBuilder.ApplicationBuilder;

        public FusionGatewayResource Resource { get; } = new(projectResourceBuilder.Resource);
    }
}
</value>
    </data>
</root>