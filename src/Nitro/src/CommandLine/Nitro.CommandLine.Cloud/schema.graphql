schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

interface ApiChangeLog implements WorkspaceChangeLog {
  apiId: ID!
  changedAt: DateTime!
  changedBy: UserInfo!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

interface ApiDocumentChangeLog implements WorkspaceChangeLog {
  apiId: ID!
  changedAt: DateTime!
  changedBy: UserInfo!
  documentId: ID!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

interface ClientVersionPublishError {
  message: String!
}

interface ClientVersionPublishResult {
  state: ProcessingState!
}

interface ClientVersionValidationError {
  message: String!
}

interface ClientVersionValidationResult {
  state: ProcessingState!
}

interface Deployment {
  approval: DeploymentApproval
  createdAt: DateTime!
  id: ID!
  logs: [DeploymentLog!]!
  status: DeploymentStatus!
  tag: String!
}

interface DeploymentLog {
  message: String!
  timestamp: DateTime!
}

interface DocumentChangeLog implements WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  documentId: ID!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

interface EnvironmentChangeLog implements WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  environmentId: ID!
  id: ID!
  name: String!
  version: Version!
  workspaceId: ID!
}

interface Error {
  message: String!
}

interface FusionConfigurationPublishingError {
  message: String!
}

interface FusionConfigurationPublishingResult {
  state: ProcessingState!
}

interface FusionConfigurationValidationError {
  message: String!
}

"The node interface is implemented by entities that have a global unique identifier."
interface Node {
  id: ID!
}

interface OpenTelemetryAttribute {
  key: String!
}

interface OpenTelemetrySpan {
  api: Api
  clockSkew: Float
  duration: Float!
  epoch: Float!
  events: [OpenTelemetryTraceEvent!]!
  links: [OpenTelemetryTraceLink!]!
  parentSpanId: String!
  resourceAttributes: [Attribute!]!
  spanAttributes: [Attribute!]!
  spanId: String!
  spanKind: String!
  spanName: String!
  stage: Stage
  statusCode: String!
  statusMessage: String!
  traceId: String!
  traceState: String!
}

interface ProcessingError {
  message: String!
}

interface SchemaChange {
  severity: SchemaChangeSeverity!
}

interface SchemaVersionPublishError {
  message: String!
}

interface SchemaVersionPublishResult {
  state: ProcessingState!
}

interface SchemaVersionValidationError {
  message: String!
}

interface SchemaVersionValidationResult {
  state: ProcessingState!
}

interface StageChangeLog {
  changedAt: DateTime!
  id: ID!
  kind: StageChangeLogKind!
  tag: String!
}

interface Subgraph {
  api: Api
  id: ID!
  name: String!
}

interface WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  id: ID!
  version: Version!
  workspaceId: ID!
}

type AfterStageCondition {
  afterStage: Stage
}

type Api implements Node {
  clients("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): ClientsConnection
  createdAt: DateTime!
  createdBy: UserInfo!
  documents("Returns the elements in the list that come after the specified cursor." after: Version "Returns the first _n_ elements from the list." first: Int): ApiDocumentConnection
  httpConnection: ApiHttpConnection
  id: ID!
  kind: ApiKind
  mockSchemas("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): MockSchemasConnection
  modifiedAt: DateTime!
  modifiedBy: UserInfo!
  name: String!
  operations("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): OperationsConnection
  path: [String!]!
  schemaVersions("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): SchemaVersionsConnection
  settings: ApiSettings!
  stages: [Stage!]!
  version: Version!
  workspace: Workspace
}

type ApiChanged implements ApiChangeLog & WorkspaceChangeLog {
  api(onlyIfLatest: Boolean): Api
  apiId: ID!
  changedAt: DateTime!
  changedBy: UserInfo!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

type ApiCreated implements ApiChangeLog & WorkspaceChangeLog {
  api(onlyIfLatest: Boolean): Api
  apiId: ID!
  changedAt: DateTime!
  changedBy: UserInfo!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

type ApiDeleted implements ApiChangeLog & WorkspaceChangeLog {
  api(onlyIfLatest: Boolean): Api
  apiId: ID!
  changedAt: DateTime!
  changedBy: UserInfo!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

type ApiDeletionFailedError implements Error {
  apiId: ID!
  message: String!
}

type ApiDocument implements Node {
  api: Api
  body: String!
  createdAt: DateTime!
  createdBy: UserInfo!
  id: ID!
  modifiedAt: DateTime!
  modifiedBy: UserInfo!
  name: String!
  path: [String!]!
  variables: String
  version: Version!
}

type ApiDocumentChanged implements ApiDocumentChangeLog & WorkspaceChangeLog {
  apiDocument(onlyIfLatest: Boolean): ApiDocument
  apiId: ID!
  changedAt: DateTime!
  changedBy: UserInfo!
  documentId: ID!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

"A connection to a list of items."
type ApiDocumentConnection {
  "A list of edges."
  edges: [ApiDocumentEdge!]
  "A flattened list of the nodes."
  nodes: [ApiDocument!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

type ApiDocumentCreated implements ApiDocumentChangeLog & WorkspaceChangeLog {
  apiDocument(onlyIfLatest: Boolean): ApiDocument
  apiId: ID!
  changedAt: DateTime!
  changedBy: UserInfo!
  documentId: ID!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

type ApiDocumentDeleted implements ApiDocumentChangeLog & WorkspaceChangeLog {
  apiDocument(onlyIfLatest: Boolean): ApiDocument
  apiId: ID!
  changedAt: DateTime!
  changedBy: UserInfo!
  documentId: ID!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

"An edge in a connection."
type ApiDocumentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ApiDocument!
}

type ApiHeader {
  enabled: Boolean!
  name: String!
  value: String!
}

type ApiHttpAuthentication {
  activeAuthenticationKind: String!
  basicOptions: BasicAuthenticationFlowOptions
  bearerOptions: BearerAuthenticationFlowOptions
  oAuth2Options: OAuth2AuthenticationFlowOptions
}

type ApiHttpConnection {
  authentication: ApiHttpAuthentication
  endpoint: String!
  headers: [ApiHeader!]
  includeCookies: Boolean!
  sdlEndpoint: String
  sseSubscriptionEndpoint: String
  subscriptionEndpoint: String
  subscriptionProtocol: String
  useGet: Boolean!
  useTunnel: Boolean!
}

type ApiKey {
  createdBy: UserInfo!
  id: ID!
  name: String!
  scopes: [ApiKeyScope!]!
  workspace: Workspace
}

type ApiKeyNotFoundError implements Error {
  apiKeyId: ID!
  message: String!
}

type ApiKeyScope {
  kind: String!
  reference: ApiKeyReference
  referenceId: String!
}

type ApiKeyWithSecret {
  key: ApiKey!
  secret: String!
}

"A connection to a list of items."
type ApiKeysConnection {
  "A list of edges."
  edges: [ApiKeysEdge!]
  "A flattened list of the nodes."
  nodes: [ApiKey!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ApiKeysEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ApiKey!
}

type ApiNotFoundError implements Error {
  apiId: ID!
  message: String!
}

type ApiSettings {
  schemaRegistry: SchemaRegistrySettings!
}

"A connection to a list of items."
type ApisConnection {
  "A list of edges."
  edges: [ApisEdge!]
  "A flattened list of the nodes."
  nodes: [Api!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ApisEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Api!
}

type ApproveDeploymentPayload {
  deployment: Deployment
  errors: [ApproveDeploymentError!]
}

type ArgumentAdded implements SchemaChange {
  coordinate: String!
  name: String!
  severity: SchemaChangeSeverity!
  typeName: String!
}

type ArgumentChanged implements SchemaChange {
  changes: [ArgumentChange!]!
  coordinate: String!
  name: String!
  severity: SchemaChangeSeverity!
}

type ArgumentRemoved implements SchemaChange {
  coordinate: String!
  name: String!
  severity: SchemaChangeSeverity!
  typeName: String!
}

type Attribute {
  key: String!
  value: String!
}

type BasicAuthenticationFlowOptions {
  password: String!
  username: String!
}

type BearerAuthenticationFlowOptions {
  prefix: String
  token: String!
}

type BeginFusionConfigurationPublishPayload {
  errors: [BeginFusionConfigurationPublishError!]
  requestId: ID
}

type CancelDeploymentPayload {
  deployment: Deployment
  errors: [CancelDeploymentError!]
}

type CancelFusionConfigurationCompositionPayload {
  errors: [CancelFusionConfigurationCompositionError!]
  requestId: ID
}

type ChangeStructureInvalid implements Error {
  message: String!
}

type ChangeValidationFailed implements Error {
  errors: [ValidationErrorProperty!]!
  message: String!
  workspaceId: ID!
}

"A connection to a list of items."
type ChangesConnection {
  "A list of edges."
  edges: [ChangesEdge!]
  "A flattened list of the nodes."
  nodes: [WorkspaceChangeLog]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ChangesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: WorkspaceChangeLog
}

type Client implements Node {
  api: Api
  createdAt: DateTime!
  createdBy: UserInfo!
  id: ID!
  name: String!
  operations("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): OperationsConnection
  versions("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): ClientVersionConnection
}

type ClientChangeLog implements StageChangeLog & Node {
  changedAt: DateTime!
  id: ID!
  kind: StageChangeLogKind!
  tag: String!
}

type ClientDeployment implements Node & Deployment {
  approval: DeploymentApproval
  client: Client
  createdAt: DateTime!
  errors: [ClientDeploymentError!]!
  id: ID!
  logs: [DeploymentLog!]!
  status: DeploymentStatus!
  tag: String!
}

type ClientInsight {
  averageLatency: Float
  client: Client
  errorRate: Float
  id: ID!
  impact: Float
  name: String!
  opm: Float
  successRate: Float
  totalCount: Long
  totalCountWithErrors: Long
}

"A connection to a list of items."
type ClientInsightsConnection {
  "A list of edges."
  edges: [ClientInsightsEdge!]
  "A flattened list of the nodes."
  nodes: [ClientInsight!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ClientInsightsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ClientInsight!
}

type ClientNotFoundError implements Error {
  clientId: ID!
  message: String!
}

type ClientVersion implements Node {
  client: Client
  createdAt: DateTime!
  id: ID!
  persistedQueries("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): PersistedQueriesConnection
  publishedTo: [PublishedClientVersion!]!
  tag: String!
  tags: [String!]! @deprecated(reason: "Use `tag` instead.")
}

"A connection to a list of items."
type ClientVersionConnection {
  "A list of edges."
  edges: [ClientVersionEdge!]
  "A flattened list of the nodes."
  nodes: [ClientVersion!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ClientVersionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ClientVersion!
}

type ClientVersionNotFoundError implements Error {
  clientId: ID!
  message: String!
  tag: String!
}

type ClientVersionPublishFailed implements ClientVersionPublishResult {
  errors: [ClientVersionPublishError!]!
  state: ProcessingState!
}

type ClientVersionPublishSuccess implements ClientVersionPublishResult {
  clientVersion: ClientVersion
  state: ProcessingState!
}

type ClientVersionRequestNotFoundError implements Error {
  message: String!
  requestId: ID!
}

type ClientVersionValidationFailed implements ClientVersionValidationResult {
  errors: [ClientVersionValidationError!]!
  state: ProcessingState!
}

type ClientVersionValidationSuccess implements ClientVersionValidationResult {
  state: ProcessingState!
}

"A connection to a list of items."
type ClientsConnection {
  "A list of edges."
  edges: [ClientsEdge!]
  "A flattened list of the nodes."
  nodes: [Client!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ClientsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Client!
}

type CommitFusionConfigurationPublishPayload {
  errors: [CommitFusionConfigurationPublishError!]
  requestId: ID
}

type ConcurrentOperationError implements Error & SchemaVersionPublishError & ClientVersionPublishError & FusionConfigurationPublishingError & ProcessingError {
  message: String!
}

type CreateAccountPayload {
  errors: [CreateAccountError!]
  user: User
}

type CreateApiKeyForApiPayload {
  errors: [CreateApiKeyForApiError!]
  result: ApiKeyWithSecret
}

type CreateClientPayload {
  client: Client
  errors: [CreateClientError!]
}

type CreateMockSchemaPayload {
  errors: [CreateMockSchemaError!]
  mockSchema: MockSchema
}

type CreatePersonalAccessTokenPayload {
  errors: [CreatePersonalAccessTokenError!]
  result: PersonalAccessTokenWithSecret
}

type CreateWorkspacePayload {
  errors: [CreateWorkspaceError!]
  workspace: Workspace
}

type DeleteApiByIdPayload {
  api: Api
  errors: [DeleteApiByIdError!]
}

type DeleteApiKeyPayload {
  apiKey: ApiKey
  errors: [DeleteApiKeyError!]
}

type DeleteClientByIdPayload {
  client: Client
  errors: [DeleteClientByIdError!]
}

type DeleteMockSchemaByIdPayload {
  errors: [DeleteMockSchemaByIdError!]
  mockSchema: MockSchema
}

type DeploymentApproval {
  approvedAt: DateTime!
  approvedBy: UserInfo!
}

type DeploymentApprovedLog implements DeploymentLog {
  message: String!
  timestamp: DateTime!
}

type DeploymentCancelledLog implements DeploymentLog {
  message: String!
  timestamp: DateTime!
}

type DeploymentCannotBeCancelledError implements Error {
  deploymentId: ID!
  message: String!
  status: DeploymentStatus!
}

type DeploymentCreatedEvent {
  deployment: Deployment!
}

type DeploymentCreatedLog implements DeploymentLog {
  message: String!
  timestamp: DateTime!
}

type DeploymentFailedLog implements DeploymentLog {
  errors: [ProcessingError!]!
  message: String!
  timestamp: DateTime!
}

type DeploymentIsNotWaitingForApprovalError implements Error {
  deploymentId: ID!
  message: String!
}

type DeploymentNotFoundError implements Error {
  deploymentId: ID!
  message: String!
}

type DeploymentQueuedLog implements DeploymentLog {
  message: String!
  timestamp: DateTime!
}

type DeploymentReadyLog implements DeploymentLog {
  message: String!
  timestamp: DateTime!
}

type DeploymentStartedProcessingLog implements DeploymentLog {
  message: String!
  timestamp: DateTime!
}

type DeploymentSuccessLog implements DeploymentLog {
  message: String!
  timestamp: DateTime!
}

type DeploymentUpdatedEvent {
  deployment: Deployment!
}

type DeploymentWaitingForApprovalLog implements DeploymentLog {
  message: String!
  timestamp: DateTime!
}

"A connection to a list of items."
type DeploymentsConnection {
  "A list of edges."
  edges: [DeploymentsEdge!]
  "A flattened list of the nodes."
  nodes: [Deployment!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DeploymentsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Deployment!
}

type DeprecatedChange implements SchemaChange {
  deprecationReason: String
  severity: SchemaChangeSeverity!
}

type DescriptionChanged implements SchemaChange {
  new: String
  old: String
  severity: SchemaChangeSeverity!
}

type DirectiveLocationAdded implements SchemaChange {
  location: DirectiveLocation!
  severity: SchemaChangeSeverity!
}

type DirectiveLocationRemoved implements SchemaChange {
  location: DirectiveLocation!
  severity: SchemaChangeSeverity!
}

type DirectiveModifiedChange implements SchemaChange {
  changes: [DirectiveChange!]!
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type DocumentChangeValidationFailed implements Error {
  errors: [ValidationErrorProperty!]!
  message: String!
  workspaceId: ID!
}

type DocumentChanged implements DocumentChangeLog & WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  document(onlyIfLatest: Boolean): WorkspaceDocument
  documentId: ID!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

type DocumentChangedConflict implements Error {
  document: WorkspaceDocument!
  message: String!
}

"A connection to a list of items."
type DocumentChangesConnection {
  "A list of edges."
  edges: [DocumentChangesEdge!]
  "A flattened list of the nodes."
  nodes: [DocumentChangeLog]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DocumentChangesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DocumentChangeLog
}

type DocumentCreated implements DocumentChangeLog & WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  document(onlyIfLatest: Boolean): WorkspaceDocument
  documentId: ID!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

type DocumentDeleted implements DocumentChangeLog & WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  document(onlyIfLatest: Boolean): WorkspaceDocument
  documentId: ID!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

type DocumentDeletionConflict implements Error {
  message: String!
  workspaceId: ID!
}

type DocumentNameCollisionConflict implements Error {
  document: WorkspaceDocument!
  message: String!
}

"A connection to a list of items."
type DocumentsConnection {
  "A list of edges."
  edges: [DocumentsEdge!]
  "A flattened list of the nodes."
  nodes: [WorkspaceDocument!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DocumentsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: WorkspaceDocument!
}

type DuplicatedTagError implements Error {
  message: String!
  tag: String!
}

type EnsureTunnelSessionPayload {
  errors: [EnsureTunnelSessionError!]
  tunnelSession: TunnelSession
}

type EnumModifiedChange implements SchemaChange {
  changes: [EnumChange!]!
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type EnumValueAdded implements SchemaChange {
  coordinate: String!
  severity: SchemaChangeSeverity!
  value: String!
}

type EnumValueChanged implements SchemaChange {
  changes: [EnumValueChange!]!
  coordinate: String!
  severity: SchemaChangeSeverity!
  value: String!
}

type EnumValueRemoved implements SchemaChange {
  coordinate: String!
  severity: SchemaChangeSeverity!
  value: String!
}

type Environment implements Node {
  createdAt: DateTime!
  createdBy: UserInfo!
  id: ID!
  modifiedAt: DateTime!
  modifiedBy: UserInfo!
  name: String!
  variables: [EnvironmentVariable!]!
  version: Version!
  workspace: Workspace
}

type EnvironmentChanged implements EnvironmentChangeLog & WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  environment(onlyIfLatest: Boolean): Environment
  environmentId: ID!
  id: ID!
  name: String!
  version: Version!
  workspaceId: ID!
}

type EnvironmentCreated implements EnvironmentChangeLog & WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  environment(onlyIfLatest: Boolean): Environment
  environmentId: ID!
  id: ID!
  name: String!
  version: Version!
  workspaceId: ID!
}

type EnvironmentDeleted implements EnvironmentChangeLog & WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  environment(onlyIfLatest: Boolean): Environment
  environmentId: ID!
  id: ID!
  name: String!
  version: Version!
  workspaceId: ID!
}

type EnvironmentVariable {
  id: String!
  isSecret: Boolean!
  name: String!
  value: String!
}

"A connection to a list of items."
type EnvironmentsConnection {
  "A list of edges."
  edges: [EnvironmentsEdge!]
  "A flattened list of the nodes."
  nodes: [Environment!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type EnvironmentsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Environment!
}

type ErrorInsight {
  epm: Float!
  id: ID!
  lastSeen: Float!
  message: String!
  totalCount: Long!
  type: String!
}

"A connection to a list of items."
type ErrorInsightsConnection {
  "A list of edges."
  edges: [ErrorInsightsEdge!]
  "A flattened list of the nodes."
  nodes: [ErrorInsight!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ErrorInsightsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ErrorInsight!
}

type FieldAddedChange implements SchemaChange {
  coordinate: String!
  fieldName: String!
  severity: SchemaChangeSeverity!
  typeName: String!
}

type FieldRemovedChange implements SchemaChange {
  coordinate: String!
  fieldName: String!
  severity: SchemaChangeSeverity!
  typeName: String!
}

type FusionConfiguration {
  downloadUrl: String!
  id: ID!
  publishedAt: DateTime!
  subgraph: Api
  subgraphName: String
  tag: String!
}

type FusionConfigurationChangeLog implements StageChangeLog & Node {
  changedAt: DateTime!
  id: ID!
  kind: StageChangeLogKind!
  tag: String!
}

type FusionConfigurationDeployment implements Node & Deployment {
  approval: DeploymentApproval
  createdAt: DateTime!
  errors: [FusionConfigurationDeploymentError!]!
  id: ID!
  logs: [DeploymentLog!]!
  schemaChanges: FusionConfigurationDeploymentSchemaChanges
  status: DeploymentStatus!
  subgraph: Subgraph
  tag: String!
}

type FusionConfigurationDeploymentSchemaChanges {
  changes("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int severity: SchemaChangeSeverity): SchemaChangesConnection
  statistic: SchemaChangeLogStatistic!
}

type FusionConfigurationPublishingFailed implements FusionConfigurationPublishingResult {
  errors: [FusionConfigurationPublishingError!]!
  state: ProcessingState!
}

type FusionConfigurationPublishingSuccess implements FusionConfigurationPublishingResult {
  state: ProcessingState!
}

type FusionConfigurationRequestNotFoundError implements Error {
  message: String!
  requestId: ID!
}

type FusionConfigurationValidationFailed implements FusionConfigurationPublishingResult {
  errors: [FusionConfigurationValidationError!]!
  state: ProcessingState!
}

type FusionConfigurationValidationSuccess implements FusionConfigurationPublishingResult {
  changes: [SchemaChangeLogEntry!]!
  state: ProcessingState!
}

type FusionSubgraph implements Subgraph {
  api: Api
  id: ID!
  name: String!
}

type GraphQLSchemaError {
  code: String
  message: String!
}

type HasBeenChangedConflict implements Error {
  current: WorkspaceChangeResult!
  message: String!
}

type HasBeenDeletedConflict implements Error {
  message: String!
  workspaceId: ID!
}

type IdentifierCollisionConflict implements Error {
  collidesWith: WorkspaceChangeResult!
  message: String!
}

type InputFieldChanged implements SchemaChange {
  changes: [InputFieldChange!]!
  coordinate: String!
  fieldName: String!
  severity: SchemaChangeSeverity!
}

type InputObjectModifiedChange implements SchemaChange {
  changes: [InputObjectChange!]!
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type InterfaceImplementationAdded implements SchemaChange {
  interfaceName: String!
  severity: SchemaChangeSeverity!
}

type InterfaceImplementationRemoved implements SchemaChange {
  interfaceName: String!
  severity: SchemaChangeSeverity!
}

type InterfaceModifiedChange implements SchemaChange {
  changes: [InterfaceChange!]!
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type InvalidGraphQLSchemaError implements SchemaVersionValidationError & SchemaVersionPublishError & FusionConfigurationPublishingError & FusionConfigurationValidationError & ProcessingError {
  errors: [GraphQLSchemaError!]!
  message: String!
}

type InvalidPersistedQueryError implements Error {
  content: String!
  hash: String!
  message: String!
}

type InvalidProcessingStateTransitionError implements Error {
  message: String!
}

type MockSchema {
  baseSchemaDownloadUrl: String!
  createdAt: DateTime!
  createdBy: UserInfo!
  downstreamUrl: URL!
  extensionsSchemaDownloadUrl: String!
  id: ID!
  modifiedAt: DateTime!
  modifiedBy: UserInfo!
  name: String!
  url: String!
}

type MockSchemaNonUniqueNameError implements Error {
  message: String!
  name: String!
}

type MockSchemaNotFoundError implements Error {
  id: ID!
  message: String!
}

"A connection to a list of items."
type MockSchemasConnection {
  "A list of edges."
  edges: [MockSchemasEdge!]
  "A flattened list of the nodes."
  nodes: [MockSchema!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type MockSchemasEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MockSchema!
}

type Mutation {
  approveDeployment(input: ApproveDeploymentInput!): ApproveDeploymentPayload!
  beginFusionConfigurationPublish(input: BeginFusionConfigurationPublishInput!): BeginFusionConfigurationPublishPayload!
  cancelDeployment(input: CancelDeploymentInput!): CancelDeploymentPayload!
  cancelFusionConfigurationComposition(input: CancelFusionConfigurationCompositionInput!): CancelFusionConfigurationCompositionPayload!
  commitFusionConfigurationPublish(input: CommitFusionConfigurationPublishInput!): CommitFusionConfigurationPublishPayload!
  createAccount: CreateAccountPayload!
  createApiKeyForApi(input: CreateApiKeyForApiInput!): CreateApiKeyForApiPayload!
  createClient(input: CreateClientInput!): CreateClientPayload!
  createMockSchema(input: CreateMockSchemaInput!): CreateMockSchemaPayload!
  createPersonalAccessToken(input: CreatePersonalAccessTokenInput!): CreatePersonalAccessTokenPayload!
  createWorkspace(input: CreateWorkspaceInput!): CreateWorkspacePayload!
  deleteApiById(input: DeleteApiByIdInput!): DeleteApiByIdPayload!
  deleteApiKey(input: DeleteApiKeyInput!): DeleteApiKeyPayload!
  deleteClientById(input: DeleteClientByIdInput!): DeleteClientByIdPayload!
  deleteMockSchemaById(input: DeleteMockSchemaByIdInput!): DeleteMockSchemaByIdPayload!
  ensureTunnelSession: EnsureTunnelSessionPayload!
  pollClientVersionPublishRequest(input: PollClientVersionPublishRequestInput!): PollClientVersionPublishRequestPayload!
  pollClientVersionValidationRequest(input: PollClientVersionValidationRequestInput!): PollClientVersionValidationRequestPayload!
  pollSchemaVersionPublishRequest(input: PollSchemaVersionPublishRequestInput!): PollSchemaVersionPublishRequestPayload!
  pollSchemaVersionValidationRequest(input: PollSchemaVersionValidationRequestInput!): PollSchemaVersionValidationRequestPayload!
  publishClient(input: PublishClientInput!): PublishClientPayload!
  publishSchema(input: PublishSchemaInput!): PublishSchemaPayload!
  pushDocumentChanges(input: PushDocumentChangeInput!): PushDocumentChangesPayload!  @deprecated(reason: "Use pushWorkspaceChanges")
  pushWorkspaceChanges(input: PushWorkspaceChangesInput!): PushWorkspaceChangesPayload!
  removeWorkspace(input: RemoveWorkspaceInput!): RemoveWorkspacePayload!
  renameWorkspace(input: RenameWorkspaceInput!): RenameWorkspacePayload!
  revokePersonalAccessToken(input: RevokePersonalAccessTokenInput!): RevokePersonalAccessTokenPayload!
  setActiveWorkspace(input: SetActiveWorkspaceInput!): SetActiveWorkspacePayload!
  startFusionConfigurationComposition(input: StartFusionConfigurationCompositionInput!): StartFusionConfigurationCompositionPayload!
  unpublishClient(input: UnpublishClientInput!): UnpublishClientPayload!
  updateApiSettings(input: UpdateApiSettingsInput!): UpdateApiSettingsPayload!
  updateFeatureFlags(input: UpdateFeatureFlagsInput!): UpdateFeatureFlagsPayload!
  updateMockSchema(input: UpdateMockSchemaInput!): UpdateMockSchemaPayload!
  updatePreferences(input: UpdatePreferencesInput!): UpdatePreferencesPayload!
  updateStages(input: UpdateStagesInput!): UpdateStagesPayload!
  updateThemeSettings(input: UpdateThemeSettingsInput!): UpdateThemeSettingsPayload!
  uploadClient(input: UploadClientInput!): UploadClientPayload!
  uploadSchema(input: UploadSchemaInput!): UploadSchemaPayload!
  validateClient(input: ValidateClientInput!): ValidateClientPayload!
  validateFusionConfigurationComposition(input: ValidateFusionConfigurationCompositionInput!): ValidateFusionConfigurationCompositionPayload!
  validateSchema(input: ValidateSchemaInput!): ValidateSchemaPayload!
}

type OAuth2AuthenticationFlowOptions {
  accessTokenUrl: String!
  activeFlowKind: String!
  audience: String!
  authorizationUrl: String!
  clientId: String!
  clientSecret: String!
  credentialsInBody: Boolean!
  grantType: String!
  origin: String!
  password: String!
  pkceMethod: String!
  prefix: String!
  redirectUrl: String!
  resource: String!
  responseType: String!
  scope: String!
  state: String!
  usePkce: Boolean!
  username: String!
}

type ObjectModifiedChange implements SchemaChange {
  changes: [ObjectChange!]!
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type OpenTelemetryBoolAttribute implements OpenTelemetryAttribute {
  key: String!
  value: Boolean!
}

type OpenTelemetryDbSpan implements OpenTelemetrySpan {
  api: Api
  clockSkew: Float
  db: OpenTelemetryDbSpanAttributes
  duration: Float!
  epoch: Float!
  events: [OpenTelemetryTraceEvent!]!
  links: [OpenTelemetryTraceLink!]!
  parentSpanId: String!
  resourceAttributes: [Attribute!]!
  spanAttributes: [Attribute!]!
  spanId: String!
  spanKind: String!
  spanName: String!
  stage: Stage
  statusCode: String!
  statusMessage: String!
  traceId: String!
  traceState: String!
}

type OpenTelemetryDbSpanAttributes {
  connectionString: String
  instance: String
  name: String
  operation: String
  statement: String
  system: String
  url: String
  user: String
}

type OpenTelemetryDefaultSpan implements OpenTelemetrySpan {
  api: Api
  clockSkew: Float
  duration: Float!
  epoch: Float!
  events: [OpenTelemetryTraceEvent!]!
  links: [OpenTelemetryTraceLink!]!
  parentSpanId: String!
  resourceAttributes: [Attribute!]!
  spanAttributes: [Attribute!]!
  spanId: String!
  spanKind: String!
  spanName: String!
  stage: Stage
  statusCode: String!
  statusMessage: String!
  traceId: String!
  traceState: String!
}

type OpenTelemetryError {
  api: Api
  epoch: Float!
  escaped: Boolean!
  message: String!
  parentSpanId: String!
  spanId: String!
  stackTrace: String!
  stage: Stage
  traceId: String!
  type: String!
}

type OpenTelemetryFloatAttribute implements OpenTelemetryAttribute {
  key: String!
  value: Float!
}

type OpenTelemetryGraphQLOperationSpan implements OpenTelemetrySpan {
  api: Api
  clockSkew: Float
  document: OpenTelemetryGraphQLOperationSpanDocumentAttributes
  duration: Float!
  epoch: Float!
  events: [OpenTelemetryTraceEvent!]!
  links: [OpenTelemetryTraceLink!]!
  operation: OpenTelemetryGraphQLOperationSpanOperationAttributes
  parentSpanId: String!
  resourceAttributes: [Attribute!]!
  spanAttributes: [Attribute!]!
  spanId: String!
  spanKind: String!
  spanName: String!
  stage: Stage
  statusCode: String!
  statusMessage: String!
  traceId: String!
  traceState: String!
}

type OpenTelemetryGraphQLOperationSpanDocumentAttributes {
  body: String
  id: String
}

type OpenTelemetryGraphQLOperationSpanOperationAttributes {
  kind: String
  name: String
}

type OpenTelemetryGraphQLResolverSpan implements OpenTelemetrySpan {
  api: Api
  clockSkew: Float
  duration: Float!
  epoch: Float!
  events: [OpenTelemetryTraceEvent!]!
  links: [OpenTelemetryTraceLink!]!
  parentSpanId: String!
  resourceAttributes: [Attribute!]!
  selection: OpenTelemetryGraphQLResolverSpanSelectionAttributes
  spanAttributes: [Attribute!]!
  spanId: String!
  spanKind: String!
  spanName: String!
  stage: Stage
  statusCode: String!
  statusMessage: String!
  traceId: String!
  traceState: String!
}

type OpenTelemetryGraphQLResolverSpanFieldAttributes {
  coordinate: String
  declaringType: String
  name: String
}

type OpenTelemetryGraphQLResolverSpanSelectionAttributes {
  field: OpenTelemetryGraphQLResolverSpanFieldAttributes!
  name: String
  path: String
  type: String
}

type OpenTelemetryHttpClientSpan implements OpenTelemetrySpan {
  api: Api
  clockSkew: Float
  duration: Float!
  epoch: Float!
  events: [OpenTelemetryTraceEvent!]!
  http: OpenTelemetryHttpClientSpanAttribute
  links: [OpenTelemetryTraceLink!]!
  parentSpanId: String!
  resourceAttributes: [Attribute!]!
  spanAttributes: [Attribute!]!
  spanId: String!
  spanKind: String!
  spanName: String!
  stage: Stage
  statusCode: String!
  statusMessage: String!
  traceId: String!
  traceState: String!
}

type OpenTelemetryHttpClientSpanAttribute {
  flavor: String
  method: String
  scheme: String
  statusCode: Int
  url: String
  userAgent: String
}

type OpenTelemetryHttpServerSpan implements OpenTelemetrySpan {
  api: Api
  clockSkew: Float
  duration: Float!
  epoch: Float!
  events: [OpenTelemetryTraceEvent!]!
  http: OpenTelemetryHttpServerSpanAttributes
  links: [OpenTelemetryTraceLink!]!
  parentSpanId: String!
  resourceAttributes: [Attribute!]!
  spanAttributes: [Attribute!]!
  spanId: String!
  spanKind: String!
  spanName: String!
  stage: Stage
  statusCode: String!
  statusMessage: String!
  traceId: String!
  traceState: String!
}

type OpenTelemetryHttpServerSpanAttributes {
  flavor: String
  method: String
  scheme: String
  statusCode: Int
  url: String
  userAgent: String
}

type OpenTelemetryLog {
  api: Api
  body: String!
  epoch: Float!
  logAttributes: [OpenTelemetryAttribute!]!
  resourceAttributes: [Attribute!]!
  severityNumber: Int!
  severityText: String!
  spanId: String!
  stage: Stage
  traceId: String!
}

"A connection to a list of items."
type OpenTelemetryLogsConnection {
  "A list of edges."
  edges: [OpenTelemetryLogsEdge!]
  "A flattened list of the nodes."
  nodes: [OpenTelemetryLog!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type OpenTelemetryLogsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: OpenTelemetryLog!
}

type OpenTelemetryLogsSeverityGraph {
  dataset: [OpenTelemetryLogsSeverityGraphData!]!
}

type OpenTelemetryLogsSeverityGraphCountData {
  count: Long!
  severity: Long!
}

type OpenTelemetryLogsSeverityGraphData {
  counts: [OpenTelemetryLogsSeverityGraphCountData!]!
  epoch: Long!
}

type OpenTelemetryLongAttribute implements OpenTelemetryAttribute {
  key: String!
  value: Long!
}

type OpenTelemetryStringAttribute implements OpenTelemetryAttribute {
  key: String!
  value: String!
}

type OpenTelemetryTrace {
  epoch: Float!
  errors: [OpenTelemetryError!]!
  logs("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): OpenTelemetryLogsConnection
  spans: [OpenTelemetrySpan!]!
  totalDuration: Float!
}

type OpenTelemetryTraceEvent {
  attributes: [Attribute!]!
  epoch: Float!
  name: String!
}

type OpenTelemetryTraceLink {
  attributes: [Attribute!]!
  spanId: String!
  traceId: String!
  traceState: String!
}

type OpenTelemetryTransactionInsight {
  averageLatency: Float!
  errorRate: Float!
  id: ID!
  impact: Float!
  latency: OpenTelemetryTransactionLatencyGraph
  name: String!
  opm: Float!
  spanKind: OpenTelemetrySpanKind!
  successRate: Float!
  throughput: OpenTelemetryTransactionThroughputGraph
  totalCount: Long!
  totalCountWithErrors: Long!
}

"A connection to a list of items."
type OpenTelemetryTransactionInsightsConnection {
  "A list of edges."
  edges: [OpenTelemetryTransactionInsightsEdge!]
  "A flattened list of the nodes."
  nodes: [OpenTelemetryTransactionInsight!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type OpenTelemetryTransactionInsightsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: OpenTelemetryTransactionInsight!
}

type OpenTelemetryTransactionLatencyDistributionGraph {
  dataset: [OpenTelemetryTransactionLatencyDistributionGraphData!]!
  p95: Float!
  totalCount: Int!
}

type OpenTelemetryTransactionLatencyDistributionGraphData {
  bin: Float!
  errorFrequency: Int!
  frequency: Int!
  successFrequency: Int!
}

type OpenTelemetryTransactionLatencyGraph {
  dataset: [OpenTelemetryTransactionLatencyGraphData!]!
}

type OpenTelemetryTransactionLatencyGraphData {
  epoch: Long!
  max: Float!
  mean: Float!
  min: Float!
  p50: Float!
  p95: Float!
  p99: Float!
}

type OpenTelemetryTransactionThroughputGraph {
  dataset: [OpenTelemetryTransactionThroughputGraphData!]!
}

type OpenTelemetryTransactionThroughputGraphData {
  epoch: Long!
  errorRate: Float!
  opm: Float!
  successRate: Float!
  totalCount: Long!
  totalCountWithError: Long!
}

type OpenTelemetryTransactionTraceSample {
  seeker: String!
  spanId: String!
  traceId: String!
}

type OpenTelemetryTransactionsLatencyGraph {
  dataset: [OpenTelemetryTransactionsLatencyGraphData!]!
}

type OpenTelemetryTransactionsLatencyGraphData {
  epoch: Long!
  max: Float!
  mean: Float!
  min: Float!
  p50: Float!
  p95: Float!
  p99: Float!
}

type OpenTelemetryTransactionsThroughputGraph {
  dataset: [OpenTelemetryTransactionsThroughputGraphData!]!
}

type OpenTelemetryTransactionsThroughputGraphData {
  epoch: Long!
  errorRate: Float!
  opm: Float!
  successRate: Float!
  totalCount: Long!
  totalCountWithError: Long!
}

type Operation {
  document: RequestDocument
  kind: OperationKind!
  name: String
}

type OperationInProgress implements SchemaVersionValidationResult & SchemaVersionPublishResult & ClientVersionValidationResult & ClientVersionPublishResult & FusionConfigurationPublishingResult {
  state: ProcessingState!
}

type OperationInsight {
  averageLatency: Float!
  documentId: String!
  errorRate: Float!
  hash: String!
  id: ID!
  impact: Float!
  kind: OperationKind
  latency: OperationLatencyGraph
  operationName: String!
  opm: Float!
  successRate: Float!
  throughput: OperationThroughputGraph
  totalCount: Long!
  totalCountWithErrors: Long!
}

"A connection to a list of items."
type OperationInsightsConnection {
  "A list of edges."
  edges: [OperationInsightsEdge!]
  "A flattened list of the nodes."
  nodes: [OperationInsight!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type OperationInsightsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: OperationInsight!
}

type OperationLatencyDistributionGraph {
  data: [OperationLatencyDistributionGraphData!]! @deprecated(reason: "Use `Dataset` instead")
  dataset: [OperationLatencyDistributionGraphData!]!
  p95: Float!
  p95DurationInMS: Float! @deprecated(reason: "Use `P95` instead")
  totalCount: Int!
}

type OperationLatencyDistributionGraphData {
  bin: Float!
  bucketInMs: Float! @deprecated(reason: "Use `Bin` instead")
  count: Int! @deprecated(reason: "Use `Frequency` instead")
  errorFrequency: Int!
  frequency: Int!
  successFrequency: Int!
}

type OperationLatencyGraph {
  dataset: [OperationLatencyGraphData!]!
}

type OperationLatencyGraphData {
  epoch: Long!
  max: Float!
  mean: Float!
  min: Float!
  p50: Float!
  p95: Float!
  p99: Float!
}

type OperationThroughputGraph {
  dataset: [OperationThroughputGraphData!]!
}

type OperationThroughputGraphData {
  epoch: Long!
  errorRate: Float!
  opm: Float!
  successRate: Float!
  totalCount: Long!
  totalCountWithError: Long!
}

type OperationTraceSample {
  seeker: String!
  spanId: String!
  traceId: String!
}

type OperationsAreNotAllowedError implements SchemaVersionValidationError & SchemaVersionPublishError & ProcessingError {
  column: Int! @deprecated(reason: "Locations are no longer used")
  end: Int! @deprecated(reason: "Locations are no longer used")
  line: Int! @deprecated(reason: "Locations are no longer used")
  message: String!
  operationName: String
  start: Int! @deprecated(reason: "Locations are no longer used")
}

"A connection to a list of items."
type OperationsConnection {
  "A list of edges."
  edges: [OperationsEdge!]
  "A flattened list of the nodes."
  nodes: [Operation!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type OperationsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Operation!
}

type OperationsLatencyGraph {
  dataset: [OperationsLatencyGraphData!]!
}

type OperationsLatencyGraphData {
  epoch: Long!
  max: Float!
  mean: Float!
  min: Float!
  p50: Float!
  p95: Float!
  p99: Float!
}

type OperationsThroughputGraph {
  dataset: [OperationsThroughputGraphData!]!
}

type OperationsThroughputGraphData {
  epoch: Long!
  errorRate: Float!
  opm: Float!
  successRate: Float!
  totalCount: Long!
  totalCountWithError: Long!
}

type OrganizationInfo {
  displayName: String!
  id: ID!
  name: String!
}

type OutputFieldChanged implements SchemaChange {
  changes: [OutputFieldChange!]!
  coordinate: String!
  fieldName: String!
  severity: SchemaChangeSeverity!
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

type PersistedQueriesChanged {
  version: String!
}

"A connection to a list of items."
type PersistedQueriesConnection {
  "A list of edges."
  edges: [PersistedQueriesEdge!]
  "A flattened list of the nodes."
  nodes: [RequestDocument!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PersistedQueriesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: RequestDocument!
}

type PersistedQueryError {
  code: String
  locations: [PersistedQueryErrorLocation!]
  message: String!
  path: String
}

type PersistedQueryErrorLocation {
  column: Int!
  line: Int!
}

type PersistedQueryValidationError implements ClientVersionPublishError & ClientVersionValidationError & SchemaVersionPublishError & SchemaVersionValidationError & FusionConfigurationValidationError & ProcessingError {
  client: Client
  clientId: ID! @deprecated(reason: "Use `client` instead.")
  hasMoreErrors: Boolean!
  message: String!
  queries: [PersistedQueryValidationFailed!]!
}

type PersistedQueryValidationFailed {
  deployedTags: [String!]!
  errors: [PersistedQueryError!]!
  hash: String!
  message: String!
}

type PersonalAccessToken {
  createdAt: DateTime!
  description: String!
  expiresAt: DateTime!
  id: ID!
}

type PersonalAccessTokenNotFoundError implements Error {
  message: String!
}

type PersonalAccessTokenWithSecret {
  secret: String!
  token: PersonalAccessToken!
}

"A connection to a list of items."
type PersonalAccessTokensConnection {
  "A list of edges."
  edges: [PersonalAccessTokensEdge!]
  "A flattened list of the nodes."
  nodes: [PersonalAccessToken!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PersonalAccessTokensEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PersonalAccessToken!
}

type PollClientVersionPublishRequestPayload {
  errors: [PollClientVersionPublishRequestError!]
  result: ClientVersionPublishResult
}

type PollClientVersionValidationRequestPayload {
  errors: [PollClientVersionValidationRequestError!]
  result: ClientVersionValidationResult
}

type PollSchemaVersionPublishRequestPayload {
  errors: [PollSchemaVersionPublishRequestError!]
  result: SchemaVersionPublishResult
}

type PollSchemaVersionValidationRequestPayload {
  errors: [PollSchemaVersionValidationRequestError!]
  result: SchemaVersionValidationResult
}

type PossibleTypeAdded implements SchemaChange {
  severity: SchemaChangeSeverity!
  typeName: String!
}

type PossibleTypeRemoved implements SchemaChange {
  severity: SchemaChangeSeverity!
  typeName: String!
}

type ProcessingTaskApproved implements SchemaVersionPublishResult & ClientVersionPublishResult & FusionConfigurationPublishingResult {
  state: ProcessingState!
}

type ProcessingTaskIsQueued implements FusionConfigurationPublishingResult & ClientVersionPublishResult & SchemaVersionPublishResult {
  queuePosition: Int!
  state: ProcessingState!
}

type ProcessingTaskIsReady implements FusionConfigurationPublishingResult & ClientVersionPublishResult & SchemaVersionPublishResult {
  state: ProcessingState!
}

type ProcessingTimeoutError implements SchemaVersionValidationError & SchemaVersionPublishError & ClientVersionValidationError & ClientVersionPublishError & FusionConfigurationPublishingError & ProcessingError {
  message: String!
}

type PublishClientPayload {
  errors: [PublishClientError!]
  id: ID
}

type PublishSchemaPayload {
  errors: [PublishSchemaError!]
  id: ID
}

type PublishedClient {
  client: Client!
  publishedVersions: [PublishedClientVersion!]!
}

type PublishedClientVersion {
  publishedAt: DateTime!
  stage: Stage
  tags: [String!]!  @deprecated(reason: "Use `version.tag` instead.")
  version: ClientVersion
}

type PublishedSchemaVersion {
  publishedAt: DateTime!
  stage: Stage
  tag: String!  @deprecated(reason: "Use `version.tag` instead.")
  version: SchemaVersion
}

type PushDocumentChangesPayload {
  changes: [WorkspaceDocumentChangeResult!]
  errors: [PushDocumentChangesError!]
}

type PushWorkspaceChangesPayload {
  changes: [WorkspaceChangePayload!]
  errors: [PushWorkspaceChangesError!]
}

type Query {
  apiById(id: ID!): Api
  fusionConfigurationByApiId(id: ID! stage: String!): FusionConfiguration
  me: Viewer
  "Fetches an object given its ID."
  node("ID of the object." id: ID!): Node
  "Lookup nodes by a list of IDs."
  nodes("The list of node IDs." ids: [ID!]!): [Node]!
  stageById(id: ID!): Stage
  workspaceById(workspaceId: ID!): Workspace
}

type ReadyTimeoutError implements ClientVersionPublishError & ClientVersionValidationError & SchemaVersionPublishError & SchemaVersionValidationError & FusionConfigurationPublishingError & ProcessingError {
  message: String!
}

type RemoveWorkspacePayload {
  errors: [RemoveWorkspaceError!]
  workspace: Workspace
}

type RenameWorkspacePayload {
  errors: [RenameWorkspaceError!]
  workspace: Workspace
}

type RequestDocument {
  content: String!
  documentIds: [String!]!
  id: ID!
}

type ResolverInsight {
  averageLatency: Float!
  coordinate: String!
  errorRate: Float!
  id: ID!
  impact: Float!
  latency: ResolverLatencyGraph
  opm: Float!
  successRate: Float!
  throughput: ResolverThroughputGraph
  totalCount: Long!
  totalCountWithErrors: Long!
}

"A connection to a list of items."
type ResolverInsightsConnection {
  "A list of edges."
  edges: [ResolverInsightsEdge!]
  "A flattened list of the nodes."
  nodes: [ResolverInsight!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ResolverInsightsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ResolverInsight!
}

type ResolverLatencyGraph {
  dataset: [ResolverLatencyGraphData!]!
}

type ResolverLatencyGraphData {
  epoch: Long!
  max: Float!
  mean: Float!
  min: Float!
  p50: Float!
  p95: Float!
  p99: Float!
}

type ResolverThroughputGraph {
  dataset: [ResolverThroughputGraphData!]!
}

type ResolverThroughputGraphData {
  epoch: Long!
  errorRate: Float!
  opm: Float!
  successRate: Float!
  totalCount: Long!
  totalCountWithError: Long!
}

type RevokePersonalAccessTokenPayload {
  errors: [RevokePersonalAccessTokenError!]
  personalAccessToken: PersonalAccessToken
}

type ScalarModifiedChange implements SchemaChange {
  changes: [ScalarChange!]!
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type SchemaChangeLog implements StageChangeLog & Node {
  changedAt: DateTime!
  changes("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int severity: SchemaChangeSeverity): SchemaChangesConnection
  id: ID!
  kind: StageChangeLogKind!
  previousSchema: SchemaVersion
  schema: SchemaVersion
  statistic: SchemaChangeLogStatistic!
  tag: String!
}

type SchemaChangeLogStatistic {
  breaking: Int!
  dangerous: Int!
  safe: Int!
}

type SchemaChangeViolationError {
  changes: [SchemaChangeLogEntry!]!
  message: String!
}

"A connection to a list of items."
type SchemaChangesConnection {
  "A list of edges."
  edges: [SchemaChangesEdge!]
  "A flattened list of the nodes."
  nodes: [SchemaChangeLogEntry!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type SchemaChangesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SchemaChangeLogEntry!
}

type SchemaDeployment implements Node & Deployment {
  approval: DeploymentApproval
  createdAt: DateTime!
  errors: [SchemaDeploymentError!]!
  id: ID!
  logs: [DeploymentLog!]!
  schemaChanges: SchemaDeploymentSchemaChanges
  status: DeploymentStatus!
  tag: String!
}

type SchemaDeploymentSchemaChanges {
  changes("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int severity: SchemaChangeSeverity): SchemaChangesConnection
  previousSchema: SchemaVersion
  schema: SchemaVersion
  statistic: SchemaChangeLogStatistic!
}

type SchemaNotFoundError implements Error {
  apiId: ID!
  message: String!
  tag: String!
}

type SchemaRegistrySettings {
  allowBreakingSchemaChanges: Boolean!
  treatDangerousAsBreaking: Boolean!
}

type SchemaVersion {
  createdAt: DateTime!
  downloadUrl: String!
  id: ID!
  publishedTo: [PublishedSchemaVersion!]!
  tag: String!
  tags: [String!]! @deprecated(reason: "Use `tag` instead.")
}

type SchemaVersionChangeViolationError implements SchemaVersionValidationError & SchemaVersionPublishError & FusionConfigurationValidationError & ProcessingError {
  changes: [SchemaChangeLogEntry!]!
  message: String!
}

type SchemaVersionPublishFailed implements SchemaVersionPublishResult {
  errors: [SchemaVersionPublishError!]!
  state: ProcessingState!
}

type SchemaVersionPublishSuccess implements SchemaVersionPublishResult {
  changeLog: SchemaChangeLog
  state: ProcessingState!
}

type SchemaVersionRequestNotFoundError implements Error {
  message: String!
  requestId: ID!
}

type SchemaVersionSyntaxError implements SchemaVersionValidationError & SchemaVersionPublishError & ProcessingError {
  column: Int!
  line: Int!
  message: String!
  position: Int!
}

type SchemaVersionValidationFailed implements SchemaVersionValidationResult {
  errors: [SchemaVersionValidationError!]!
  state: ProcessingState!
}

type SchemaVersionValidationSuccess implements SchemaVersionValidationResult {
  changes: [SchemaChangeLogEntry!]!
  state: ProcessingState!
}

"A connection to a list of items."
type SchemaVersionsConnection {
  "A list of edges."
  edges: [SchemaVersionsEdge!]
  "A flattened list of the nodes."
  nodes: [SchemaVersion!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type SchemaVersionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SchemaVersion!
}

type SetActiveWorkspacePayload {
  errors: [SetActiveWorkspaceError!]
  workspace: Workspace
}

type Stage implements Node {
  api: Api
  changeLog("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int kind: [StageChangeLogKind!] "Returns the last _n_ elements from the list." last: Int): StageChangeLogConnection
  conditions: [StageCondition!]!
  deployments("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): DeploymentsConnection
  displayName: String!
  essentials: StageEssentials
  id: ID!
  logDistribution(from: DateTime! to: DateTime!): OpenTelemetryLogsSeverityGraph
  logs("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int from: DateTime "Returns the last _n_ elements from the list." last: Int to: DateTime): OpenTelemetryLogsConnection
  metrics: StageMetrics!
  name: String!
  publishedClients: [PublishedClient!]!
  publishedFusionConfiguration: FusionConfiguration
  publishedSchema: PublishedSchemaVersion
  subgraphs: [Subgraph!]!
  traceById(seeker: String spanId: String traceId: String!): OpenTelemetryTrace
}

"A connection to a list of items."
type StageChangeLogConnection {
  "A list of edges."
  edges: [StageChangeLogEdge!]
  "A flattened list of the nodes."
  nodes: [StageChangeLog!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type StageChangeLogEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: StageChangeLog!
}

type StageClientsMetrics {
  insights("Returns the elements in the list that come after the specified cursor." after: String "Returns the first _n_ elements from the list." first: Int from: DateTime! orderBy: [ClientInsightsOrderByInput!] to: DateTime!): ClientInsightsConnection
}

type StageErrorsMetrics {
  insights("Returns the elements in the list that come after the specified cursor." after: String "Returns the first _n_ elements from the list." first: Int from: DateTime! search: String to: DateTime!): ErrorInsightsConnection
}

type StageEssentials {
  clientCount: Int!
  lastPublishedAt: DateTime
  subgraphCount: Int!
  version: String
}

type StageLatencySummary {
  max: Float
  mean: Float
  min: Float
  p50: Float
  p95: Float
  p99: Float
}

type StageMetrics {
  clients: StageClientsMetrics!
  errors: StageErrorsMetrics!
  operation(hash: String! operationName: String!): StageOperationMetrics!
  operations: StageOperationsMetrics!
  resolver(coordinate: String!): StageResolverMetrics!
  resolvers: StageResolversMetrics!
  subgraphs: StageSubgraphsMetrics!
  transaction(name: String!): StageTransactionMetrics!
  transactions: StageTransactionsMetrics!
}

type StageNotFoundError implements Error {
  apiId: ID!
  message: String!
  name: String!
}

type StageOperationMetrics {
  latency(from: DateTime! to: DateTime!): OperationLatencyGraph
  latencyDistribution(from: DateTime! to: DateTime!): OperationLatencyDistributionGraph
  samples(from: DateTime! maxLatency: Float minLatency: Float to: DateTime!): [OperationTraceSample!]!
  throughput(from: DateTime! operationKinds: [OperationKind!] @deprecated(reason: "Not longer in use") to: DateTime!): OperationThroughputGraph
}

type StageOperationMetricsSummary {
  latency: StageLatencySummary
  throughput: StageThroughputSummary
}

type StageOperationsMetrics {
  insights("Returns the elements in the list that come after the specified cursor." after: String "Returns the first _n_ elements from the list." first: Int from: DateTime! operationKinds: [OperationKind!] orderBy: [OperationInsightsOrderByInput!] search: String to: DateTime!): OperationInsightsConnection
  latency(from: DateTime! operationKinds: [OperationKind!] to: DateTime!): OperationsLatencyGraph
  summary(from: DateTime! to: DateTime!): StageOperationMetricsSummary!
  throughput(from: DateTime! operationKinds: [OperationKind!] to: DateTime!): OperationsThroughputGraph
}

type StageResolverMetrics {
  latency(from: DateTime! to: DateTime!): ResolverLatencyGraph
  throughput(from: DateTime! to: DateTime!): ResolverThroughputGraph
}

type StageResolversMetrics {
  insights("Returns the elements in the list that come after the specified cursor." after: String "Returns the first _n_ elements from the list." first: Int from: DateTime! orderBy: [ResolverInsightsOrderByInput!] search: String to: DateTime!): ResolverInsightsConnection
}

type StageSubgraphsMetrics {
  insights("Returns the elements in the list that come after the specified cursor." after: String "Returns the first _n_ elements from the list." first: Int from: DateTime! orderBy: [SubgraphInsightsOrderByInput!] to: DateTime!): SubgraphInsightsConnection
}

type StageThroughputSummary {
  errorRate: Float
  opm: Float
  successRate: Float
  totalCount: Long
  totalCountWithError: Long
}

type StageTransactionMetrics {
  latency(from: DateTime! to: DateTime!): OpenTelemetryTransactionLatencyGraph
  latencyDistribution(from: DateTime! to: DateTime!): OpenTelemetryTransactionLatencyDistributionGraph
  samples(from: DateTime! maxLatency: Float minLatency: Float to: DateTime!): [OpenTelemetryTransactionTraceSample!]!
  throughput(from: DateTime! to: DateTime!): OpenTelemetryTransactionThroughputGraph
}

type StageTransactionMetricsSummary {
  latency: StageLatencySummary
  throughput: StageThroughputSummary
}

type StageTransactionsMetrics {
  insights("Returns the elements in the list that come after the specified cursor." after: String "Returns the first _n_ elements from the list." first: Int from: DateTime! orderBy: [OpenTelemetryTransactionInsightsOrderByInput!] search: String spanKinds: [OpenTelemetrySpanKind!] to: DateTime!): OpenTelemetryTransactionInsightsConnection
  latency(from: DateTime! spanKinds: [OpenTelemetrySpanKind!] to: DateTime!): OpenTelemetryTransactionsLatencyGraph
  summary(from: DateTime! to: DateTime!): StageTransactionMetricsSummary!
  throughput(from: DateTime! spanKinds: [OpenTelemetrySpanKind!] to: DateTime!): OpenTelemetryTransactionsThroughputGraph
}

type StageValidationError implements Error {
  message: String!
}

type StagesHavePublishedDependenciesError implements Error {
  message: String!
  stages: [Stage!]!
}

type StartFusionConfigurationCompositionPayload {
  errors: [StartFusionConfigurationCompositionError!]
  requestId: ID
}

type SubgraphInsight {
  averageLatency: Float
  errorRate: Float
  id: ID!
  impact: Float
  latency: SubgraphLatencyGraph
  name: String!
  opm: Float
  stage: Stage
  subgraph: Subgraph
  successRate: Float
  throughput: SubgraphThroughputGraph
  totalCount: Long
  totalCountWithErrors: Long
}

"A connection to a list of items."
type SubgraphInsightsConnection {
  "A list of edges."
  edges: [SubgraphInsightsEdge!]
  "A flattened list of the nodes."
  nodes: [SubgraphInsight!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type SubgraphInsightsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SubgraphInsight!
}

type SubgraphInvalidError implements Error {
  message: String!
}

type SubgraphLatencyGraph {
  dataset: [SubgraphLatencyGraphData!]!
}

type SubgraphLatencyGraphData {
  epoch: Long!
  max: Float!
  mean: Float!
  min: Float!
  p50: Float!
  p95: Float!
  p99: Float!
}

type SubgraphThroughputGraph {
  dataset: [SubgraphThroughputGraphData!]!
}

type SubgraphThroughputGraphData {
  epoch: Long!
  errorRate: Float!
  opm: Float!
  successRate: Float!
  totalCount: Long!
  totalCountWithError: Long!
}

type Subscription {
  onClientVersionPublishingUpdate(requestId: ID!): ClientVersionPublishResult!
  onClientVersionValidationUpdate(requestId: ID!): ClientVersionValidationResult!
  onFusionConfigurationPublishingTaskChanged(requestId: ID!): FusionConfigurationPublishingResult!
  onPersistedQueriesChanged(apiId: ID! stageName: String!): PersistedQueriesChanged!
  onSchemaVersionPublishingUpdate(requestId: ID!): SchemaVersionPublishResult!
  onSchemaVersionValidationUpdate(requestId: ID!): SchemaVersionValidationResult!
  onStageChangeLogAdded(apiId: ID! kind: [StageChangeLogKind!] stageName: String!): StageChangeLog!
  onStageDeploymentsChanged(stageId: ID!): DeploymentEvent!
}

type ThemeSettings {
  darkThemeName: String
  lightThemeName: String
  themeName: String
  usePreferredOsAppearance: Boolean!
}

type TunnelSession {
  expiresAt: DateTime!
  expiresIn: Int!
  sessionId: ID!
}

type TypeChanged implements SchemaChange {
  newType: String!
  oldType: String!
  severity: SchemaChangeSeverity!
}

type TypeSystemMemberAddedChange implements SchemaChange {
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type TypeSystemMemberModifiedChange implements SchemaChange {
  changes: [SchemaChange!]!
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type TypeSystemMemberRemovedChange implements SchemaChange {
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type UnauthorizedOperation implements Error {
  message: String!
}

type UnexpectedErrorOnChange implements Error {
  message: String!
  workspaceId: ID!
}

type UnexpectedErrorOnDocumentChange implements Error {
  message: String!
  workspaceId: ID!
}

type UnexpectedProcessingError implements SchemaVersionValidationError & SchemaVersionPublishError & ClientVersionValidationError & ClientVersionPublishError & FusionConfigurationPublishingError & FusionConfigurationValidationError & ProcessingError {
  message: String!
}

type UnionMemberAdded implements SchemaChange {
  severity: SchemaChangeSeverity!
  typeName: String!
}

type UnionMemberRemoved implements SchemaChange {
  severity: SchemaChangeSeverity!
  typeName: String!
}

type UnionModifiedChange implements SchemaChange {
  changes: [UnionChange!]!
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type UnpublishClientPayload {
  clientVersion: ClientVersion
  errors: [UnpublishClientError!]
}

type UpdateApiSettingsPayload {
  api: Api
  errors: [UpdateApiSettingsError!]
}

type UpdateFeatureFlagsPayload {
  errors: [UpdateFeatureFlagsError!]
  settings: UserSettings
}

type UpdateMockSchemaPayload {
  errors: [UpdateMockSchemaError!]
  mockSchema: MockSchema
}

type UpdatePreferencesPayload {
  errors: [UpdatePreferencesError!]
  preferences: Any
}

type UpdateStagesPayload {
  api: Api
  errors: [UpdateStagesError!]
}

type UpdateThemeSettingsPayload {
  errors: [UpdateThemeSettingsError!]
  settings: UserSettings
}

type UploadClientPayload {
  clientVersion: ClientVersion
  errors: [UploadClientError!]
}

type UploadSchemaPayload {
  errors: [UploadSchemaError!]
  schemaVersion: SchemaVersion
}

type User implements Node {
  id: ID!
  username: String!
}

type UserInfo {
  id: ID!
  username: String!
}

type UserSettings {
  featureFlags: [String!]!
  theme: ThemeSettings!
}

type ValidateClientPayload {
  errors: [ValidateClientError!]
  id: ID
}

type ValidateFusionConfigurationCompositionPayload {
  errors: [ValidateFusionConfigurationCompositionError!]
  requestId: ID
}

type ValidateSchemaPayload {
  errors: [ValidateSchemaError!]
  id: ID
}

type ValidationError implements Error {
  errors: [ValidationErrorProperty!]!
  message: String!
}

type ValidationErrorProperty {
  message: String!
}

type ValidationInProgress implements FusionConfigurationPublishingResult & ClientVersionValidationResult & SchemaVersionValidationResult {
  state: ProcessingState!
}

type Viewer {
  activeWorkspace: Workspace
  billingUrl: String
  manageTenantUrl: String
  organization: OrganizationInfo
  personalAccessTokens("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): PersonalAccessTokensConnection
  preferences: Any!
  sessionId: String!
  settings: UserSettings!
  user: User
  workspaces("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): WorkspacesConnection
}

type WaitForApproval implements SchemaVersionPublishResult & ClientVersionPublishResult & FusionConfigurationPublishingResult {
  deployment: Deployment
  state: ProcessingState!
}

type Workspace implements Node {
  apiKeys("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): ApiKeysConnection
  apis("Returns the elements in the list that come after the specified cursor." after: Version "Returns the first _n_ elements from the list." first: Int): ApisConnection
  changed(version: Version!): Boolean!
  changes("Returns the elements in the list that come after the specified cursor." after: Version "Returns the first _n_ elements from the list." first: Int): ChangesConnection
  documentChanges("Returns the elements in the list that come after the specified cursor." after: Version "Returns the first _n_ elements from the list." first: Int): DocumentChangesConnection   @deprecated(reason: "Use changes")
  documents("Returns the elements in the list that come after the specified cursor." after: Version "Returns the first _n_ elements from the list." first: Int): DocumentsConnection
  documentsChanged(version: Version): Boolean!  @deprecated(reason: "Use changed")
  environments("Returns the elements in the list that come after the specified cursor." after: Version "Returns the first _n_ elements from the list." first: Int): EnvironmentsConnection
  id: ID!
  members: [WorkspaceMember!]!
  name: String!
  personal: Boolean!
  version: Version!
}

type WorkspaceChangePayload {
  error: WorkspaceChangeError
  referenceId: String!
  result: WorkspaceChangeResult
}

type WorkspaceDocument implements Node {
  activeConnectionKind: String!
  body: String!
  createdAt: DateTime!
  createdBy: UserInfo!
  httpConnection: WorkspaceDocumentHttpConnection
  id: ID!
  modifiedAt: DateTime!
  modifiedBy: UserInfo!
  name: String!
  path: [String!]!
  variables: String
  version: Version!
  workspace: Workspace
}

type WorkspaceDocumentAuthentication {
  activeAuthenticationKind: String!
  basicOptions: BasicAuthenticationFlowOptions
  bearerOptions: BearerAuthenticationFlowOptions
  oAuth2Options: OAuth2AuthenticationFlowOptions
}

type WorkspaceDocumentChangeResult {
  document: WorkspaceDocument
  error: WorkspaceDocumentChangeError
  referenceId: String!
}

type WorkspaceDocumentHeader {
  enabled: Boolean!
  name: String!
  value: String!
}

type WorkspaceDocumentHttpConnection {
  authentication: WorkspaceDocumentAuthentication
  endpoint: String!
  headers: [WorkspaceDocumentHeader!]
  includeCookies: Boolean!
  sdlEndpoint: String
  sseSubscriptionEndpoint: String
  subscriptionEndpoint: String
  subscriptionProtocol: String
  useGet: Boolean!
  useTunnel: Boolean!
}

type WorkspaceMember {
  role: WorkspaceUserRole!
  user: UserInfo!
}

type WorkspaceNotFound implements Error {
  message: String!
  workspaceId: ID!
}

type WorkspaceNotFoundForChange implements Error {
  message: String!
  workspaceId: ID!
}

type WorkspaceNotFoundForDocument implements Error {
  message: String!
  workspaceId: ID!
}

"A connection to a list of items."
type WorkspacesConnection {
  "A list of edges."
  edges: [WorkspacesEdge!]
  "A flattened list of the nodes."
  nodes: [Workspace!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type WorkspacesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Workspace!
}

union ApiKeyReference = Api

union ApproveDeploymentError = UnauthorizedOperation | DeploymentNotFoundError | DeploymentIsNotWaitingForApprovalError

union ArgumentChange = DeprecatedChange | DescriptionChanged | TypeChanged

union BeginFusionConfigurationPublishError = UnauthorizedOperation | ApiNotFoundError | StageNotFoundError | SubgraphInvalidError | InvalidProcessingStateTransitionError

union CancelDeploymentError = UnauthorizedOperation | DeploymentNotFoundError | DeploymentCannotBeCancelledError

union CancelFusionConfigurationCompositionError = UnauthorizedOperation | FusionConfigurationRequestNotFoundError | InvalidProcessingStateTransitionError

union ClientDeploymentError = PersistedQueryValidationError

union CommitFusionConfigurationPublishError = UnauthorizedOperation | FusionConfigurationRequestNotFoundError | InvalidProcessingStateTransitionError

union CreateAccountError = UnauthorizedOperation

union CreateApiKeyForApiError = ApiNotFoundError | ValidationError | UnauthorizedOperation

union CreateClientError = ApiNotFoundError | UnauthorizedOperation

union CreateMockSchemaError = ApiNotFoundError | MockSchemaNonUniqueNameError | UnauthorizedOperation | ValidationError

union CreatePersonalAccessTokenError = ValidationError | UnauthorizedOperation

union CreateWorkspaceError = UnauthorizedOperation | ValidationError

union DeleteApiByIdError = ApiNotFoundError | UnauthorizedOperation | ApiDeletionFailedError

union DeleteApiKeyError = ApiKeyNotFoundError | UnauthorizedOperation

union DeleteClientByIdError = ClientNotFoundError | UnauthorizedOperation

union DeleteMockSchemaByIdError = MockSchemaNotFoundError | UnauthorizedOperation

union DeploymentEvent = DeploymentCreatedEvent | DeploymentUpdatedEvent

union DirectiveChange = ArgumentAdded | ArgumentChanged | ArgumentRemoved | DescriptionChanged | DirectiveLocationAdded | DirectiveLocationRemoved

union EnsureTunnelSessionError = UnauthorizedOperation

union EnumChange = DescriptionChanged | EnumValueAdded | EnumValueChanged | EnumValueRemoved

union EnumValueChange = DeprecatedChange | DescriptionChanged

union FieldChange = ArgumentAdded | ArgumentChanged | ArgumentRemoved | DeprecatedChange | DescriptionChanged | TypeChanged

union FusionConfigurationDeploymentError = PersistedQueryValidationError | SchemaChangeViolationError | InvalidGraphQLSchemaError

union InputFieldChange = DeprecatedChange | DescriptionChanged | TypeChanged

union InputObjectChange = DescriptionChanged | FieldAddedChange | FieldRemovedChange | InputFieldChanged

union InterfaceChange = DescriptionChanged | FieldAddedChange | FieldRemovedChange | InterfaceImplementationAdded | InterfaceImplementationRemoved | PossibleTypeAdded | PossibleTypeRemoved | OutputFieldChanged

union ObjectChange = DescriptionChanged | FieldAddedChange | FieldRemovedChange | InterfaceImplementationAdded | InterfaceImplementationRemoved | OutputFieldChanged

union OutputFieldChange = ArgumentAdded | ArgumentChanged | ArgumentRemoved | DeprecatedChange | DescriptionChanged | TypeChanged

union PollClientVersionPublishRequestError = ClientVersionRequestNotFoundError | UnauthorizedOperation

union PollClientVersionValidationRequestError = ClientVersionRequestNotFoundError | UnauthorizedOperation

union PollSchemaVersionPublishRequestError = SchemaVersionRequestNotFoundError | UnauthorizedOperation

union PollSchemaVersionValidationRequestError = SchemaVersionRequestNotFoundError | UnauthorizedOperation

union PublishClientError = StageNotFoundError | ClientNotFoundError | UnauthorizedOperation | ClientVersionNotFoundError

union PublishSchemaError = StageNotFoundError | ApiNotFoundError | SchemaNotFoundError | UnauthorizedOperation

union PushDocumentChangesError = UnauthorizedOperation | ChangeStructureInvalid

union PushWorkspaceChangesError = UnauthorizedOperation | ChangeStructureInvalid

union RemoveWorkspaceError = UnauthorizedOperation | WorkspaceNotFound | ValidationError

union RenameWorkspaceError = UnauthorizedOperation | WorkspaceNotFound | ValidationError

union RevokePersonalAccessTokenError = UnauthorizedOperation | PersonalAccessTokenNotFoundError

union ScalarChange = DescriptionChanged

union SchemaChangeLogEntry = DirectiveModifiedChange | EnumModifiedChange | InputObjectModifiedChange | InterfaceModifiedChange | ObjectModifiedChange | ScalarModifiedChange | TypeSystemMemberAddedChange | TypeSystemMemberModifiedChange | TypeSystemMemberRemovedChange | UnionModifiedChange

union SchemaDeploymentError = PersistedQueryValidationError | SchemaChangeViolationError | OperationsAreNotAllowedError | SchemaVersionSyntaxError | InvalidGraphQLSchemaError

union SchemaMemberChange = ArgumentAdded | ArgumentChanged | ArgumentRemoved | DescriptionChanged | DirectiveLocationAdded | DirectiveLocationRemoved | EnumValueAdded | EnumValueChanged | EnumValueRemoved | FieldAddedChange | FieldRemovedChange | InputFieldChanged | InterfaceImplementationAdded | InterfaceImplementationRemoved | PossibleTypeAdded | PossibleTypeRemoved | OutputFieldChanged | UnionMemberAdded | UnionMemberRemoved

union SetActiveWorkspaceError = UnauthorizedOperation | WorkspaceNotFound

union StageCondition = AfterStageCondition

union StartFusionConfigurationCompositionError = UnauthorizedOperation | FusionConfigurationRequestNotFoundError | InvalidProcessingStateTransitionError

union UnionChange = DescriptionChanged | UnionMemberAdded | UnionMemberRemoved

union UnpublishClientError = StageNotFoundError | ClientNotFoundError | UnauthorizedOperation | ClientVersionNotFoundError | ConcurrentOperationError

union UpdateApiSettingsError = ApiNotFoundError | UnauthorizedOperation

union UpdateFeatureFlagsError = UnauthorizedOperation | ValidationError

union UpdateMockSchemaError = MockSchemaNonUniqueNameError | MockSchemaNotFoundError | UnauthorizedOperation | ValidationError

union UpdatePreferencesError = UnauthorizedOperation | ValidationError

union UpdateStagesError = ApiNotFoundError | StageNotFoundError | StagesHavePublishedDependenciesError | StageValidationError

union UpdateThemeSettingsError = UnauthorizedOperation | ValidationError

union UploadClientError = ClientNotFoundError | ConcurrentOperationError | InvalidPersistedQueryError | UnauthorizedOperation | DuplicatedTagError

union UploadSchemaError = ApiNotFoundError | ConcurrentOperationError | DuplicatedTagError | UnauthorizedOperation

union ValidateClientError = StageNotFoundError | ClientNotFoundError | UnauthorizedOperation

union ValidateFusionConfigurationCompositionError = UnauthorizedOperation | FusionConfigurationRequestNotFoundError | InvalidProcessingStateTransitionError

union ValidateSchemaError = StageNotFoundError | SchemaNotFoundError | ApiNotFoundError | UnauthorizedOperation

union WorkspaceChangeError = ChangeValidationFailed | HasBeenChangedConflict | HasBeenDeletedConflict | IdentifierCollisionConflict | UnexpectedErrorOnChange | WorkspaceNotFoundForChange

union WorkspaceChangeResult = ApiDocument | Api | WorkspaceDocument | Environment

union WorkspaceDocumentChangeError = DocumentChangedConflict | DocumentNameCollisionConflict | DocumentDeletionConflict | UnexpectedErrorOnDocumentChange | DocumentChangeValidationFailed | WorkspaceNotFoundForDocument

input ApiCreateChangeInput {
  httpConnection: ApiHttpConnectionInput
  kind: ApiKind
  name: String!
  path: [String!]!
  referenceId: String!
  workspaceId: ID!
}

input ApiDeleteChangeInput {
  id: ID!
  referenceId: String!
  version: Version!
  workspaceId: ID!
}

input ApiDocumentCreateChangeInput {
  apiId: ID!
  body: String!
  name: String!
  path: [String!]!
  referenceId: String!
  variables: String
  workspaceId: ID!
}

input ApiDocumentDeleteChangeInput {
  apiId: ID!
  id: ID!
  referenceId: String!
  version: Version!
  workspaceId: ID!
}

input ApiDocumentUpdateChangeInput {
  apiId: ID!
  body: String!
  id: ID!
  name: String!
  path: [String!]!
  referenceId: String!
  variables: String
  version: Version!
  workspaceId: ID!
}

input ApiHeaderInput {
  enabled: Boolean!
  name: String!
  value: String!
}

input ApiHttpAuthenticationInput {
  activeAuthenticationKind: String!
  basicOptions: BasicAuthenticationFlowOptionsInput
  bearerOptions: BearerAuthenticationFlowOptionsInput
  oAuth2Options: OAuth2AuthenticationFlowOptionsInput
}

input ApiHttpConnectionInput {
  authentication: ApiHttpAuthenticationInput
  endpoint: String!
  headers: [ApiHeaderInput!]
  includeCookies: Boolean!
  sdlEndpoint: String
  sseSubscriptionEndpoint: String
  subscriptionEndpoint: String
  subscriptionProtocol: String
  useGet: Boolean!
  useTunnel: Boolean!
}

input ApiUpdateChangeInput {
  httpConnection: ApiHttpConnectionInput
  id: ID!
  kind: ApiKind
  name: String!
  path: [String!]!
  referenceId: String!
  version: Version!
  workspaceId: ID!
}

input ApproveDeploymentInput {
  deploymentId: ID!
}

input BasicAuthenticationFlowOptionsInput {
  password: String!
  username: String!
}

input BearerAuthenticationFlowOptionsInput {
  prefix: String
  token: String!
}

input BeginFusionConfigurationPublishInput {
  apiId: ID!
  stageName: String!
  subgraphApiId: ID
  subgraphName: String
  tag: String!
  waitForApproval: Boolean! = false
}

input CancelDeploymentInput {
  deploymentId: ID!
}

input CancelFusionConfigurationCompositionInput {
  requestId: ID!
}

input ClientInsightsOrderByInput {
  averageLatency: SortEnumType
  errorRate: SortEnumType
  impact: SortEnumType
  opm: SortEnumType
  totalCount: SortEnumType
  totalCountWithError: SortEnumType
}

input CommitFusionConfigurationPublishInput {
  configuration: Upload!
  requestId: ID!
}

input CreateApiKeyForApiInput {
  apiId: ID!
  name: String
}

input CreateClientInput {
  apiId: ID!
  name: String!
}

input CreateMockSchemaInput {
  apiId: ID!
  baseSchemaFile: Upload!
  downstreamUrl: String!
  extensionsSchemaFile: Upload!
  name: String!
}

input CreatePersonalAccessTokenInput {
  description: String!
  expiresAt: DateTime!
}

input CreateWorkspaceInput {
  name: String!
}

input DeleteApiByIdInput {
  apiId: ID!
}

input DeleteApiKeyInput {
  apiKeyId: ID!
}

input DeleteClientByIdInput {
  clientId: ID!
}

input DeleteMockSchemaByIdInput {
  mockSchemaId: ID!
}

input EnvironmentCreateChangeInput {
  name: String!
  referenceId: String!
  variables: [EnvironmentVariableInput!]! = [  ]
  workspaceId: ID!
}

input EnvironmentDeleteChangeInput {
  id: ID!
  referenceId: String!
  version: Version!
  workspaceId: ID!
}

input EnvironmentUpdateChangeInput {
  id: ID!
  name: String!
  referenceId: String!
  variables: [EnvironmentVariableInput!]! = [  ]
  version: Version!
  workspaceId: ID!
}

input EnvironmentVariableInput {
  id: String!
  isSecret: Boolean!
  name: String!
  value: String!
}

input OAuth2AuthenticationFlowOptionsInput {
  accessTokenUrl: String!
  activeFlowKind: String!
  audience: String!
  authorizationUrl: String!
  clientId: String!
  clientSecret: String!
  credentialsInBody: Boolean!
  grantType: String!
  origin: String!
  password: String!
  pkceMethod: String!
  prefix: String!
  redirectUrl: String!
  resource: String!
  responseType: String!
  scope: String!
  state: String!
  usePkce: Boolean!
  username: String!
}

input OpenTelemetryTransactionInsightsOrderByInput {
  averageLatency: SortEnumType
  errorRate: SortEnumType
  impact: SortEnumType
  opm: SortEnumType
  totalCount: SortEnumType
  totalCountWithError: SortEnumType
}

input OperationInsightsOrderByInput {
  averageLatency: SortEnumType
  errorRate: SortEnumType
  impact: SortEnumType
  opm: SortEnumType
  totalCount: SortEnumType
  totalCountWithError: SortEnumType
}

input PartialApiSettingsInput {
  schemaRegistry: PartialSchemaRegistrySettingsInput
}

input PartialSchemaRegistrySettingsInput {
  allowBreakingSchemaChanges: Boolean! = false
  treatDangerousAsBreaking: Boolean! = false
}

input PollClientVersionPublishRequestInput {
  id: ID!
}

input PollClientVersionValidationRequestInput {
  id: ID!
}

input PollSchemaVersionPublishRequestInput {
  id: ID!
}

input PollSchemaVersionValidationRequestInput {
  id: ID!
}

input PublishClientInput {
  clientId: ID!
  force: Boolean! = false
  stage: String!
  tag: String!
  waitForApproval: Boolean! = false
}

input PublishSchemaInput {
  apiId: ID!
  force: Boolean! = false
  stage: String!
  tag: String!
  waitForApproval: Boolean! = false
}

input PushApiChangeInput {
  create: ApiCreateChangeInput
  delete: ApiDeleteChangeInput
  update: ApiUpdateChangeInput
}

input PushApiDocumentChangeInput {
  create: ApiDocumentCreateChangeInput
  delete: ApiDocumentDeleteChangeInput
  update: ApiDocumentUpdateChangeInput
}

input PushDocumentChangeInput {
  changes: [WorkspaceDocumentInput!]!
}

input PushEnvironmentChangeInput {
  create: EnvironmentCreateChangeInput
  delete: EnvironmentDeleteChangeInput
  update: EnvironmentUpdateChangeInput
}

input PushWorkspaceChangeInput {
  api: PushApiChangeInput
  apiDocument: PushApiDocumentChangeInput
  document: PushWorkspaceDocumentChangeInput
  environment: PushEnvironmentChangeInput
}

input PushWorkspaceChangesInput {
  changes: [PushWorkspaceChangeInput!]!
}

input PushWorkspaceDocumentChangeInput {
  create: WorkspaceDocumentCreateChangeInput
  delete: WorkspaceDocumentDeleteChangeInput
  update: WorkspaceDocumentUpdateChangeInput
}

input RemoveWorkspaceInput {
  id: ID!
}

input RenameWorkspaceInput {
  id: ID!
  name: String!
}

input ResolverInsightsOrderByInput {
  averageLatency: SortEnumType
  errorRate: SortEnumType
  impact: SortEnumType
  opm: SortEnumType
  totalCount: SortEnumType
  totalCountWithError: SortEnumType
}

input RevokePersonalAccessTokenInput {
  id: ID!
}

input SetActiveWorkspaceInput {
  workspaceId: ID!
}

input StageConditionUpdateInput {
  afterStage: String!
}

input StageUpdateInput {
  conditions: [StageConditionUpdateInput!]! = [  ]
  displayName: String!
  name: String!
}

input StartFusionConfigurationCompositionInput {
  requestId: ID!
}

input SubgraphInsightsOrderByInput {
  averageLatency: SortEnumType
  errorRate: SortEnumType
  impact: SortEnumType
  opm: SortEnumType
  totalCount: SortEnumType
  totalCountWithError: SortEnumType
}

input UnpublishClientInput {
  clientId: ID!
  stage: String!
  tag: String!
}

input UpdateApiSettingsInput {
  apiId: ID!
  settings: PartialApiSettingsInput!
}

input UpdateFeatureFlagsInput {
  featureFlags: [String!]!
}

input UpdateMockSchemaInput {
  baseSchemaFile: Upload
  downstreamUrl: String
  extensionsSchemaFile: Upload
  id: ID!
  name: String
}

input UpdatePreferencesInput {
  preferences: Any!
}

input UpdateStagesInput {
  apiId: ID!
  updatedStages: [StageUpdateInput!]!
}

input UpdateThemeSettingsInput {
  darkThemeName: String
  lightThemeName: String
  themeName: String
  usePreferredOsAppearance: Boolean!
}

input UploadClientInput {
  clientId: ID!
  operations: Upload!
  tag: String!
}

input UploadSchemaInput {
  apiId: ID!
  schema: Upload!
  tag: String!
}

input ValidateClientInput {
  clientId: ID!
  operations: Upload!
  stage: String!
}

input ValidateFusionConfigurationCompositionInput {
  configuration: Upload!
  requestId: ID!
}

input ValidateSchemaInput {
  apiId: ID!
  schema: Upload!
  stage: String!
}

input WorkspaceDocumentAuthenticationInput {
  activeAuthenticationKind: String!
  basicOptions: BasicAuthenticationFlowOptionsInput
  bearerOptions: BearerAuthenticationFlowOptionsInput
  oAuth2Options: OAuth2AuthenticationFlowOptionsInput
}

input WorkspaceDocumentChangeInput {
  activeConnectionKind: String!
  body: String!
  httpConnection: WorkspaceDocumentHttpConnectionInput
  id: ID
  name: String!
  path: [String!]!
  referenceId: String!
  variables: String
  version: Version
  workspaceId: ID!
}

input WorkspaceDocumentCreateChangeInput {
  activeConnectionKind: String!
  body: String!
  httpConnection: WorkspaceDocumentHttpConnectionInput
  name: String!
  path: [String!]!
  referenceId: String!
  variables: String
  workspaceId: ID!
}

input WorkspaceDocumentDeleteChangeInput {
  id: ID!
  referenceId: String!
  version: Version!
  workspaceId: ID!
}

input WorkspaceDocumentDeleteInput {
  id: ID!
  referenceId: String!
  version: Version!
  workspaceId: ID!
}

input WorkspaceDocumentHeaderInput {
  enabled: Boolean!
  name: String!
  value: String!
}

input WorkspaceDocumentHttpConnectionInput {
  authentication: WorkspaceDocumentAuthenticationInput
  endpoint: String!
  headers: [WorkspaceDocumentHeaderInput!]
  includeCookies: Boolean!
  sdlEndpoint: String
  sseSubscriptionEndpoint: String
  subscriptionEndpoint: String
  subscriptionProtocol: String
  useGet: Boolean!
  useTunnel: Boolean!
}

input WorkspaceDocumentInput {
  delete: WorkspaceDocumentDeleteInput
  put: WorkspaceDocumentChangeInput
}

input WorkspaceDocumentUpdateChangeInput {
  activeConnectionKind: String!
  body: String!
  httpConnection: WorkspaceDocumentHttpConnectionInput
  id: ID!
  name: String!
  path: [String!]!
  referenceId: String!
  variables: String
  version: Version!
  workspaceId: ID!
}

enum ApiKind {
  COLLECTION
  SERVICE
  GATEWAY
}

"Defines when a policy shall be executed."
enum ApplyPolicy {
  "Before the resolver was executed."
  BEFORE_RESOLVER
  "After the resolver was executed."
  AFTER_RESOLVER
  "The policy is applied in the validation step before the execution."
  VALIDATION
}

enum DeploymentStatus {
  QUEUED
  READY
  PROCESSING
  WAITING_FOR_APPROVAL
  APPROVED
  SUCCEEDED
  FAILED
  CANCELLED
}

enum DirectiveLocation {
  QUERY
  MUTATION
  SUBSCRIPTION
  FIELD
  FRAGMENT_DEFINITION
  FRAGMENT_SPREAD
  INLINE_FRAGMENT
  VARIABLE_DEFINITION
  SCHEMA
  SCALAR
  OBJECT
  FIELD_DEFINITION
  ARGUMENT_DEFINITION
  INTERFACE
  UNION
  ENUM
  ENUM_VALUE
  INPUT_OBJECT
  INPUT_FIELD_DEFINITION
}

enum OpenTelemetrySpanKind {
  UNSPECIFIED
  SERVER
  CLIENT
  INTERNAL
  PRODUCER
  CONSUMER
}

enum OperationKind {
  QUERY
  SUBSCRIPTION
  MUTATION
}

enum ProcessingState {
  QUEUED
  READY
  PROCESSING
  SUCCESS
  FAILED
  CANCELLED
  WAITING_FOR_APPROVAL
  APPROVED
}

enum SchemaChangeSeverity {
  SAFE
  DANGEROUS
  BREAKING
}

enum SortEnumType {
  ASC
  DESC
}

enum StageChangeLogKind {
  SCHEMA
  CLIENT
  FUSION_CONFIGURATION
}

enum TypeSystemMemberKind {
  OBJECT
  ENUM
  INPUT_OBJECT
  DIRECTIVE
  INTERFACE
  UNION
  SCALAR
}

enum WorkspaceUserRole {
  OWNER
  ADMINISTRATOR
  MEMBER
}

"The authorize directive."
directive "Defines when when the authorize directive shall be applied.By default the authorize directives are applied during the validation phase." apply: ApplyPolicy! = BEFORE_RESOLVER "The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!]) on OBJECT | FIELD_DEFINITION

"The purpose of the  directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overalery or response."
directive  on SENUM | INPUT_FIELD_DEFINITION

"The `@defer` directive may be provided for fragment spreads and inline fragments to inform the executor to delay the execution of the current fragment to indicate deprioritization of the current fragment. A query with `@defer` directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred is delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`."
directive @defer("Deferred when true." if: Boolean "If this argument label has a value other than null, it will be passed on to the result of this defer directive. This label is intended to give client applications a way to identify to which fragment a deferred result belongs to." label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"The purpose of the `` directive is to either inform the static analysis about the size of returned lists  or to point the analysis to where to find that information."
directive  on FIELD_DEFINITIO

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy("The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types." url: String!) on SCALAR

scalar Any

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

scalar URL @specifiedBy(url: "https:\/\/tools.ietf.org\/html\/rfc3986")

scalar UUID @specifiedBy(url: "https:\/\/tools.ietf.org\/html\/rfc4122")

"The `Upload` scalar type represents a file upload."
scalar Upload

scalar Version
