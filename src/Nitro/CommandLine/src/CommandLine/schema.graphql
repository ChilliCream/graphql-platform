schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

interface ApiChangeLog implements WorkspaceChangeLog {
  apiId: ID!
  changedAt: DateTime!
  changedBy: UserInfo!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

interface ApiDocumentChangeLog implements WorkspaceChangeLog {
  apiId: ID!
  changedAt: DateTime!
  changedBy: UserInfo!
  documentId: ID!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

interface ClientVersionPublishError {
  message: String!
}

interface ClientVersionPublishResult {
  state: ProcessingState!
}

interface ClientVersionValidationError {
  message: String!
}

interface ClientVersionValidationResult {
  state: ProcessingState!
}

interface CoordinateMetrics {
  clientUsage(
    clientId: ID
    from: DateTime!
    to: DateTime!
  ): CoordinateClientUsage
  clientUsages(from: DateTime!, to: DateTime!): [CoordinateClientUsage!]!
  requests(
    from: DateTime!
    resolution: Int! = 300
    to: DateTime!
  ): CoordinateRequestGraph
  usages(
    from: DateTime!
    resolution: Int! = 300
    to: DateTime!
  ): CoordinateUsageGraph
}

interface Deployment {
  approval: DeploymentApproval
  createdAt: DateTime!
  id: ID!
  logs: [DeploymentLog!]!
  status: DeploymentStatus!
  tag: String!
}

interface DeploymentLog {
  message: String!
  timestamp: DateTime!
}

interface DocumentChangeLog implements WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  documentId: ID!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

interface EnvironmentChangeLog implements WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  environmentId: ID!
  id: ID!
  name: String!
  version: Version!
  workspaceId: ID!
}

interface Error {
  message: String!
}

interface FusionConfigurationPublishingError {
  message: String!
}

interface FusionConfigurationPublishingResult {
  state: ProcessingState!
}

interface FusionConfigurationValidationError {
  message: String!
}

interface GraphQLInputValueDefinition implements GraphQLTypeSystemMember {
  coordinate: String!
  id: ID!
  isDeprecated: Boolean!
  metrics: CoordinateMetrics!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

interface GraphQLOutputFieldArgumentDefinition implements GraphQLTypeSystemMember & GraphQLInputValueDefinition {
  coordinate: String!
  declaringField: String!
  declaringType: String!
  id: ID!
  isDeprecated: Boolean!
  metrics: CoordinateMetrics!
  name: String!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

interface GraphQLOutputFieldDefinition implements GraphQLTypeSystemMember {
  arguments: GraphQLOutputFieldDefinitionArgumentsConnection!
  coordinate: String!
  id: ID!
  isDeprecated: Boolean!
  metrics: CoordinateMetrics!
  name: String!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

interface GraphQLOutputFieldDefinitionArgumentsConnection {
  nodes: [GraphQLOutputFieldArgumentDefinition!]!
}

interface GraphQLTypeSystemMember {
  coordinate: String!
  isDeprecated: Boolean!
  metrics: CoordinateMetrics
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

interface GroupMember {
  assignedAt: DateTime!
  group: Group
  id: ID!
}

"The node interface is implemented by entities that have a global unique identifier."
interface Node {
  id: ID!
}

interface OpenApiCollectionValidationEntity {
  errors: [OpenApiCollectionValidationEntityError!]!
}

interface OpenApiCollectionValidationEntityError {
  message: String!
}

interface OpenApiCollectionVersionPublishError {
  message: String!
}

interface OpenApiCollectionVersionPublishResult {
  state: ProcessingState!
}

interface OpenApiCollectionVersionValidationError {
  message: String!
}

interface OpenApiCollectionVersionValidationResult {
  state: ProcessingState!
}

interface OpenTelemetryAttribute {
  key: String!
}

interface OpenTelemetrySpan {
  api: Api
  clockSkew: Float
  duration: Float!
  epoch: Float!
  events: [OpenTelemetryTraceEvent!]!
  links: [OpenTelemetryTraceLink!]!
  parentSpanId: String!
  resourceAttributes: [Attribute!]!
  spanAttributes: [Attribute!]!
  spanId: String!
  spanKind: String!
  spanName: String!
  stage: Stage
  statusCode: String!
  statusMessage: String!
  traceId: String!
  traceState: String!
}

interface PermissionScope {
  id: ID!
  type: String!
}

interface ProcessingError {
  message: String!
}

interface SchemaChange {
  severity: SchemaChangeSeverity!
}

interface SchemaVersionPublishError {
  message: String!
}

interface SchemaVersionPublishResult {
  state: ProcessingState!
}

interface SchemaVersionValidationError {
  message: String!
}

interface SchemaVersionValidationResult {
  state: ProcessingState!
}

interface StageChangeLog {
  changedAt: DateTime!
  id: ID!
  kind: StageChangeLogKind!
  tag: String!
}

interface Subgraph {
  api: Api
  id: ID!
  name: String!
}

interface WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  id: ID!
  version: Version!
  workspaceId: ID!
}

type AfterStageCondition {
  afterStage: Stage
}

type Api implements Node {
  clients(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): ClientsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  createdAt: DateTime!
  createdBy: UserInfo!
  documents(
    "Returns the elements in the list that come after the specified cursor."
    after: Version
    "Returns the first _n_ elements from the list."
    first: Int
  ): ApiDocumentConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  httpConnection: ApiHttpConnection
  id: ID!
  kind: ApiKind
  mockSchemas(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): MockSchemasConnection
<<<<<<< HEAD
  modifiedAt: DateTime!
  modifiedBy: UserInfo!
  name: String!
  openApiCollections(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): ApiOpenApiCollectionsConnection
=======

  modifiedAt: DateTime!
  modifiedBy: UserInfo!
  name: String!
>>>>>>> origin/main
  operations(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): OperationsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  path: [String!]!
  schemaVersions(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): SchemaVersionsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  settings: ApiSettings!
  stages: [Stage!]!
  version: Version!
  workspace: Workspace
}

type ApiChanged implements ApiChangeLog & WorkspaceChangeLog {
  api(onlyIfLatest: Boolean): Api
  apiId: ID!
  changedAt: DateTime!
  changedBy: UserInfo!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

type ApiCreated implements ApiChangeLog & WorkspaceChangeLog {
  api(onlyIfLatest: Boolean): Api
  apiId: ID!
  changedAt: DateTime!
  changedBy: UserInfo!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

type ApiDeleted implements ApiChangeLog & WorkspaceChangeLog {
  api(onlyIfLatest: Boolean): Api
  apiId: ID!
  changedAt: DateTime!
  changedBy: UserInfo!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

type ApiDeletionFailedError implements Error {
  apiId: ID!
  message: String!
}

type ApiDocument implements Node {
  api: Api
  body: String!
  createdAt: DateTime!
  createdBy: UserInfo!
  id: ID!
  modifiedAt: DateTime!
  modifiedBy: UserInfo!
  name: String!
  path: [String!]!
  variables: String
  version: Version!
}

type ApiDocumentChanged implements ApiDocumentChangeLog & WorkspaceChangeLog {
  apiDocument(onlyIfLatest: Boolean): ApiDocument
  apiId: ID!
  changedAt: DateTime!
  changedBy: UserInfo!
  documentId: ID!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

"A connection to a list of items."
type ApiDocumentConnection {
  "A list of edges."
  edges: [ApiDocumentEdge!]
  "A flattened list of the nodes."
  nodes: [ApiDocument!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

type ApiDocumentCreated implements ApiDocumentChangeLog & WorkspaceChangeLog {
  apiDocument(onlyIfLatest: Boolean): ApiDocument
  apiId: ID!
  changedAt: DateTime!
  changedBy: UserInfo!
  documentId: ID!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

type ApiDocumentDeleted implements ApiDocumentChangeLog & WorkspaceChangeLog {
  apiDocument(onlyIfLatest: Boolean): ApiDocument
  apiId: ID!
  changedAt: DateTime!
  changedBy: UserInfo!
  documentId: ID!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

"An edge in a connection."
type ApiDocumentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ApiDocument!
}

"A connection to a list of items."
type ApiDocumentsConnection {
  "A list of edges."
  edges: [ApiDocumentsEdge!]
  "A flattened list of the nodes."
  nodes: [ApiDocument!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ApiDocumentsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ApiDocument!
}

type ApiHeader {
  enabled: Boolean!
  name: String!
  value: String!
}

type ApiHttpAuthentication {
  activeAuthenticationKind: String!
  basicOptions: BasicAuthenticationFlowOptions
  bearerOptions: BearerAuthenticationFlowOptions
  oAuth2Options: OAuth2AuthenticationFlowOptions
}

type ApiHttpConnection {
  authentication: ApiHttpAuthentication
  endpoint: String!
  headers: [ApiHeader!]
  includeCookies: Boolean!
  sdlEndpoint: String
  sseSubscriptionEndpoint: String
  subscriptionEndpoint: String
  subscriptionProtocol: String
  useGet: Boolean!
  useTunnel: Boolean!
}

type ApiKey implements Node {
  createdBy: UserInfo!
  id: ID!
  name: String!
  roleAssignments(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): ApiKeyRoleAssignmentsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  scopes: [ApiKeyScope!]!
  workspace: Workspace
}

type ApiKeyNotFoundError implements Error {
  apiKeyId: ID!
  message: String!
}

"A connection to a list of items."
type ApiKeyRoleAssignmentsConnection {
  "A list of edges."
  edges: [ApiKeyRoleAssignmentsEdge!]
  "A flattened list of the nodes."
  nodes: [RoleAssignment!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ApiKeyRoleAssignmentsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: RoleAssignment!
}

type ApiKeyScope {
  kind: String!
  reference: ApiKeyReference
  referenceId: String!
}

type ApiKeyWithSecret {
  key: ApiKey!
  secret: String!
}

"A connection to a list of items."
type ApiKeysConnection {
  "A list of edges."
  edges: [ApiKeysEdge!]
  "A flattened list of the nodes."
  nodes: [ApiKey!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ApiKeysEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ApiKey!
}

type ApiNotFoundError implements Error {
  apiId: ID!
  message: String!
}

"A connection to a list of items."
type ApiOpenApiCollectionsConnection {
  "A list of edges."
  edges: [ApiOpenApiCollectionsEdge!]
  "A flattened list of the nodes."
  nodes: [OpenApiCollection!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ApiOpenApiCollectionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: OpenApiCollection!
}

type ApiPermissionScope implements PermissionScope {
  api: Api
  id: ID!
  type: String!
}

type ApiSettings {
  schemaRegistry: SchemaRegistrySettings!
}

"A connection to a list of items."
type ApisConnection {
  "A list of edges."
  edges: [ApisEdge!]
  "A flattened list of the nodes."
  nodes: [Api!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ApisEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Api!
}

type ApproveDeploymentPayload {
  deployment: Deployment
  errors: [ApproveDeploymentError!]
}

type ArgumentAdded implements SchemaChange {
  coordinate: String!
  name: String!
  severity: SchemaChangeSeverity!
  typeName: String!
}

type ArgumentChanged implements SchemaChange {
  changes: [ArgumentChange!]!
  coordinate: String!
  name: String!
  severity: SchemaChangeSeverity!
}

type ArgumentRemoved implements SchemaChange {
  coordinate: String!
  name: String!
  severity: SchemaChangeSeverity!
  typeName: String!
}

type Attribute {
  key: String!
  value: String!
}

type AuthorizationEventLog {
  effect: AuthorizationEventEffect!
  eventId: UUID!
  eventType: AuthorizationEventType!
  isConditional: Boolean!
  organization: Organization
  permission: String!
  principal: AuthorizationEventLogPrincipal
  realm: AuthorizationEventLogRealm
  resource: AuthorizationEventLogResource
  subject: AuthorizationEventLogSubject
  timestamp: DateTime!
  traceId: String!
  workspace: Workspace
}

type BasicAuthenticationFlowOptions {
  password: String!
  username: String!
}

type BearerAuthenticationFlowOptions {
  prefix: String
  token: String!
}

type BeginFusionConfigurationPublishPayload {
  errors: [BeginFusionConfigurationPublishError!]
  requestId: ID
}

type CancelDeploymentPayload {
  deployment: Deployment
  errors: [CancelDeploymentError!]
}

type CancelFusionConfigurationCompositionPayload {
  errors: [CancelFusionConfigurationCompositionError!]
  requestId: ID
}

type ChangeStructureInvalid implements Error {
  message: String!
}

type ChangeValidationFailed implements Error {
  errors: [ValidationErrorProperty!]!
  message: String!
  workspaceId: ID!
}

"A connection to a list of items."
type ChangesConnection {
  "A list of edges."
  edges: [ChangesEdge!]
  "A flattened list of the nodes."
  nodes: [WorkspaceChangeLog]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ChangesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: WorkspaceChangeLog
}

type Client implements Node {
  api: Api
  createdAt: DateTime!
  createdBy: UserInfo!
  id: ID!
  name: String!
  operations(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): OperationsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  versions(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): ClientVersionConnection
}

type ClientChangeLog implements StageChangeLog & Node {
  changedAt: DateTime!
  id: ID!
  kind: StageChangeLogKind!
  tag: String!
}

type ClientDeployment implements Node & Deployment {
  approval: DeploymentApproval
  client: Client
  createdAt: DateTime!
  errors: [ClientDeploymentError!]!
  id: ID!
  logs: [DeploymentLog!]!
  status: DeploymentStatus!
  tag: String!
}

type ClientInsight {
  averageLatency: Float
  client: Client
  errorRate: Float
  id: ID!
  impact: Float
  name: String
  opm: Float
  successRate: Float
  totalCount: Long
  totalCountWithErrors: Long
}

"A connection to a list of items."
type ClientInsightsConnection {
  "A list of edges."
  edges: [ClientInsightsEdge!]
  "A flattened list of the nodes."
  nodes: [ClientInsight!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ClientInsightsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ClientInsight!
}

type ClientNotFoundError implements Error {
  clientId: ID!
  message: String!
}

type ClientVersion implements Node {
  client: Client
  createdAt: DateTime!
  id: ID!
  persistedQueries(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): PersistedQueriesConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  publishedTo: [PublishedClientVersion!]!
  tag: String!
  tags: [String!]! @deprecated(reason: "Use `tag` instead.")
}

"A connection to a list of items."
type ClientVersionConnection {
  "A list of edges."
  edges: [ClientVersionEdge!]
  "A flattened list of the nodes."
  nodes: [ClientVersion!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ClientVersionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ClientVersion!
}

type ClientVersionNotFoundError implements Error {
  clientId: ID!
  message: String!
  tag: String!
}

type ClientVersionPublishFailed implements ClientVersionPublishResult {
  errors: [ClientVersionPublishError!]!
  state: ProcessingState!
}

type ClientVersionPublishSuccess implements ClientVersionPublishResult {
  clientVersion: ClientVersion
  state: ProcessingState!
}

type ClientVersionRequestNotFoundError implements Error {
  message: String!
  requestId: ID!
}

type ClientVersionValidationFailed implements ClientVersionValidationResult {
  errors: [ClientVersionValidationError!]!
  state: ProcessingState!
}

type ClientVersionValidationSuccess implements ClientVersionValidationResult {
  state: ProcessingState!
}

"A connection to a list of items."
type ClientsConnection {
  "A list of edges."
  edges: [ClientsEdge!]
  "A flattened list of the nodes."
  nodes: [Client!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ClientsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Client!
}

type CommitFusionConfigurationPublishPayload {
  errors: [CommitFusionConfigurationPublishError!]
  requestId: ID
}

type ConcurrentOperationError implements Error & SchemaVersionPublishError & ClientVersionPublishError & FusionConfigurationPublishingError & OpenApiCollectionVersionPublishError & ProcessingError {
  message: String!
}

type CoordinateClientUsage {
  client: Client
  metrics: CoordinateClientUsageMetrics!
  name: String
  totalOperations: Long!
  totalRequests: Long!
  totalVersions: Long!
}

type CoordinateClientUsageMetrics implements Node {
  id: ID!
  operations(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): CoordinateClientUsageOperationInsightsConnection
}

type CoordinateClientUsageOperationInsight {
  averageLatency: Float!
  coordinate: String!
  errorRate: Float!
  hash: String!
  impact: Float!
  kind: OperationKind
  operationName: String!
  opm: Float!
  successRate: Float!
  totalCount: Long!
  totalCountWithErrors: Long!
  totalVersions: Long!
}

"A connection to a list of items."
type CoordinateClientUsageOperationInsightsConnection {
  "A list of edges."
  edges: [CoordinateClientUsageOperationInsightsEdge!]
  "A flattened list of the nodes."
  nodes: [CoordinateClientUsageOperationInsight!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CoordinateClientUsageOperationInsightsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CoordinateClientUsageOperationInsight!
}

type CoordinateRequestGraph {
  dataset: [CoordinateRequestGraphData!]!
}

type CoordinateRequestGraphData {
  count: Long!
  epoch: Long!
}

type CoordinateUsage {
  clientCount: Long!
  errorRate: Float
  firstSeen: DateTime
  lastSeen: DateTime
  meanDuration: Float
  operationCount: Long!
  opm: Float
  totalReference: Long! @deprecated(reason: "Use totalReferences instead")
  totalReferences: Long!
  totalRequests: Long
  totalUsages: Long
}

type CoordinateUsageGraph {
  dataset: [CoordinateUsageGraphData!]!
}

type CoordinateUsageGraphData {
  count: Long!
  epoch: Long!
}

"A connection to a list of items."
type CoordinatesConnection {
  "A list of edges."
  edges: [CoordinatesEdge!]
  "A flattened list of the nodes."
  nodes: [GraphQLTypeSystemMember!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CoordinatesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GraphQLTypeSystemMember!
}

type CreateAccountPayload {
  errors: [CreateAccountError!]
  user: User
}

type CreateApiKeyForApiPayload {
  errors: [CreateApiKeyForApiError!]
  result: ApiKeyWithSecret
}

type CreateApiKeyPayload {
  errors: [CreateApiKeyError!]
  result: ApiKeyWithSecret
}

type CreateClientPayload {
  client: Client
  errors: [CreateClientError!]
}

type CreateMockSchemaPayload {
  errors: [CreateMockSchemaError!]
  mockSchema: MockSchema
}

type CreateOpenApiCollectionPayload {
  errors: [CreateOpenApiCollectionError!]
  openApiCollection: OpenApiCollection
}

type CreatePersonalAccessTokenPayload {
  errors: [CreatePersonalAccessTokenError!]
  result: PersonalAccessTokenWithSecret
}

type CreateWorkspacePayload {
  errors: [CreateWorkspaceError!]
  workspace: Workspace
}

type DeleteApiByIdPayload {
  api: Api
  errors: [DeleteApiByIdError!]
}

type DeleteApiKeyPayload {
  apiKey: ApiKey
  errors: [DeleteApiKeyError!]
}

type DeleteClientByIdPayload {
  client: Client
  errors: [DeleteClientByIdError!]
}

type DeleteMockSchemaByIdPayload {
  errors: [DeleteMockSchemaByIdError!]
  mockSchema: MockSchema
}

type DeleteOpenApiCollectionByIdPayload {
  errors: [DeleteOpenApiCollectionByIdError!]
  openApiCollection: OpenApiCollection
}

type DeploymentApproval {
  approvedAt: DateTime!
  approvedBy: UserInfo!
}

type DeploymentApprovedLog implements DeploymentLog {
  message: String!
  timestamp: DateTime!
}

type DeploymentCancelledLog implements DeploymentLog {
  message: String!
  timestamp: DateTime!
}

type DeploymentCannotBeCancelledError implements Error {
  deploymentId: ID!
  message: String!
  status: DeploymentStatus!
}

type DeploymentCreatedEvent {
  deployment: Deployment!
}

type DeploymentCreatedLog implements DeploymentLog {
  message: String!
  timestamp: DateTime!
}

type DeploymentFailedLog implements DeploymentLog {
  errors: [ProcessingError!]!
  message: String!
  timestamp: DateTime!
}

type DeploymentIsNotWaitingForApprovalError implements Error {
  deploymentId: ID!
  message: String!
}

type DeploymentNotFoundError implements Error {
  deploymentId: ID!
  message: String!
}

type DeploymentQueuedLog implements DeploymentLog {
  message: String!
  timestamp: DateTime!
}

type DeploymentReadyLog implements DeploymentLog {
  message: String!
  timestamp: DateTime!
}

type DeploymentStartedProcessingLog implements DeploymentLog {
  message: String!
  timestamp: DateTime!
}

type DeploymentSuccessLog implements DeploymentLog {
  message: String!
  timestamp: DateTime!
}

type DeploymentUpdatedEvent {
  deployment: Deployment!
}

type DeploymentWaitingForApprovalLog implements DeploymentLog {
  message: String!
  timestamp: DateTime!
}

"A connection to a list of items."
type DeploymentsConnection {
  "A list of edges."
  edges: [DeploymentsEdge!]
  "A flattened list of the nodes."
  nodes: [Deployment!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DeploymentsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Deployment!
}

type DeprecatedChange implements SchemaChange {
  deprecationReason: String
  severity: SchemaChangeSeverity!
}

type DescriptionChanged implements SchemaChange {
  new: String
  old: String
  severity: SchemaChangeSeverity!
}

type DirectiveLocationAdded implements SchemaChange {
  location: DirectiveLocation!
  severity: SchemaChangeSeverity!
}

type DirectiveLocationRemoved implements SchemaChange {
  location: DirectiveLocation!
  severity: SchemaChangeSeverity!
}

type DirectiveModifiedChange implements SchemaChange {
  changes: [DirectiveChange!]!
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type DocumentChangeValidationFailed implements Error {
  errors: [ValidationErrorProperty!]!
  message: String!
  workspaceId: ID!
}

type DocumentChanged implements DocumentChangeLog & WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  document(onlyIfLatest: Boolean): WorkspaceDocument
  documentId: ID!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

type DocumentChangedConflict implements Error {
  document: WorkspaceDocument!
  message: String!
}

"A connection to a list of items."
type DocumentChangesConnection {
  "A list of edges."
  edges: [DocumentChangesEdge!]
  "A flattened list of the nodes."
  nodes: [DocumentChangeLog]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DocumentChangesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DocumentChangeLog
}

type DocumentCreated implements DocumentChangeLog & WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  document(onlyIfLatest: Boolean): WorkspaceDocument
  documentId: ID!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

type DocumentDeleted implements DocumentChangeLog & WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  document(onlyIfLatest: Boolean): WorkspaceDocument
  documentId: ID!
  id: ID!
  name: String!
  path: [String!]!
  version: Version!
  workspaceId: ID!
}

type DocumentDeletionConflict implements Error {
  message: String!
  workspaceId: ID!
}

type DocumentNameCollisionConflict implements Error {
  document: WorkspaceDocument!
  message: String!
}

"A connection to a list of items."
type DocumentsConnection {
  "A list of edges."
  edges: [DocumentsEdge!]
  "A flattened list of the nodes."
  nodes: [WorkspaceDocument!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DocumentsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: WorkspaceDocument!
}

type DuplicatedTagError implements Error {
  message: String!
  tag: String!
}

type EnsureTunnelSessionPayload {
  errors: [EnsureTunnelSessionError!]
  tunnelSession: TunnelSession
}

type EnumModifiedChange implements SchemaChange {
  changes: [EnumChange!]!
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type EnumValueAdded implements SchemaChange {
  coordinate: String!
  severity: SchemaChangeSeverity!
  value: String!
}

type EnumValueChanged implements SchemaChange {
  changes: [EnumValueChange!]!
  coordinate: String!
  severity: SchemaChangeSeverity!
  value: String!
}

type EnumValueRemoved implements SchemaChange {
  coordinate: String!
  severity: SchemaChangeSeverity!
  value: String!
}

type Environment implements Node {
  createdAt: DateTime!
  createdBy: UserInfo!
  id: ID!
  modifiedAt: DateTime!
  modifiedBy: UserInfo!
  name: String!
  variables: [EnvironmentVariable!]!
  version: Version!
  workspace: Workspace
}

type EnvironmentChanged implements EnvironmentChangeLog & WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  environment(onlyIfLatest: Boolean): Environment
  environmentId: ID!
  id: ID!
  name: String!
  version: Version!
  workspaceId: ID!
}

type EnvironmentCreated implements EnvironmentChangeLog & WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  environment(onlyIfLatest: Boolean): Environment
  environmentId: ID!
  id: ID!
  name: String!
  version: Version!
  workspaceId: ID!
}

type EnvironmentDeleted implements EnvironmentChangeLog & WorkspaceChangeLog {
  changedAt: DateTime!
  changedBy: UserInfo!
  environment(onlyIfLatest: Boolean): Environment
  environmentId: ID!
  id: ID!
  name: String!
  version: Version!
  workspaceId: ID!
}

type EnvironmentVariable {
  id: String!
  isSecret: Boolean!
  name: String!
  value: String!
}

"A connection to a list of items."
type EnvironmentsConnection {
  "A list of edges."
  edges: [EnvironmentsEdge!]
  "A flattened list of the nodes."
  nodes: [Environment!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type EnvironmentsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Environment!
}

type ErrorInsight {
  epm: Float!
  id: ID!
  lastSeen: Float!
  message: String!
  totalCount: Long!
  type: String!
}

"A connection to a list of items."
type ErrorInsightsConnection {
  "A list of edges."
  edges: [ErrorInsightsEdge!]
  "A flattened list of the nodes."
  nodes: [ErrorInsight!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ErrorInsightsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ErrorInsight!
}

type FieldAddedChange implements SchemaChange {
  coordinate: String!
  fieldName: String!
  severity: SchemaChangeSeverity!
  typeName: String!
}

type FieldCoordinateMetrics implements CoordinateMetrics {
  clientUsage(
    clientId: ID
    from: DateTime!
    to: DateTime!
  ): CoordinateClientUsage
  clientUsages(from: DateTime!, to: DateTime!): [CoordinateClientUsage!]!
<<<<<<< HEAD
=======

>>>>>>> origin/main
  duration(
    from: DateTime!
    resolution: Int! = 300
    to: DateTime!
  ): FieldDurationGraph
  requests(
    from: DateTime!
    resolution: Int! = 300
    to: DateTime!
  ): CoordinateRequestGraph
  usages(
    from: DateTime!
    resolution: Int! = 300
    to: DateTime!
  ): CoordinateUsageGraph
}

type FieldDurationGraph {
  dataset: [FieldDurationGraphData!]!
}

type FieldDurationGraphData {
  epoch: Long!
  max: Float!
  mean: Float!
  min: Float!
  p50: Float!
  p95: Float!
  p99: Float!
}

type FieldRemovedChange implements SchemaChange {
  coordinate: String!
  fieldName: String!
  severity: SchemaChangeSeverity!
  typeName: String!
}

type FusionConfiguration {
  downloadUrl: String!
  format: FusionConfigurationFormat!
  id: ID!
  publishedAt: DateTime!
  subgraph: Api
  subgraphName: String
  supportedVersions: [String!]!
  tag: String!
}

type FusionConfigurationChangeLog implements StageChangeLog & Node {
  changedAt: DateTime!
  id: ID!
  kind: StageChangeLogKind!
  tag: String!
}

type FusionConfigurationDeployment implements Node & Deployment {
  approval: DeploymentApproval
  createdAt: DateTime!
  errors: [FusionConfigurationDeploymentError!]!
  id: ID!
  logs: [DeploymentLog!]!
  schemaChanges: FusionConfigurationDeploymentSchemaChanges
  status: DeploymentStatus!
  subgraph: Subgraph
  tag: String!
}

type FusionConfigurationDeploymentSchemaChanges {
  changes(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
    severity: SchemaChangeSeverity
  ): SchemaChangesConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  statistic: SchemaChangeLogStatistic!
}

type FusionConfigurationPublishingFailed implements FusionConfigurationPublishingResult {
  errors: [FusionConfigurationPublishingError!]!
  state: ProcessingState!
}

type FusionConfigurationPublishingSuccess implements FusionConfigurationPublishingResult {
  state: ProcessingState!
}

type FusionConfigurationRequestNotFoundError implements Error {
  message: String!
  requestId: ID!
}

type FusionConfigurationValidationFailed implements FusionConfigurationPublishingResult {
  errors: [FusionConfigurationValidationError!]!
  state: ProcessingState!
}

type FusionConfigurationValidationSuccess implements FusionConfigurationPublishingResult {
  changes: [SchemaChangeLogEntry!]!
  state: ProcessingState!
}

type FusionSubgraph implements Subgraph {
  api: Api
  id: ID!
  name: String!
}

<<<<<<< HEAD
=======
type FusionSubgraphVersion {
  createdAt: DateTime!
  fusionSubgraph: FusionSubgraph!
  id: ID!
  tag: String!
}

>>>>>>> origin/main
type GraphQLDirectiveArgumentDefinition implements Node & GraphQLTypeSystemMember & GraphQLInputValueDefinition {
  coordinate: String!
  id: ID!
  isDeprecated: Boolean!
  metrics: CoordinateMetrics!
  name: String!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

type GraphQLDirectiveDefinition implements Node & GraphQLTypeSystemMember {
  arguments: GraphQLDirectiveDefinitionArgumentsConnection!
  coordinate: String!
  id: ID!
  isDeprecated: Boolean!
  kind: TypeSystemMemberKind!
  metrics: CoordinateMetrics!
  name: String!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

type GraphQLDirectiveDefinitionArgumentsConnection {
  nodes: [GraphQLDirectiveArgumentDefinition!]!
}

type GraphQLEnumTypeDefinition implements Node & GraphQLTypeSystemMember {
  coordinate: String!
  id: ID!
  isDeprecated: Boolean!
  kind: TypeSystemMemberKind!
  metrics: CoordinateMetrics!
  name: String!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
  values: GraphQLEnumTypeDefinitionValuesConnection!
}

type GraphQLEnumTypeDefinitionValuesConnection {
  nodes: [GraphQLEnumValueDefinition!]!
}

type GraphQLEnumValueDefinition implements Node & GraphQLTypeSystemMember {
  coordinate: String!
  id: ID!
  isDeprecated: Boolean!
  metrics: CoordinateMetrics!
  name: String!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

type GraphQLInputObjectFieldDefinition implements Node & GraphQLTypeSystemMember & GraphQLInputValueDefinition {
  coordinate: String!
  id: ID!
  isDeprecated: Boolean!
  metrics: CoordinateMetrics!
  name: String!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

type GraphQLInputObjectTypeDefinition implements Node & GraphQLTypeSystemMember {
  coordinate: String!
  fields: GraphQLInputObjectTypeDefinitionFieldsConnection!
  id: ID!
  isDeprecated: Boolean!
  kind: TypeSystemMemberKind!
  metrics: CoordinateMetrics!
  name: String!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

type GraphQLInputObjectTypeDefinitionFieldsConnection {
  nodes: [GraphQLInputObjectFieldDefinition!]!
}

type GraphQLInterfaceFieldArgumentDefinition implements Node & GraphQLTypeSystemMember & GraphQLInputValueDefinition & GraphQLOutputFieldArgumentDefinition {
  coordinate: String!
  declaringField: String!
  declaringType: String!
  id: ID!
  isDeprecated: Boolean!
  metrics: CoordinateMetrics!
  name: String!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

type GraphQLInterfaceFieldArgumentDefinitionArgumentsConnection implements GraphQLOutputFieldDefinitionArgumentsConnection {
  nodes: [GraphQLInterfaceFieldArgumentDefinition!]!
}

type GraphQLInterfaceFieldDefinition implements Node & GraphQLTypeSystemMember & GraphQLOutputFieldDefinition {
  arguments: GraphQLInterfaceFieldArgumentDefinitionArgumentsConnection!
<<<<<<< HEAD
=======

>>>>>>> origin/main
  coordinate: String!
  id: ID!
  isDeprecated: Boolean!
  metrics: CoordinateMetrics!
  name: String!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

type GraphQLInterfaceTypeDefinition implements Node & GraphQLTypeSystemMember {
  coordinate: String!
  fields: GraphQLInterfaceTypeDefinitionFieldsConnection!
  id: ID!
  isDeprecated: Boolean!
  kind: TypeSystemMemberKind!
  metrics: CoordinateMetrics!
  name: String!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

type GraphQLInterfaceTypeDefinitionFieldsConnection {
  nodes: [GraphQLInterfaceFieldDefinition!]!
}

type GraphQLObjectFieldArgumentDefinition implements Node & GraphQLTypeSystemMember & GraphQLInputValueDefinition & GraphQLOutputFieldArgumentDefinition {
  coordinate: String!
  declaringField: String!
  declaringType: String!
  id: ID!
  isDeprecated: Boolean!
  metrics: CoordinateMetrics!
  name: String!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

type GraphQLObjectFieldArgumentDefinitionArgumentsConnection implements GraphQLOutputFieldDefinitionArgumentsConnection {
  nodes: [GraphQLObjectFieldArgumentDefinition!]!
}

type GraphQLObjectFieldDefinition implements Node & GraphQLTypeSystemMember & GraphQLOutputFieldDefinition {
  arguments: GraphQLObjectFieldArgumentDefinitionArgumentsConnection!
<<<<<<< HEAD
=======

>>>>>>> origin/main
  coordinate: String!
  id: ID!
  isDeprecated: Boolean!
  metrics: FieldCoordinateMetrics!
  name: String!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

type GraphQLObjectTypeDefinition implements GraphQLTypeSystemMember {
  coordinate: String!
  fields: GraphQLObjectTypeDefinitionFieldsConnection!
  isDeprecated: Boolean!
  kind: TypeSystemMemberKind!
  metrics: CoordinateMetrics!
  name: String!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

type GraphQLObjectTypeDefinitionFieldsConnection {
  nodes: [GraphQLObjectFieldDefinition!]!
}

type GraphQLScalarTypeDefinition implements Node & GraphQLTypeSystemMember {
  coordinate: String!
  id: ID!
  isDeprecated: Boolean!
  kind: TypeSystemMemberKind!
  metrics: CoordinateMetrics!
  name: String!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

type GraphQLSchemaError {
  code: String
  message: String!
}

type GraphQLUnionTypeDefinition implements Node & GraphQLTypeSystemMember {
  coordinate: String!
  id: ID!
  isDeprecated: Boolean!
  kind: TypeSystemMemberKind!
  metrics: CoordinateMetrics!
  name: String!
  usage(from: DateTime, to: DateTime): CoordinateUsage!
}

type Group implements Node {
  description: String!
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupGroupsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  id: ID!
  isDefault: Boolean!
  members(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMembersConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  name: String!
  organization: Organization
  roleAssignments(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupRoleAssignmentsConnection
}

type GroupGroupMember implements GroupMember {
  assignedAt: DateTime!
  group: Group
  id: ID!
  nestedGroup: Group
  type: String!
}

"A connection to a list of groups via group members."
type GroupGroupsConnection {
  edges: [GroupGroupsEdge!]
  nodes: [Group!]!
  pageInfo: PageInfo!
}

type GroupGroupsEdge {
  cursor: String!
  node: Group!
}

"A connection to a list of items."
type GroupMembersConnection {
  "A list of edges."
  edges: [GroupMembersEdge!]
  "A flattened list of the nodes."
  nodes: [GroupMember!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type GroupMembersEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GroupMember!
}

"A connection to a list of items."
type GroupRoleAssignmentsConnection {
  "A list of edges."
  edges: [GroupRoleAssignmentsEdge!]
  "A flattened list of the nodes."
  nodes: [RoleAssignment!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type GroupRoleAssignmentsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: RoleAssignment!
}

type HasBeenChangedConflict implements Error {
  current: WorkspaceChangeResult!
  message: String!
}

type HasBeenDeletedConflict implements Error {
  message: String!
  workspaceId: ID!
}

type IdentifierCollisionConflict implements Error {
  collidesWith: WorkspaceChangeResult!
  message: String!
}

type InputFieldChanged implements SchemaChange {
  changes: [InputFieldChange!]!
  coordinate: String!
  fieldName: String!
  severity: SchemaChangeSeverity!
}

type InputObjectModifiedChange implements SchemaChange {
  changes: [InputObjectChange!]!
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type InterfaceImplementationAdded implements SchemaChange {
  interfaceName: String!
  severity: SchemaChangeSeverity!
}

type InterfaceImplementationRemoved implements SchemaChange {
  interfaceName: String!
  severity: SchemaChangeSeverity!
}

type InterfaceModifiedChange implements SchemaChange {
  changes: [InterfaceChange!]!
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type InvalidFusionSourceSchemaArchiveError implements Error {
  message: String!
}

type InvalidGraphQLSchemaError implements SchemaVersionValidationError & SchemaVersionPublishError & FusionConfigurationPublishingError & FusionConfigurationValidationError & ProcessingError {
  errors: [GraphQLSchemaError!]!
  message: String!
}

type InvalidOpenApiCollectionArchiveError implements Error {
  message: String!
}

type InvalidPersistedQueryError implements Error {
  content: String!
  hash: String!
  message: String!
}

type InvalidProcessingStateTransitionError implements Error {
  message: String!
}

type MockSchema {
  baseSchemaDownloadUrl: String!
  createdAt: DateTime!
  createdBy: UserInfo!
  downstreamUrl: URL!
  extensionsSchemaDownloadUrl: String!
  id: ID!
  modifiedAt: DateTime!
  modifiedBy: UserInfo!
  name: String!
  url: String!
}

type MockSchemaNonUniqueNameError implements Error {
  message: String!
  name: String!
}

type MockSchemaNotFoundError implements Error {
  id: ID!
  message: String!
}

"A connection to a list of items."
type MockSchemasConnection {
  "A list of edges."
  edges: [MockSchemasEdge!]
  "A flattened list of the nodes."
  nodes: [MockSchema!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type MockSchemasEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MockSchema!
}

type Mutation {
  approveDeployment(input: ApproveDeploymentInput!): ApproveDeploymentPayload!
<<<<<<< HEAD
=======

>>>>>>> origin/main
  beginFusionConfigurationPublish(
    input: BeginFusionConfigurationPublishInput!
  ): BeginFusionConfigurationPublishPayload!
  cancelDeployment(input: CancelDeploymentInput!): CancelDeploymentPayload!
<<<<<<< HEAD
=======

>>>>>>> origin/main
  cancelFusionConfigurationComposition(
    input: CancelFusionConfigurationCompositionInput!
  ): CancelFusionConfigurationCompositionPayload!
  commitFusionConfigurationPublish(
    input: CommitFusionConfigurationPublishInput!
  ): CommitFusionConfigurationPublishPayload!
  createAccount: CreateAccountPayload!
  createApiKey(input: CreateApiKeyInput!): CreateApiKeyPayload!
<<<<<<< HEAD
=======

>>>>>>> origin/main
  createApiKeyForApi(
    input: CreateApiKeyForApiInput!
  ): CreateApiKeyForApiPayload!
  createClient(input: CreateClientInput!): CreateClientPayload!
<<<<<<< HEAD
  createMockSchema(input: CreateMockSchemaInput!): CreateMockSchemaPayload!
  createOpenApiCollection(
    input: CreateOpenApiCollectionInput!
  ): CreateOpenApiCollectionPayload!
=======

  createMockSchema(input: CreateMockSchemaInput!): CreateMockSchemaPayload!

>>>>>>> origin/main
  createPersonalAccessToken(
    input: CreatePersonalAccessTokenInput!
  ): CreatePersonalAccessTokenPayload!
  createWorkspace(input: CreateWorkspaceInput!): CreateWorkspacePayload!
<<<<<<< HEAD
  deleteApiById(input: DeleteApiByIdInput!): DeleteApiByIdPayload!
  deleteApiKey(input: DeleteApiKeyInput!): DeleteApiKeyPayload!
  deleteClientById(input: DeleteClientByIdInput!): DeleteClientByIdPayload!
  deleteMockSchemaById(
    input: DeleteMockSchemaByIdInput!
  ): DeleteMockSchemaByIdPayload!
  deleteOpenApiCollectionById(
    input: DeleteOpenApiCollectionByIdInput!
  ): DeleteOpenApiCollectionByIdPayload!
  ensureTunnelSession: EnsureTunnelSessionPayload!
=======

  deleteApiById(input: DeleteApiByIdInput!): DeleteApiByIdPayload!

  deleteApiKey(input: DeleteApiKeyInput!): DeleteApiKeyPayload!

  deleteClientById(input: DeleteClientByIdInput!): DeleteClientByIdPayload!

  deleteMockSchemaById(
    input: DeleteMockSchemaByIdInput!
  ): DeleteMockSchemaByIdPayload!
  ensureTunnelSession: EnsureTunnelSessionPayload!

>>>>>>> origin/main
  pollClientVersionPublishRequest(
    input: PollClientVersionPublishRequestInput!
  ): PollClientVersionPublishRequestPayload!
  pollClientVersionValidationRequest(
    input: PollClientVersionValidationRequestInput!
  ): PollClientVersionValidationRequestPayload!
<<<<<<< HEAD
  pollOpenApiCollectionVersionPublishRequest(
    input: PollOpenApiCollectionVersionPublishRequestInput!
  ): PollOpenApiCollectionVersionPublishRequestPayload!
  pollOpenApiCollectionVersionValidationRequest(
    input: PollOpenApiCollectionVersionValidationRequestInput!
  ): PollOpenApiCollectionVersionValidationRequestPayload!
=======
>>>>>>> origin/main
  pollSchemaVersionPublishRequest(
    input: PollSchemaVersionPublishRequestInput!
  ): PollSchemaVersionPublishRequestPayload!
  pollSchemaVersionValidationRequest(
    input: PollSchemaVersionValidationRequestInput!
  ): PollSchemaVersionValidationRequestPayload!
  publishClient(input: PublishClientInput!): PublishClientPayload!
<<<<<<< HEAD
  publishOpenApiCollection(
    input: PublishOpenApiCollectionInput!
  ): PublishOpenApiCollectionPayload!
  publishSchema(input: PublishSchemaInput!): PublishSchemaPayload!
=======

  publishSchema(input: PublishSchemaInput!): PublishSchemaPayload!

>>>>>>> origin/main
  pushDocumentChanges(
    input: PushDocumentChangeInput!
  ): PushDocumentChangesPayload! @deprecated(reason: "Use pushWorkspaceChanges")
  pushWorkspaceChanges(
    input: PushWorkspaceChangesInput!
  ): PushWorkspaceChangesPayload!
<<<<<<< HEAD
  removeWorkspace(input: RemoveWorkspaceInput!): RemoveWorkspacePayload!
  renameWorkspace(input: RenameWorkspaceInput!): RenameWorkspacePayload!
=======

  removeWorkspace(input: RemoveWorkspaceInput!): RemoveWorkspacePayload!

  renameWorkspace(input: RenameWorkspaceInput!): RenameWorkspacePayload!

>>>>>>> origin/main
  revokePersonalAccessToken(
    input: RevokePersonalAccessTokenInput!
  ): RevokePersonalAccessTokenPayload!
  setActiveWorkspace(
    input: SetActiveWorkspaceInput!
  ): SetActiveWorkspacePayload!
<<<<<<< HEAD
=======

>>>>>>> origin/main
  startFusionConfigurationComposition(
    input: StartFusionConfigurationCompositionInput!
  ): StartFusionConfigurationCompositionPayload!
  unpublishClient(input: UnpublishClientInput!): UnpublishClientPayload!
<<<<<<< HEAD
  updateApiSettings(input: UpdateApiSettingsInput!): UpdateApiSettingsPayload!
=======

  updateApiSettings(input: UpdateApiSettingsInput!): UpdateApiSettingsPayload!

>>>>>>> origin/main
  updateFeatureFlags(
    input: UpdateFeatureFlagsInput!
  ): UpdateFeatureFlagsPayload!
  updateMockSchema(input: UpdateMockSchemaInput!): UpdateMockSchemaPayload!
<<<<<<< HEAD
  updatePreferences(input: UpdatePreferencesInput!): UpdatePreferencesPayload!
  updateStages(input: UpdateStagesInput!): UpdateStagesPayload!
=======

  updatePreferences(input: UpdatePreferencesInput!): UpdatePreferencesPayload!

  updateStages(input: UpdateStagesInput!): UpdateStagesPayload!

>>>>>>> origin/main
  updateThemeSettings(
    input: UpdateThemeSettingsInput!
  ): UpdateThemeSettingsPayload!
  uploadClient(input: UploadClientInput!): UploadClientPayload!
<<<<<<< HEAD
  uploadOpenApiCollection(
    input: UploadOpenApiCollectionInput!
  ): UploadOpenApiCollectionPayload!
  uploadSchema(input: UploadSchemaInput!): UploadSchemaPayload!
  validateClient(input: ValidateClientInput!): ValidateClientPayload!
  validateFusionConfigurationComposition(
    input: ValidateFusionConfigurationCompositionInput!
  ): ValidateFusionConfigurationCompositionPayload!
  validateOpenApiCollection(
    input: ValidateOpenApiCollectionInput!
  ): ValidateOpenApiCollectionPayload!
=======

  uploadFusionSubgraph(
    input: UploadFusionSubgraphInput!
  ): UploadFusionSubgraphPayload!
  uploadSchema(input: UploadSchemaInput!): UploadSchemaPayload!

  validateClient(input: ValidateClientInput!): ValidateClientPayload!

  validateFusionConfigurationComposition(
    input: ValidateFusionConfigurationCompositionInput!
  ): ValidateFusionConfigurationCompositionPayload!
>>>>>>> origin/main
  validateSchema(input: ValidateSchemaInput!): ValidateSchemaPayload!
}

type OAuth2AuthenticationFlowOptions {
  accessTokenUrl: String!
  activeFlowKind: String!
  audience: String!
  authorizationUrl: String!
  clientId: String!
  clientSecret: String!
  credentialsInBody: Boolean!
  grantType: String!
  origin: String!
  password: String!
  pkceMethod: String!
  prefix: String!
  redirectUrl: String!
  resource: String!
  responseType: String!
  scope: String!
  state: String!
  usePkce: Boolean!
  username: String!
}

type ObjectModifiedChange implements SchemaChange {
  changes: [ObjectChange!]!
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type OpenApiCollection implements Node {
  api: Api
  createdAt: DateTime!
  createdBy: UserInfo!
  id: ID!
  name: String!
  versions(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): OpenApiCollectionVersionsConnection
}

type OpenApiCollectionChangeLog implements StageChangeLog & Node {
  changedAt: DateTime!
  id: ID!
  kind: StageChangeLogKind!
  tag: String!
}

type OpenApiCollectionDeployment implements Node & Deployment {
  approval: DeploymentApproval
  createdAt: DateTime!
  errors: [OpenApiCollectionDeploymentError!]!
  id: ID!
  logs: [DeploymentLog!]!
  openApiCollection: OpenApiCollection
  status: DeploymentStatus!
  tag: String!
}

type OpenApiCollectionNotFoundError implements Error {
  message: String!
  openApiCollectionId: ID!
}

type OpenApiCollectionValidationArchiveError implements OpenApiCollectionVersionValidationError & ProcessingError {
  message: String!
}

type OpenApiCollectionValidationCollection {
  entities: [OpenApiCollectionValidationEntity!]!
  openApiCollection: OpenApiCollection
}

type OpenApiCollectionValidationDocumentError implements OpenApiCollectionValidationEntityError {
  code: String
  locations: [OpenApiCollectionValidationDocumentErrorLocation!]
  message: String!
  path: String
}

type OpenApiCollectionValidationDocumentErrorLocation {
  column: Int!
  line: Int!
}

type OpenApiCollectionValidationEndpoint implements OpenApiCollectionValidationEntity {
  errors: [OpenApiCollectionValidationEntityError!]!
  httpMethod: String!
  route: String!
}

type OpenApiCollectionValidationEntityValidationError implements OpenApiCollectionValidationEntityError {
  message: String!
}

type OpenApiCollectionValidationError implements OpenApiCollectionVersionPublishError & OpenApiCollectionVersionValidationError & SchemaVersionPublishError & SchemaVersionValidationError & FusionConfigurationValidationError & ProcessingError {
  collections: [OpenApiCollectionValidationCollection!]!
  message: String!
}

type OpenApiCollectionValidationModel implements OpenApiCollectionValidationEntity {
  errors: [OpenApiCollectionValidationEntityError!]!
  name: String!
}

type OpenApiCollectionVersion implements Node {
  createdAt: DateTime!
  id: ID!
  openApiCollection: OpenApiCollection
  tag: String!
}

type OpenApiCollectionVersionNotFoundError implements Error {
  message: String!
  openApiCollectionId: ID!
  tag: String!
}

type OpenApiCollectionVersionPublishFailed implements OpenApiCollectionVersionPublishResult {
  errors: [OpenApiCollectionVersionPublishError!]!
  state: ProcessingState!
}

type OpenApiCollectionVersionPublishSuccess implements OpenApiCollectionVersionPublishResult {
  openApiCollectionVersion: OpenApiCollectionVersion
  state: ProcessingState!
}

type OpenApiCollectionVersionRequestNotFoundError implements Error {
  message: String!
  requestId: ID!
}

type OpenApiCollectionVersionValidationFailed implements OpenApiCollectionVersionValidationResult {
  errors: [OpenApiCollectionVersionValidationError!]!
  state: ProcessingState!
}

type OpenApiCollectionVersionValidationSuccess implements OpenApiCollectionVersionValidationResult {
  state: ProcessingState!
}

"A connection to a list of items."
type OpenApiCollectionVersionsConnection {
  "A list of edges."
  edges: [OpenApiCollectionVersionsEdge!]
  "A flattened list of the nodes."
  nodes: [OpenApiCollectionVersion!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type OpenApiCollectionVersionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: OpenApiCollectionVersion!
}

type OpenTelemetryBoolAttribute implements OpenTelemetryAttribute {
  key: String!
  value: Boolean!
}

type OpenTelemetryDbSpan implements OpenTelemetrySpan {
  api: Api
  clockSkew: Float
  db: OpenTelemetryDbSpanAttributes
  duration: Float!
  epoch: Float!
  events: [OpenTelemetryTraceEvent!]!
  links: [OpenTelemetryTraceLink!]!
  parentSpanId: String!
  resourceAttributes: [Attribute!]!
  spanAttributes: [Attribute!]!
  spanId: String!
  spanKind: String!
  spanName: String!
  stage: Stage
  statusCode: String!
  statusMessage: String!
  traceId: String!
  traceState: String!
}

type OpenTelemetryDbSpanAttributes {
  connectionString: String
  instance: String
  name: String
  operation: String
  statement: String
  system: String
  url: String
  user: String
}

type OpenTelemetryDefaultSpan implements OpenTelemetrySpan {
  api: Api
  clockSkew: Float
  duration: Float!
  epoch: Float!
  events: [OpenTelemetryTraceEvent!]!
  links: [OpenTelemetryTraceLink!]!
  parentSpanId: String!
  resourceAttributes: [Attribute!]!
  spanAttributes: [Attribute!]!
  spanId: String!
  spanKind: String!
  spanName: String!
  stage: Stage
  statusCode: String!
  statusMessage: String!
  traceId: String!
  traceState: String!
}

type OpenTelemetryError {
  api: Api
  epoch: Float!
  escaped: Boolean!
  message: String!
  parentSpanId: String!
  spanId: String!
  stackTrace: String!
  stage: Stage
  traceId: String!
  type: String!
}

type OpenTelemetryFloatAttribute implements OpenTelemetryAttribute {
  key: String!
  value: Float!
}

type OpenTelemetryGraphQLOperationSpan implements OpenTelemetrySpan {
  api: Api
  clockSkew: Float
  document: OpenTelemetryGraphQLOperationSpanDocumentAttributes
<<<<<<< HEAD
=======

>>>>>>> origin/main
  duration: Float!
  epoch: Float!
  events: [OpenTelemetryTraceEvent!]!
  links: [OpenTelemetryTraceLink!]!
  operation: OpenTelemetryGraphQLOperationSpanOperationAttributes
<<<<<<< HEAD
=======

>>>>>>> origin/main
  parentSpanId: String!
  resourceAttributes: [Attribute!]!
  spanAttributes: [Attribute!]!
  spanId: String!
  spanKind: String!
  spanName: String!
  stage: Stage
  statusCode: String!
  statusMessage: String!
  traceId: String!
  traceState: String!
}

type OpenTelemetryGraphQLOperationSpanDocumentAttributes {
  body: String
  id: String
}

type OpenTelemetryGraphQLOperationSpanOperationAttributes {
  kind: String
  name: String
}

type OpenTelemetryGraphQLResolverSpan implements OpenTelemetrySpan {
  api: Api
  clockSkew: Float
  duration: Float!
  epoch: Float!
  events: [OpenTelemetryTraceEvent!]!
  links: [OpenTelemetryTraceLink!]!
  parentSpanId: String!
  resourceAttributes: [Attribute!]!
  selection: OpenTelemetryGraphQLResolverSpanSelectionAttributes
<<<<<<< HEAD
=======

>>>>>>> origin/main
  spanAttributes: [Attribute!]!
  spanId: String!
  spanKind: String!
  spanName: String!
  stage: Stage
  statusCode: String!
  statusMessage: String!
  traceId: String!
  traceState: String!
}

type OpenTelemetryGraphQLResolverSpanFieldAttributes {
  coordinate: String
  declaringType: String
  name: String
}

type OpenTelemetryGraphQLResolverSpanSelectionAttributes {
  field: OpenTelemetryGraphQLResolverSpanFieldAttributes!
  name: String
  path: String
  type: String
}

type OpenTelemetryHttpClientSpan implements OpenTelemetrySpan {
  api: Api
  clockSkew: Float
  duration: Float!
  epoch: Float!
  events: [OpenTelemetryTraceEvent!]!
  http: OpenTelemetryHttpClientSpanAttribute
  links: [OpenTelemetryTraceLink!]!
  parentSpanId: String!
  resourceAttributes: [Attribute!]!
  spanAttributes: [Attribute!]!
  spanId: String!
  spanKind: String!
  spanName: String!
  stage: Stage
  statusCode: String!
  statusMessage: String!
  traceId: String!
  traceState: String!
}

type OpenTelemetryHttpClientSpanAttribute {
  flavor: String
  method: String
  scheme: String
  statusCode: Int
  url: String
  userAgent: String
}

type OpenTelemetryHttpServerSpan implements OpenTelemetrySpan {
  api: Api
  clockSkew: Float
  duration: Float!
  epoch: Float!
  events: [OpenTelemetryTraceEvent!]!
  http: OpenTelemetryHttpServerSpanAttributes
  links: [OpenTelemetryTraceLink!]!
  parentSpanId: String!
  resourceAttributes: [Attribute!]!
  spanAttributes: [Attribute!]!
  spanId: String!
  spanKind: String!
  spanName: String!
  stage: Stage
  statusCode: String!
  statusMessage: String!
  traceId: String!
  traceState: String!
}

type OpenTelemetryHttpServerSpanAttributes {
  flavor: String
  method: String
  scheme: String
  statusCode: Int
  url: String
  userAgent: String
}

type OpenTelemetryLog {
  api: Api
  body: String!
  epoch: Float!
  logAttributes: [OpenTelemetryAttribute!]!
  resourceAttributes: [Attribute!]!
  severityNumber: Int!
  severityText: String!
  spanId: String!
  stage: Stage
  traceId: String!
}

"A connection to a list of items."
type OpenTelemetryLogsConnection {
  "A list of edges."
  edges: [OpenTelemetryLogsEdge!]
  "A flattened list of the nodes."
  nodes: [OpenTelemetryLog!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type OpenTelemetryLogsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: OpenTelemetryLog!
}

type OpenTelemetryLogsSeverityGraph {
  dataset: [OpenTelemetryLogsSeverityGraphData!]!
}

type OpenTelemetryLogsSeverityGraphCountData {
  count: Long!
  severity: Long!
}

type OpenTelemetryLogsSeverityGraphData {
  counts: [OpenTelemetryLogsSeverityGraphCountData!]!
  epoch: Long!
}

type OpenTelemetryLongAttribute implements OpenTelemetryAttribute {
  key: String!
  value: Long!
}

type OpenTelemetryStringAttribute implements OpenTelemetryAttribute {
  key: String!
  value: String!
}

type OpenTelemetryTrace {
  epoch: Float!
  errors: [OpenTelemetryError!]!
  logs(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): OpenTelemetryLogsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  spans: [OpenTelemetrySpan!]!
  totalDuration: Float!
}

type OpenTelemetryTraceEvent {
  attributes: [Attribute!]!
  epoch: Float!
  name: String!
}

type OpenTelemetryTraceLink {
  attributes: [Attribute!]!
  spanId: String!
  traceId: String!
  traceState: String!
}

type OpenTelemetryTransactionInsight {
  averageLatency: Float!
  errorRate: Float!
  id: ID!
  impact: Float!
  latency: OpenTelemetryTransactionLatencyGraph
  name: String!
  opm: Float!
  spanKind: OpenTelemetrySpanKind!
  successRate: Float!
  throughput: OpenTelemetryTransactionThroughputGraph
  totalCount: Long!
  totalCountWithErrors: Long!
}

"A connection to a list of items."
type OpenTelemetryTransactionInsightsConnection {
  "A list of edges."
  edges: [OpenTelemetryTransactionInsightsEdge!]
  "A flattened list of the nodes."
  nodes: [OpenTelemetryTransactionInsight!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type OpenTelemetryTransactionInsightsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: OpenTelemetryTransactionInsight!
}

type OpenTelemetryTransactionLatencyDistributionGraph {
  dataset: [OpenTelemetryTransactionLatencyDistributionGraphData!]!
  p95: Float!
  totalCount: Int!
}

type OpenTelemetryTransactionLatencyDistributionGraphData {
  bin: Float!
  errorFrequency: Int!
  frequency: Int!
  successFrequency: Int!
}

type OpenTelemetryTransactionLatencyGraph {
  dataset: [OpenTelemetryTransactionLatencyGraphData!]!
}

type OpenTelemetryTransactionLatencyGraphData {
  epoch: Long!
  max: Float!
  mean: Float!
  min: Float!
  p50: Float!
  p95: Float!
  p99: Float!
}

type OpenTelemetryTransactionThroughputGraph {
  dataset: [OpenTelemetryTransactionThroughputGraphData!]!
}

type OpenTelemetryTransactionThroughputGraphData {
  epoch: Long!
  errorRate: Float!
  opm: Float!
  successRate: Float!
  totalCount: Long!
  totalCountWithError: Long!
}

type OpenTelemetryTransactionTraceSample {
  seeker: String!
  spanId: String!
  traceId: String!
}

type OpenTelemetryTransactionsLatencyGraph {
  dataset: [OpenTelemetryTransactionsLatencyGraphData!]!
}

type OpenTelemetryTransactionsLatencyGraphData {
  epoch: Long!
  max: Float!
  mean: Float!
  min: Float!
  p50: Float!
  p95: Float!
  p99: Float!
}

type OpenTelemetryTransactionsThroughputGraph {
  dataset: [OpenTelemetryTransactionsThroughputGraphData!]!
}

type OpenTelemetryTransactionsThroughputGraphData {
  epoch: Long!
  errorRate: Float!
  opm: Float!
  successRate: Float!
  totalCount: Long!
  totalCountWithError: Long!
}

type Operation {
  document: RequestDocument
  kind: OperationKind!
  name: String
}

type OperationInProgress implements SchemaVersionValidationResult & SchemaVersionPublishResult & ClientVersionValidationResult & ClientVersionPublishResult & FusionConfigurationPublishingResult & OpenApiCollectionVersionPublishResult & OpenApiCollectionVersionValidationResult {
  state: ProcessingState!
}

type OperationInsight {
  averageLatency: Float!
  documentId: String!
  errorRate: Float!
  hash: String!
  id: ID!
  impact: Float!
  kind: OperationKind
  latency: OperationLatencyGraph
  operationName: String!
  opm: Float!
  successRate: Float!
  throughput: OperationThroughputGraph
  totalCount: Long!
  totalCountWithErrors: Long!
}

"A connection to a list of items."
type OperationInsightsConnection {
  "A list of edges."
  edges: [OperationInsightsEdge!]
  "A flattened list of the nodes."
  nodes: [OperationInsight!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type OperationInsightsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: OperationInsight!
}

type OperationLatencyDistributionGraph {
  data: [OperationLatencyDistributionGraphData!]!
    @deprecated(reason: "Use `Dataset` instead")
  dataset: [OperationLatencyDistributionGraphData!]!
  p95: Float!
  p95DurationInMS: Float! @deprecated(reason: "Use `P95` instead")
  totalCount: Int!
}

type OperationLatencyDistributionGraphData {
  bin: Float!
  bucketInMs: Float! @deprecated(reason: "Use `Bin` instead")
  count: Int! @deprecated(reason: "Use `Frequency` instead")
  errorFrequency: Int!
  frequency: Int!
  successFrequency: Int!
}

type OperationLatencyGraph {
  dataset: [OperationLatencyGraphData!]!
}

type OperationLatencyGraphData {
  epoch: Long!
  max: Float!
  mean: Float!
  min: Float!
  p50: Float!
  p95: Float!
  p99: Float!
}

type OperationThroughputGraph {
  dataset: [OperationThroughputGraphData!]!
}

type OperationThroughputGraphData {
  epoch: Long!
  errorRate: Float!
  opm: Float!
  successRate: Float!
  totalCount: Long!
  totalCountWithError: Long!
}

type OperationTraceSample {
  seeker: String!
  spanId: String!
  traceId: String!
}

type OperationsAreNotAllowedError implements SchemaVersionValidationError & SchemaVersionPublishError & ProcessingError {
  column: Int! @deprecated(reason: "Locations are no longer used")
  end: Int! @deprecated(reason: "Locations are no longer used")
  line: Int! @deprecated(reason: "Locations are no longer used")
  message: String!
  operationName: String
  start: Int! @deprecated(reason: "Locations are no longer used")
}

"A connection to a list of items."
type OperationsConnection {
  "A list of edges."
  edges: [OperationsEdge!]
  "A flattened list of the nodes."
  nodes: [Operation!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type OperationsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Operation!
}

type OperationsLatencyGraph {
  dataset: [OperationsLatencyGraphData!]!
}

type OperationsLatencyGraphData {
  epoch: Long!
  max: Float!
  mean: Float!
  min: Float!
  p50: Float!
  p95: Float!
  p99: Float!
}

type OperationsThroughputGraph {
  dataset: [OperationsThroughputGraphData!]!
}

type OperationsThroughputGraphData {
  epoch: Long!
  errorRate: Float!
  opm: Float!
  successRate: Float!
  totalCount: Long!
  totalCountWithError: Long!
}

type Organization implements Node {
  authorizationEventLogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    from: DateTime
    "Returns the last _n_ elements from the list."
    last: Int
    to: DateTime
  ): OrganizationAuthorizationEventLogsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  billingInfo: OrganizationBillingInfo
  displayName: String!
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationGroupsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  id: ID!
  members(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationMembersConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  name: String!
  plan: OrganizationPlan
  usage(from: DateTime, to: DateTime): OrganizationUsage
}

"A connection to a list of items."
type OrganizationAuthorizationEventLogsConnection {
  "A list of edges."
  edges: [OrganizationAuthorizationEventLogsEdge!]
  "A flattened list of the nodes."
  nodes: [AuthorizationEventLog!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type OrganizationAuthorizationEventLogsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AuthorizationEventLog!
}

type OrganizationBillingInfo {
  nextPaymentDate: DateTime!
  paymentIssue: OrganizationPaymentIssue
  paymentMethod: OrganizationPaymentMethod!
}

"A connection to a list of items."
type OrganizationGroupsConnection {
  "A list of edges."
  edges: [OrganizationGroupsEdge!]
  "A flattened list of the nodes."
  nodes: [Group!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type OrganizationGroupsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Group!
}

type OrganizationInfo {
  displayName: String!
  id: ID!
  name: String!
}

type OrganizationMember implements Node {
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationMemberGroupsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  id: ID!
  isDisabled: Boolean!
  userName: String
}

type OrganizationMemberGroupMember implements GroupMember {
  assignedAt: DateTime!
  group: Group
  id: ID!
  member: OrganizationMember
  type: String!
}

"A connection to a list of groups via group members."
type OrganizationMemberGroupsConnection {
  edges: [OrganizationMemberGroupsEdge!]
  nodes: [Group!]!
  pageInfo: PageInfo!
}

type OrganizationMemberGroupsEdge {
  cursor: String!
  node: Group!
}

"A connection to a list of items."
type OrganizationMembersConnection {
  "A list of edges."
  edges: [OrganizationMembersEdge!]
  "A flattened list of the nodes."
  nodes: [OrganizationMember!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type OrganizationMembersEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: OrganizationMember!
}

type OrganizationPaymentIssue {
  message: String!
}

type OrganizationPermissionScope implements PermissionScope {
  id: ID!
  organization: Organization
  type: String!
}

type OrganizationPlan {
  type: OrganizationPlanType!
}

type OrganizationUsage {
  cumulativeGigabyteHours: OrganizationUsageCumulativeGigabyteHoursGraph
<<<<<<< HEAD
=======

>>>>>>> origin/main
  gigabyteHours: OrganizationUsageGigabyteHoursGraph
  period: OrganizationUsagePeriod!
}

type OrganizationUsageCumulativeGigabyteHoursGraph {
  dataset: [OrganizationUsageCumulativeGigabyteHoursGraphData!]!
}

type OrganizationUsageCumulativeGigabyteHoursGraphCountData {
  label: String!
  predictedValue: Float
  value: Float
}

type OrganizationUsageCumulativeGigabyteHoursGraphData {
  epoch: Long!
  values: [OrganizationUsageCumulativeGigabyteHoursGraphCountData!]!
}

type OrganizationUsageGigabyteHoursGraph {
  dataset: [OrganizationUsageGigabyteHoursGraphData!]!
}

type OrganizationUsageGigabyteHoursGraphCountData {
  label: String!
  value: Float!
}

type OrganizationUsageGigabyteHoursGraphData {
  epoch: Long!
  values: [OrganizationUsageGigabyteHoursGraphCountData!]!
}

type OrganizationUsagePeriod {
  endDate: DateTime!
  startDate: DateTime!
}

type OutputFieldChanged implements SchemaChange {
  changes: [OutputFieldChange!]!
  coordinate: String!
  fieldName: String!
  severity: SchemaChangeSeverity!
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

type PersistedQueriesChanged {
  version: String!
}

"A connection to a list of items."
type PersistedQueriesConnection {
  "A list of edges."
  edges: [PersistedQueriesEdge!]
  "A flattened list of the nodes."
  nodes: [RequestDocument!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PersistedQueriesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: RequestDocument!
}

type PersistedQueryError {
  code: String
  locations: [PersistedQueryErrorLocation!]
  message: String!
  path: String
}

type PersistedQueryErrorLocation {
  column: Int!
  line: Int!
}

type PersistedQueryValidationError implements ClientVersionPublishError & ClientVersionValidationError & SchemaVersionPublishError & SchemaVersionValidationError & FusionConfigurationValidationError & ProcessingError {
  client: Client
  clientId: ID! @deprecated(reason: "Use `client` instead.")
  hasMoreErrors: Boolean!
  message: String!
  queries: [PersistedQueryValidationFailed!]!
}

type PersistedQueryValidationFailed {
  deployedTags: [String!]!
  errors: [PersistedQueryError!]!
  hash: String!
  message: String!
}

type PersonalAccessToken {
  createdAt: DateTime!
  description: String!
  expiresAt: DateTime!
  id: ID!
}

type PersonalAccessTokenNotFoundError implements Error {
  message: String!
}

type PersonalAccessTokenWithSecret {
  secret: String!
  token: PersonalAccessToken!
}

"A connection to a list of items."
type PersonalAccessTokensConnection {
  "A list of edges."
  edges: [PersonalAccessTokensEdge!]
  "A flattened list of the nodes."
  nodes: [PersonalAccessToken!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PersonalAccessTokensEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PersonalAccessToken!
}

type PersonalWorkspaceNotSupportedError implements Error {
  message: String!
}

type PollClientVersionPublishRequestPayload {
  errors: [PollClientVersionPublishRequestError!]
  result: ClientVersionPublishResult
}

type PollClientVersionValidationRequestPayload {
  errors: [PollClientVersionValidationRequestError!]
  result: ClientVersionValidationResult
}

type PollOpenApiCollectionVersionPublishRequestPayload {
  errors: [PollOpenApiCollectionVersionPublishRequestError!]
  result: OpenApiCollectionVersionPublishResult
}

type PollOpenApiCollectionVersionValidationRequestPayload {
  errors: [PollOpenApiCollectionVersionValidationRequestError!]
  result: OpenApiCollectionVersionValidationResult
}

type PollSchemaVersionPublishRequestPayload {
  errors: [PollSchemaVersionPublishRequestError!]
  result: SchemaVersionPublishResult
}

type PollSchemaVersionValidationRequestPayload {
  errors: [PollSchemaVersionValidationRequestError!]
  result: SchemaVersionValidationResult
}

type PossibleTypeAdded implements SchemaChange {
  severity: SchemaChangeSeverity!
  typeName: String!
}

type PossibleTypeRemoved implements SchemaChange {
  severity: SchemaChangeSeverity!
  typeName: String!
}

type ProcessingTaskApproved implements SchemaVersionPublishResult & ClientVersionPublishResult & FusionConfigurationPublishingResult & OpenApiCollectionVersionPublishResult {
  state: ProcessingState!
}

<<<<<<< HEAD
type ProcessingTaskIsQueued implements FusionConfigurationPublishingResult & ClientVersionPublishResult & SchemaVersionPublishResult & OpenApiCollectionVersionPublishResult {
=======
type ProcessingTaskIsQueued implements FusionConfigurationPublishingResult & ClientVersionPublishResult & SchemaVersionPublishResult {
>>>>>>> origin/main
  queuePosition: Int!
  state: ProcessingState!
}

type ProcessingTaskIsReady implements FusionConfigurationPublishingResult & ClientVersionPublishResult & SchemaVersionPublishResult & OpenApiCollectionVersionPublishResult {
  state: ProcessingState!
}

type ProcessingTimeoutError implements SchemaVersionValidationError & SchemaVersionPublishError & ClientVersionValidationError & ClientVersionPublishError & FusionConfigurationPublishingError & OpenApiCollectionVersionPublishError & OpenApiCollectionVersionValidationError & ProcessingError {
  message: String!
}

type PublishClientPayload {
  errors: [PublishClientError!]
  id: ID
}

type PublishOpenApiCollectionPayload {
  errors: [PublishOpenApiCollectionError!]
  id: ID
}

type PublishSchemaPayload {
  errors: [PublishSchemaError!]
  id: ID
}

type PublishedClient {
  client: Client!
  publishedVersions: [PublishedClientVersion!]!
}

type PublishedClientVersion {
  publishedAt: DateTime!
  stage: Stage
  tags: [String!]! @deprecated(reason: "Use `version.tag` instead.")
  version: ClientVersion
}

type PublishedSchemaVersion {
  publishedAt: DateTime!
  stage: Stage
  tag: String! @deprecated(reason: "Use `version.tag` instead.")
  version: SchemaVersion
}

type PushDocumentChangesPayload {
  changes: [WorkspaceDocumentChangeResult!]
  errors: [PushDocumentChangesError!]
}

type PushWorkspaceChangesPayload {
  changes: [WorkspaceChangePayload!]
  errors: [PushWorkspaceChangesError!]
}

type Query {
  apiById(id: ID!): Api
  fusionConfigurationByApiId(id: ID!, stage: String!): FusionConfiguration
<<<<<<< HEAD
  me: Viewer
  "Fetches an object given its ID."
  node("ID of the object." id: ID!): Node @lookup @shareable
=======

  me: Viewer
  "Fetches an object given its ID."
  node("ID of the object." id: ID!): Node
>>>>>>> origin/main
  "Lookup nodes by a list of IDs."
  nodes("The list of node IDs." ids: [ID!]!): [Node]!
  organizationById(id: ID!): Organization
  stageById(id: ID!): Stage
  workspaceById(workspaceId: ID!): Workspace
}

type ReadyTimeoutError implements ClientVersionPublishError & ClientVersionValidationError & SchemaVersionPublishError & SchemaVersionValidationError & FusionConfigurationPublishingError & OpenApiCollectionVersionPublishError & OpenApiCollectionVersionValidationError & ProcessingError {
  message: String!
}

type RemoveWorkspacePayload {
  errors: [RemoveWorkspaceError!]
  workspace: Workspace
}

type RenameWorkspacePayload {
  errors: [RenameWorkspaceError!]
  workspace: Workspace
}

type RequestDocument {
  content: String!
  documentIds: [String!]!
  id: ID!
}

type ResolverInsight {
  averageLatency: Float!
  coordinate: String!
  errorRate: Float!
  id: ID!
  impact: Float!
  latency: ResolverLatencyGraph
  opm: Float!
  successRate: Float!
  throughput: ResolverThroughputGraph
  totalCount: Long!
  totalCountWithErrors: Long!
}

"A connection to a list of items."
type ResolverInsightsConnection {
  "A list of edges."
  edges: [ResolverInsightsEdge!]
  "A flattened list of the nodes."
  nodes: [ResolverInsight!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ResolverInsightsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ResolverInsight!
}

type ResolverLatencyGraph {
  dataset: [ResolverLatencyGraphData!]!
}

type ResolverLatencyGraphData {
  epoch: Long!
  max: Float!
  mean: Float!
  min: Float!
  p50: Float!
  p95: Float!
  p99: Float!
}

type ResolverThroughputGraph {
  dataset: [ResolverThroughputGraphData!]!
}

type ResolverThroughputGraphData {
  epoch: Long!
  errorRate: Float!
  opm: Float!
  successRate: Float!
  totalCount: Long!
  totalCountWithError: Long!
}

type RevokePersonalAccessTokenPayload {
  errors: [RevokePersonalAccessTokenError!]
  personalAccessToken: PersonalAccessToken
}

type Role {
  description: String!
  id: ID!
  name: String!
}

type RoleAssignment {
  condition: RoleAssignmentCondition
  effect: RoleEffect!
  id: ID!
  role: Role
  scope: PermissionScope
}

type RoleAssignmentStageAuthorizationCondition {
  name: String!
}

type RoleNotFoundError implements Error {
  message: String!
  roleId: ID!
}

type ScalarModifiedChange implements SchemaChange {
  changes: [ScalarChange!]!
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type SchemaChangeLog implements StageChangeLog & Node {
  changedAt: DateTime!
  changes(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
    severity: SchemaChangeSeverity
  ): SchemaChangesConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  id: ID!
  kind: StageChangeLogKind!
  previousSchema: SchemaVersion
  schema: SchemaVersion
  statistic: SchemaChangeLogStatistic!
  tag: String!
}

type SchemaChangeLogStatistic {
  breaking: Int!
  dangerous: Int!
  safe: Int!
}

type SchemaChangeViolationError {
  changes: [SchemaChangeLogEntry!]!
  message: String!
}

"A connection to a list of items."
type SchemaChangesConnection {
  "A list of edges."
  edges: [SchemaChangesEdge!]
  "A flattened list of the nodes."
  nodes: [SchemaChangeLogEntry!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type SchemaChangesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SchemaChangeLogEntry!
}

type SchemaCoordinateMetrics implements CoordinateMetrics {
  clientUsage(
    clientId: ID
    from: DateTime!
    to: DateTime!
  ): CoordinateClientUsage
  clientUsages(from: DateTime!, to: DateTime!): [CoordinateClientUsage!]!
<<<<<<< HEAD
=======

>>>>>>> origin/main
  requests(
    from: DateTime!
    resolution: Int! = 300
    to: DateTime!
  ): CoordinateRequestGraph
  usages(
    from: DateTime!
    resolution: Int! = 300
    to: DateTime!
  ): CoordinateUsageGraph
}

type SchemaDeployment implements Node & Deployment {
  approval: DeploymentApproval
  createdAt: DateTime!
  errors: [SchemaDeploymentError!]!
  id: ID!
  logs: [DeploymentLog!]!
  schemaChanges: SchemaDeploymentSchemaChanges
  status: DeploymentStatus!
  tag: String!
}

type SchemaDeploymentSchemaChanges {
  changes(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
    severity: SchemaChangeSeverity
  ): SchemaChangesConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  previousSchema: SchemaVersion
  schema: SchemaVersion
  statistic: SchemaChangeLogStatistic!
}

type SchemaNotFoundError implements Error {
  apiId: ID!
  message: String!
  tag: String!
}

type SchemaRegistrySettings {
  allowBreakingSchemaChanges: Boolean!
  treatDangerousAsBreaking: Boolean!
}

type SchemaVersion {
  createdAt: DateTime!
  downloadUrl: String!
  id: ID!
  publishedTo: [PublishedSchemaVersion!]!
  tag: String!
  tags: [String!]! @deprecated(reason: "Use `tag` instead.")
}

type SchemaVersionChangeViolationError implements SchemaVersionValidationError & SchemaVersionPublishError & FusionConfigurationValidationError & ProcessingError {
  changes: [SchemaChangeLogEntry!]!
  message: String!
}

type SchemaVersionPublishFailed implements SchemaVersionPublishResult {
  errors: [SchemaVersionPublishError!]!
  state: ProcessingState!
}

type SchemaVersionPublishSuccess implements SchemaVersionPublishResult {
  changeLog: SchemaChangeLog
  state: ProcessingState!
}

type SchemaVersionRequestNotFoundError implements Error {
  message: String!
  requestId: ID!
}

type SchemaVersionSyntaxError implements SchemaVersionValidationError & SchemaVersionPublishError & ProcessingError {
  column: Int!
  line: Int!
  message: String!
  position: Int!
}

type SchemaVersionValidationFailed implements SchemaVersionValidationResult {
  errors: [SchemaVersionValidationError!]!
  state: ProcessingState!
}

type SchemaVersionValidationSuccess implements SchemaVersionValidationResult {
  changes: [SchemaChangeLogEntry!]!
  state: ProcessingState!
}

"A connection to a list of items."
type SchemaVersionsConnection {
  "A list of edges."
  edges: [SchemaVersionsEdge!]
  "A flattened list of the nodes."
  nodes: [SchemaVersion!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type SchemaVersionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SchemaVersion!
}

type SetActiveWorkspacePayload {
  errors: [SetActiveWorkspaceError!]
  workspace: Workspace
}

type Stage implements Node {
  api: Api
  changeLog(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    kind: [StageChangeLogKind!]
    "Returns the last _n_ elements from the list."
    last: Int
  ): StageChangeLogConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  conditions: [StageCondition!]!
  coordinate(coordinate: String!): GraphQLTypeSystemMember
  coordinates(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the first _n_ elements from the list."
    first: Int
    from: DateTime
    isDeprecated: Boolean
    kinds: [CoordinateKind!]
    orderBy: [GraphQLCoordinateOrderByInput!]
    search: String
    to: DateTime
  ): CoordinatesConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  deployments(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): DeploymentsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  displayName: String!
  essentials: StageEssentials
  id: ID!
  logDistribution(
    from: DateTime!
    to: DateTime!
  ): OpenTelemetryLogsSeverityGraph
  logs(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    from: DateTime
    "Returns the last _n_ elements from the list."
    last: Int
    to: DateTime
  ): OpenTelemetryLogsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  metrics: StageMetrics!
  name: String!
  publishedClients: [PublishedClient!]!
  publishedFusionConfiguration: FusionConfiguration
  publishedSchema: PublishedSchemaVersion
<<<<<<< HEAD
  subgraphs: [Subgraph!]!
=======
>>>>>>> origin/main
  traceById(
    seeker: String
    spanId: String
    traceId: String!
  ): OpenTelemetryTrace
}

"A connection to a list of items."
type StageChangeLogConnection {
  "A list of edges."
  edges: [StageChangeLogEdge!]
  "A flattened list of the nodes."
  nodes: [StageChangeLog!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type StageChangeLogEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: StageChangeLog!
}

type StageClientsMetrics {
  insights(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the first _n_ elements from the list."
    first: Int
    from: DateTime!
    orderBy: [ClientInsightsOrderByInput!]
    to: DateTime!
  ): ClientInsightsConnection
}

type StageErrorsMetrics {
  insights(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the first _n_ elements from the list."
    first: Int
    from: DateTime!
    search: String
    to: DateTime!
  ): ErrorInsightsConnection
}

type StageEssentials {
  clientCount: Int!
  lastPublishedAt: DateTime
  subgraphCount: Int!
  version: String
}

type StageLatencySummary {
  max: Float
  mean: Float
  min: Float
  p50: Float
  p95: Float
  p99: Float
}

type StageMetrics {
  clients: StageClientsMetrics!
  errors: StageErrorsMetrics!
  operation(hash: String!, operationName: String!): StageOperationMetrics!
  operations: StageOperationsMetrics!
  resolver(coordinate: String!): StageResolverMetrics!
  resolvers: StageResolversMetrics!
  subgraphs: StageSubgraphsMetrics!
  transaction(name: String!): StageTransactionMetrics!
  transactions: StageTransactionsMetrics!
}

type StageNotFoundError implements Error {
  apiId: ID!
  message: String!
  name: String!
}

type StageOperationMetrics {
  latency(from: DateTime!, to: DateTime!): OperationLatencyGraph
<<<<<<< HEAD
=======

>>>>>>> origin/main
  latencyDistribution(
    from: DateTime!
    to: DateTime!
  ): OperationLatencyDistributionGraph
  requestDocument: RequestDocument
  samples(
    from: DateTime!
    maxLatency: Float
    minLatency: Float
    to: DateTime!
  ): [OperationTraceSample!]!
  throughput(
    from: DateTime!
    operationKinds: [OperationKind!] @deprecated(reason: "Not longer in use")
    to: DateTime!
  ): OperationThroughputGraph
}

type StageOperationMetricsSummary {
  latency: StageLatencySummary
  throughput: StageThroughputSummary
}

type StageOperationsMetrics {
  insights(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the first _n_ elements from the list."
    first: Int
    from: DateTime!
    operationKinds: [OperationKind!]
    orderBy: [OperationInsightsOrderByInput!]
    search: String
    to: DateTime!
  ): OperationInsightsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  latency(
    from: DateTime!
    operationKinds: [OperationKind!]
    to: DateTime!
  ): OperationsLatencyGraph
  summary(from: DateTime!, to: DateTime!): StageOperationMetricsSummary!
<<<<<<< HEAD
=======

>>>>>>> origin/main
  throughput(
    from: DateTime!
    operationKinds: [OperationKind!]
    to: DateTime!
  ): OperationsThroughputGraph
}

type StageResolverMetrics {
  latency(from: DateTime!, to: DateTime!): ResolverLatencyGraph
<<<<<<< HEAD
=======

>>>>>>> origin/main
  throughput(from: DateTime!, to: DateTime!): ResolverThroughputGraph
}

type StageResolversMetrics {
  insights(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the first _n_ elements from the list."
    first: Int
    from: DateTime!
    orderBy: [ResolverInsightsOrderByInput!]
    search: String
    to: DateTime!
  ): ResolverInsightsConnection
}

type StageSubgraphsMetrics {
  insights(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the first _n_ elements from the list."
    first: Int
    from: DateTime!
    orderBy: [SubgraphInsightsOrderByInput!]
    to: DateTime!
  ): SubgraphInsightsConnection
}

type StageThroughputSummary {
  errorRate: Float
  opm: Float
  successRate: Float
  totalCount: Long
  totalCountWithError: Long
}

type StageTransactionMetrics {
  latency(from: DateTime!, to: DateTime!): OpenTelemetryTransactionLatencyGraph
<<<<<<< HEAD
=======

>>>>>>> origin/main
  latencyDistribution(
    from: DateTime!
    to: DateTime!
  ): OpenTelemetryTransactionLatencyDistributionGraph
  samples(
    from: DateTime!
    maxLatency: Float
    minLatency: Float
    to: DateTime!
  ): [OpenTelemetryTransactionTraceSample!]!
  throughput(
    from: DateTime!
    to: DateTime!
  ): OpenTelemetryTransactionThroughputGraph
}

type StageTransactionMetricsSummary {
  latency: StageLatencySummary
  throughput: StageThroughputSummary
}

type StageTransactionsMetrics {
  insights(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the first _n_ elements from the list."
    first: Int
    from: DateTime!
    orderBy: [OpenTelemetryTransactionInsightsOrderByInput!]
    search: String
    spanKinds: [OpenTelemetrySpanKind!]
    to: DateTime!
  ): OpenTelemetryTransactionInsightsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  latency(
    from: DateTime!
    spanKinds: [OpenTelemetrySpanKind!]
    to: DateTime!
  ): OpenTelemetryTransactionsLatencyGraph
  summary(from: DateTime!, to: DateTime!): StageTransactionMetricsSummary!
<<<<<<< HEAD
=======

>>>>>>> origin/main
  throughput(
    from: DateTime!
    spanKinds: [OpenTelemetrySpanKind!]
    to: DateTime!
  ): OpenTelemetryTransactionsThroughputGraph
}

type StageValidationError implements Error {
  message: String!
}

type StagesHavePublishedDependenciesError implements Error {
  message: String!
  stages: [Stage!]!
}

type StartFusionConfigurationCompositionPayload {
  errors: [StartFusionConfigurationCompositionError!]
  requestId: ID
}

type SubgraphInsight {
  averageLatency: Float
  errorRate: Float
  id: ID!
  impact: Float
  latency: SubgraphLatencyGraph
  name: String!
  opm: Float
  stage: Stage
  subgraph: Subgraph
  successRate: Float
  throughput: SubgraphThroughputGraph
  totalCount: Long
  totalCountWithErrors: Long
}

"A connection to a list of items."
type SubgraphInsightsConnection {
  "A list of edges."
  edges: [SubgraphInsightsEdge!]
  "A flattened list of the nodes."
  nodes: [SubgraphInsight!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type SubgraphInsightsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SubgraphInsight!
}

type SubgraphInvalidError implements Error {
  message: String!
}

type SubgraphLatencyGraph {
  dataset: [SubgraphLatencyGraphData!]!
}

type SubgraphLatencyGraphData {
  epoch: Long!
  max: Float!
  mean: Float!
  min: Float!
  p50: Float!
  p95: Float!
  p99: Float!
}

type SubgraphThroughputGraph {
  dataset: [SubgraphThroughputGraphData!]!
}

type SubgraphThroughputGraphData {
  epoch: Long!
  errorRate: Float!
  opm: Float!
  successRate: Float!
  totalCount: Long!
  totalCountWithError: Long!
}

type Subscription {
  onClientVersionPublishingUpdate(requestId: ID!): ClientVersionPublishResult!
  onClientVersionValidationUpdate(
    requestId: ID!
  ): ClientVersionValidationResult!
  onFusionConfigurationPublishingTaskChanged(
    requestId: ID!
  ): FusionConfigurationPublishingResult!
<<<<<<< HEAD
  onOpenApiCollectionVersionPublishingUpdate(
    requestId: ID!
  ): OpenApiCollectionVersionPublishResult!
  onOpenApiCollectionVersionValidationUpdate(
    requestId: ID!
  ): OpenApiCollectionVersionValidationResult!
=======
>>>>>>> origin/main
  onPersistedQueriesChanged(
    apiId: ID!
    stageName: String!
  ): PersistedQueriesChanged!
  onSchemaVersionPublishingUpdate(requestId: ID!): SchemaVersionPublishResult!
  onSchemaVersionValidationUpdate(
    requestId: ID!
  ): SchemaVersionValidationResult!
  onStageChangeLogAdded(
    apiId: ID!
    kind: [StageChangeLogKind!]
    stageName: String!
  ): StageChangeLog!
  onStageDeploymentsChanged(stageId: ID!): DeploymentEvent!
}

type ThemeSettings {
  darkThemeName: String
  lightThemeName: String
  themeName: String
  usePreferredOsAppearance: Boolean!
}

type TunnelSession {
  expiresAt: DateTime!
  expiresIn: Int!
  sessionId: ID!
}

type TypeChanged implements SchemaChange {
  newType: String!
  oldType: String!
  severity: SchemaChangeSeverity!
}

type TypeSystemMemberAddedChange implements SchemaChange {
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type TypeSystemMemberModifiedChange implements SchemaChange {
  changes: [SchemaChange!]!
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type TypeSystemMemberRemovedChange implements SchemaChange {
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type UnauthorizedOperation implements Error {
  message: String!
}

type UnexpectedErrorOnChange implements Error {
  message: String!
  workspaceId: ID!
}

type UnexpectedErrorOnDocumentChange implements Error {
  message: String!
  workspaceId: ID!
}

type UnexpectedProcessingError implements SchemaVersionValidationError & SchemaVersionPublishError & ClientVersionValidationError & ClientVersionPublishError & FusionConfigurationPublishingError & FusionConfigurationValidationError & OpenApiCollectionVersionPublishError & OpenApiCollectionVersionValidationError & ProcessingError {
  message: String!
}

type UnionMemberAdded implements SchemaChange {
  severity: SchemaChangeSeverity!
  typeName: String!
}

type UnionMemberRemoved implements SchemaChange {
  severity: SchemaChangeSeverity!
  typeName: String!
}

type UnionModifiedChange implements SchemaChange {
  changes: [UnionChange!]!
  coordinate: String!
  kind: TypeSystemMemberKind!
  severity: SchemaChangeSeverity!
}

type UnpublishClientPayload {
  clientVersion: ClientVersion
  errors: [UnpublishClientError!]
}

type UpdateApiSettingsPayload {
  api: Api
  errors: [UpdateApiSettingsError!]
}

type UpdateFeatureFlagsPayload {
  errors: [UpdateFeatureFlagsError!]
  settings: UserSettings
}

type UpdateMockSchemaPayload {
  errors: [UpdateMockSchemaError!]
  mockSchema: MockSchema
}

type UpdatePreferencesPayload {
  errors: [UpdatePreferencesError!]
  preferences: Any
}

type UpdateStagesPayload {
  api: Api
  errors: [UpdateStagesError!]
}

type UpdateThemeSettingsPayload {
  errors: [UpdateThemeSettingsError!]
  settings: UserSettings
}

type UploadClientPayload {
  clientVersion: ClientVersion
  errors: [UploadClientError!]
}

<<<<<<< HEAD
type UploadOpenApiCollectionPayload {
  errors: [UploadOpenApiCollectionError!]
  openApiCollectionVersion: OpenApiCollectionVersion
=======
type UploadFusionSubgraphPayload {
  errors: [UploadFusionSubgraphError!]
  fusionSubgraphVersion: FusionSubgraphVersion
>>>>>>> origin/main
}

type UploadSchemaPayload {
  errors: [UploadSchemaError!]
  schemaVersion: SchemaVersion
}

type User implements Node {
  id: ID!
  username: String!
}

type UserInfo {
  id: ID!
  username: String!
}

type UserSettings {
  featureFlags: [String!]!
  theme: ThemeSettings!
}

type ValidateClientPayload {
  errors: [ValidateClientError!]
  id: ID
}

type ValidateFusionConfigurationCompositionPayload {
  errors: [ValidateFusionConfigurationCompositionError!]
  requestId: ID
}

type ValidateOpenApiCollectionPayload {
  errors: [ValidateOpenApiCollectionError!]
  id: ID
}

type ValidateSchemaPayload {
  errors: [ValidateSchemaError!]
  id: ID
}

type ValidationError implements Error {
  errors: [ValidationErrorProperty!]!
  message: String!
}

type ValidationErrorProperty {
  message: String!
}

type ValidationInProgress implements FusionConfigurationPublishingResult & ClientVersionValidationResult & SchemaVersionValidationResult & OpenApiCollectionVersionValidationResult {
  state: ProcessingState!
}

type Viewer {
  activeOrganization: Organization
  activeWorkspace: Workspace
  billingUrl: String
  manageTenantUrl: String
  organization: OrganizationInfo
  personalAccessTokens(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): PersonalAccessTokensConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  preferences: Any!
  sessionId: String!
  settings: UserSettings!
  user: User
  workspaces(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkspacesConnection
}

<<<<<<< HEAD
type WaitForApproval implements SchemaVersionPublishResult & ClientVersionPublishResult & FusionConfigurationPublishingResult & OpenApiCollectionVersionPublishResult {
=======
type WaitForApproval implements SchemaVersionPublishResult & ClientVersionPublishResult & FusionConfigurationPublishingResult {
>>>>>>> origin/main
  deployment: Deployment
  state: ProcessingState!
}

type Workspace implements Node {
  apiDocuments(
    "Returns the elements in the list that come after the specified cursor."
    after: Version
    "Returns the first _n_ elements from the list."
    first: Int
  ): ApiDocumentsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  apiKeys(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): ApiKeysConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  apis(
    "Returns the elements in the list that come after the specified cursor."
    after: Version
    "Returns the first _n_ elements from the list."
    first: Int
  ): ApisConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  changed(version: Version!): Boolean!
  changes(
    "Returns the elements in the list that come after the specified cursor."
    after: Version
    "Returns the first _n_ elements from the list."
    first: Int
  ): ChangesConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  documentChanges(
    "Returns the elements in the list that come after the specified cursor."
    after: Version
    "Returns the first _n_ elements from the list."
    first: Int
  ): DocumentChangesConnection @deprecated(reason: "Use changes")
  documents(
    "Returns the elements in the list that come after the specified cursor."
    after: Version
    "Returns the first _n_ elements from the list."
    first: Int
  ): DocumentsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  documentsChanged(version: Version): Boolean!
    @deprecated(reason: "Use changed")
  environments(
    "Returns the elements in the list that come after the specified cursor."
    after: Version
    "Returns the first _n_ elements from the list."
    first: Int
  ): EnvironmentsConnection
<<<<<<< HEAD
=======

>>>>>>> origin/main
  id: ID!
  members: [WorkspaceMember!]!
  name: String!
  personal: Boolean!
  version: Version!
}

type WorkspaceChangePayload {
  error: WorkspaceChangeError
  referenceId: String!
  result: WorkspaceChangeResult
}

type WorkspaceDocument implements Node {
  activeConnectionKind: String!
  body: String!
  createdAt: DateTime!
  createdBy: UserInfo!
  httpConnection: WorkspaceDocumentHttpConnection
  id: ID!
  modifiedAt: DateTime!
  modifiedBy: UserInfo!
  name: String!
  path: [String!]!
  variables: String
  version: Version!
  workspace: Workspace
}

type WorkspaceDocumentAuthentication {
  activeAuthenticationKind: String!
  basicOptions: BasicAuthenticationFlowOptions
  bearerOptions: BearerAuthenticationFlowOptions
  oAuth2Options: OAuth2AuthenticationFlowOptions
}

type WorkspaceDocumentChangeResult {
  document: WorkspaceDocument
  error: WorkspaceDocumentChangeError
  referenceId: String!
}

type WorkspaceDocumentHeader {
  enabled: Boolean!
  name: String!
  value: String!
}

type WorkspaceDocumentHttpConnection {
  authentication: WorkspaceDocumentAuthentication
  endpoint: String!
  headers: [WorkspaceDocumentHeader!]
  includeCookies: Boolean!
  sdlEndpoint: String
  sseSubscriptionEndpoint: String
  subscriptionEndpoint: String
  subscriptionProtocol: String
  useGet: Boolean!
  useTunnel: Boolean!
}

type WorkspaceMember {
  role: WorkspaceUserRole!
  user: UserInfo!
}

type WorkspaceNotFound implements Error {
  message: String!
  workspaceId: ID!
}

type WorkspaceNotFoundForChange implements Error {
  message: String!
  workspaceId: ID!
}

type WorkspaceNotFoundForDocument implements Error {
  message: String!
  workspaceId: ID!
}

type WorkspacePermissionScope implements PermissionScope {
  id: ID!
  type: String!
  workspace: Workspace
}

"A connection to a list of items."
type WorkspacesConnection {
  "A list of edges."
  edges: [WorkspacesEdge!]
  "A flattened list of the nodes."
  nodes: [Workspace!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type WorkspacesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Workspace!
}

union ApiKeyReference = Api

union ApproveDeploymentError =
<<<<<<< HEAD
  | UnauthorizedOperation
=======
    UnauthorizedOperation
>>>>>>> origin/main
  | DeploymentNotFoundError
  | DeploymentIsNotWaitingForApprovalError

union ArgumentChange = DeprecatedChange | DescriptionChanged | TypeChanged

union AuthorizationEventLogPrincipal =
<<<<<<< HEAD
  | UserInfo
=======
    UserInfo
>>>>>>> origin/main
  | ApiKey
  | OrganizationMember
  | Group

union AuthorizationEventLogRealm = Organization | Workspace | User

union AuthorizationEventLogResource = Organization | Workspace | Api

union AuthorizationEventLogSubject = User | ApiKey

union BeginFusionConfigurationPublishError =
<<<<<<< HEAD
  | UnauthorizedOperation
=======
    UnauthorizedOperation
>>>>>>> origin/main
  | ApiNotFoundError
  | StageNotFoundError
  | SubgraphInvalidError
  | InvalidProcessingStateTransitionError

union CancelDeploymentError =
<<<<<<< HEAD
  | UnauthorizedOperation
=======
    UnauthorizedOperation
>>>>>>> origin/main
  | DeploymentNotFoundError
  | DeploymentCannotBeCancelledError

union CancelFusionConfigurationCompositionError =
<<<<<<< HEAD
  | UnauthorizedOperation
=======
    UnauthorizedOperation
>>>>>>> origin/main
  | FusionConfigurationRequestNotFoundError
  | InvalidProcessingStateTransitionError

union ClientDeploymentError = PersistedQueryValidationError

union CommitFusionConfigurationPublishError =
<<<<<<< HEAD
  | UnauthorizedOperation
=======
    UnauthorizedOperation
>>>>>>> origin/main
  | FusionConfigurationRequestNotFoundError
  | InvalidProcessingStateTransitionError

union CreateAccountError = UnauthorizedOperation

union CreateApiKeyError =
<<<<<<< HEAD
  | ApiNotFoundError
=======
    ApiNotFoundError
>>>>>>> origin/main
  | WorkspaceNotFound
  | PersonalWorkspaceNotSupportedError
  | ValidationError
  | UnauthorizedOperation
  | RoleNotFoundError

union CreateApiKeyForApiError =
<<<<<<< HEAD
  | ApiNotFoundError
=======
    ApiNotFoundError
>>>>>>> origin/main
  | PersonalWorkspaceNotSupportedError
  | ValidationError
  | UnauthorizedOperation

union CreateClientError = ApiNotFoundError | UnauthorizedOperation

union CreateMockSchemaError =
<<<<<<< HEAD
  | ApiNotFoundError
  | MockSchemaNonUniqueNameError
  | UnauthorizedOperation
  | ValidationError

union CreateOpenApiCollectionError = ApiNotFoundError | UnauthorizedOperation
=======
    ApiNotFoundError
  | MockSchemaNonUniqueNameError
  | UnauthorizedOperation
  | ValidationError
>>>>>>> origin/main

union CreatePersonalAccessTokenError = ValidationError | UnauthorizedOperation

union CreateWorkspaceError = UnauthorizedOperation | ValidationError

union DeleteApiByIdError =
<<<<<<< HEAD
  | ApiNotFoundError
=======
    ApiNotFoundError
>>>>>>> origin/main
  | UnauthorizedOperation
  | ApiDeletionFailedError

union DeleteApiKeyError = ApiKeyNotFoundError | UnauthorizedOperation

union DeleteClientByIdError = ClientNotFoundError | UnauthorizedOperation

union DeleteMockSchemaByIdError =
<<<<<<< HEAD
  | MockSchemaNotFoundError
  | UnauthorizedOperation

union DeleteOpenApiCollectionByIdError =
  | OpenApiCollectionNotFoundError
=======
    MockSchemaNotFoundError
>>>>>>> origin/main
  | UnauthorizedOperation

union DeploymentEvent = DeploymentCreatedEvent | DeploymentUpdatedEvent

union DirectiveChange =
<<<<<<< HEAD
  | ArgumentAdded
=======
    ArgumentAdded
>>>>>>> origin/main
  | ArgumentChanged
  | ArgumentRemoved
  | DescriptionChanged
  | DirectiveLocationAdded
  | DirectiveLocationRemoved

union EnsureTunnelSessionError = UnauthorizedOperation

union EnumChange =
<<<<<<< HEAD
  | DescriptionChanged
=======
    DescriptionChanged
>>>>>>> origin/main
  | EnumValueAdded
  | EnumValueChanged
  | EnumValueRemoved

union EnumValueChange = DeprecatedChange | DescriptionChanged

union FieldChange =
<<<<<<< HEAD
  | ArgumentAdded
=======
    ArgumentAdded
>>>>>>> origin/main
  | ArgumentChanged
  | ArgumentRemoved
  | DeprecatedChange
  | DescriptionChanged
  | TypeChanged

union FusionConfigurationDeploymentError =
<<<<<<< HEAD
  | PersistedQueryValidationError
  | SchemaChangeViolationError
  | InvalidGraphQLSchemaError
  | OpenApiCollectionValidationError
=======
    PersistedQueryValidationError
  | SchemaChangeViolationError
  | InvalidGraphQLSchemaError
>>>>>>> origin/main

union InputFieldChange = DeprecatedChange | DescriptionChanged | TypeChanged

union InputObjectChange =
<<<<<<< HEAD
  | DescriptionChanged
=======
    DescriptionChanged
>>>>>>> origin/main
  | FieldAddedChange
  | FieldRemovedChange
  | InputFieldChanged

union InterfaceChange =
<<<<<<< HEAD
  | DescriptionChanged
=======
    DescriptionChanged
>>>>>>> origin/main
  | FieldAddedChange
  | FieldRemovedChange
  | InterfaceImplementationAdded
  | InterfaceImplementationRemoved
  | OutputFieldChanged
  | PossibleTypeAdded
  | PossibleTypeRemoved

union ObjectChange =
<<<<<<< HEAD
  | DescriptionChanged
=======
    DescriptionChanged
>>>>>>> origin/main
  | FieldAddedChange
  | FieldRemovedChange
  | InterfaceImplementationAdded
  | InterfaceImplementationRemoved
  | OutputFieldChanged

<<<<<<< HEAD
union OpenApiCollectionDeploymentError = OpenApiCollectionValidationError

union OutputFieldChange =
  | ArgumentAdded
  | ArgumentChanged
  | ArgumentRemoved
  | DeprecatedChange
  | DescriptionChanged
  | TypeChanged

union PollClientVersionPublishRequestError =
  | ClientVersionRequestNotFoundError
  | UnauthorizedOperation

union PollClientVersionValidationRequestError =
  | ClientVersionRequestNotFoundError
  | UnauthorizedOperation

union PollOpenApiCollectionVersionPublishRequestError =
  | OpenApiCollectionVersionRequestNotFoundError
  | UnauthorizedOperation

union PollOpenApiCollectionVersionValidationRequestError =
  | OpenApiCollectionVersionRequestNotFoundError
  | UnauthorizedOperation

union PollSchemaVersionPublishRequestError =
  | SchemaVersionRequestNotFoundError
  | UnauthorizedOperation

union PollSchemaVersionValidationRequestError =
  | SchemaVersionRequestNotFoundError
  | UnauthorizedOperation

union PublishClientError =
  | StageNotFoundError
  | ClientNotFoundError
  | UnauthorizedOperation
  | ClientVersionNotFoundError

union PublishOpenApiCollectionError =
  | StageNotFoundError
  | OpenApiCollectionNotFoundError
  | UnauthorizedOperation
  | OpenApiCollectionVersionNotFoundError

union PublishSchemaError =
  | StageNotFoundError
=======
union OutputFieldChange =
    ArgumentAdded
  | ArgumentChanged
  | ArgumentRemoved
  | DeprecatedChange
  | DescriptionChanged
  | TypeChanged

union PollClientVersionPublishRequestError =
    ClientVersionRequestNotFoundError
  | UnauthorizedOperation

union PollClientVersionValidationRequestError =
    ClientVersionRequestNotFoundError
  | UnauthorizedOperation

union PollSchemaVersionPublishRequestError =
    SchemaVersionRequestNotFoundError
  | UnauthorizedOperation

union PollSchemaVersionValidationRequestError =
    SchemaVersionRequestNotFoundError
  | UnauthorizedOperation

union PublishClientError =
    StageNotFoundError
  | ClientNotFoundError
  | UnauthorizedOperation
  | ClientVersionNotFoundError

union PublishSchemaError =
    StageNotFoundError
>>>>>>> origin/main
  | ApiNotFoundError
  | SchemaNotFoundError
  | UnauthorizedOperation

union PushDocumentChangesError = UnauthorizedOperation | ChangeStructureInvalid

union PushWorkspaceChangesError = UnauthorizedOperation | ChangeStructureInvalid

union RemoveWorkspaceError =
<<<<<<< HEAD
  | UnauthorizedOperation
=======
    UnauthorizedOperation
>>>>>>> origin/main
  | WorkspaceNotFound
  | ValidationError

union RenameWorkspaceError =
<<<<<<< HEAD
  | UnauthorizedOperation
=======
    UnauthorizedOperation
>>>>>>> origin/main
  | WorkspaceNotFound
  | ValidationError

union RevokePersonalAccessTokenError =
<<<<<<< HEAD
  | UnauthorizedOperation
=======
    UnauthorizedOperation
>>>>>>> origin/main
  | PersonalAccessTokenNotFoundError

union RoleAssignmentCondition = RoleAssignmentStageAuthorizationCondition

union ScalarChange = DescriptionChanged

union SchemaChangeLogEntry =
<<<<<<< HEAD
  | DirectiveModifiedChange
=======
    DirectiveModifiedChange
>>>>>>> origin/main
  | EnumModifiedChange
  | InputObjectModifiedChange
  | InterfaceModifiedChange
  | ObjectModifiedChange
  | ScalarModifiedChange
  | TypeSystemMemberAddedChange
  | TypeSystemMemberModifiedChange
  | TypeSystemMemberRemovedChange
  | UnionModifiedChange

union SchemaDeploymentError =
<<<<<<< HEAD
  | PersistedQueryValidationError
=======
    PersistedQueryValidationError
>>>>>>> origin/main
  | SchemaChangeViolationError
  | OperationsAreNotAllowedError
  | SchemaVersionSyntaxError
  | InvalidGraphQLSchemaError
<<<<<<< HEAD
  | OpenApiCollectionValidationError

union SchemaMemberChange =
  | ArgumentAdded
=======

union SchemaMemberChange =
    ArgumentAdded
>>>>>>> origin/main
  | ArgumentChanged
  | ArgumentRemoved
  | DescriptionChanged
  | DirectiveLocationAdded
  | DirectiveLocationRemoved
  | EnumValueAdded
  | EnumValueChanged
  | EnumValueRemoved
  | FieldAddedChange
  | FieldRemovedChange
  | InputFieldChanged
  | InterfaceImplementationAdded
  | InterfaceImplementationRemoved
  | OutputFieldChanged
  | PossibleTypeAdded
  | PossibleTypeRemoved
  | UnionMemberAdded
  | UnionMemberRemoved

union SetActiveWorkspaceError = UnauthorizedOperation | WorkspaceNotFound

union StageCondition = AfterStageCondition

union StartFusionConfigurationCompositionError =
<<<<<<< HEAD
  | UnauthorizedOperation
=======
    UnauthorizedOperation
>>>>>>> origin/main
  | FusionConfigurationRequestNotFoundError
  | InvalidProcessingStateTransitionError

union UnionChange = DescriptionChanged | UnionMemberAdded | UnionMemberRemoved

union UnpublishClientError =
<<<<<<< HEAD
  | StageNotFoundError
=======
    StageNotFoundError
>>>>>>> origin/main
  | ClientNotFoundError
  | UnauthorizedOperation
  | ClientVersionNotFoundError
  | ConcurrentOperationError

union UpdateApiSettingsError = ApiNotFoundError | UnauthorizedOperation

union UpdateFeatureFlagsError = UnauthorizedOperation | ValidationError

union UpdateMockSchemaError =
<<<<<<< HEAD
  | MockSchemaNonUniqueNameError
=======
    MockSchemaNonUniqueNameError
>>>>>>> origin/main
  | MockSchemaNotFoundError
  | UnauthorizedOperation
  | ValidationError

union UpdatePreferencesError = UnauthorizedOperation | ValidationError

union UpdateStagesError =
<<<<<<< HEAD
  | ApiNotFoundError
=======
    ApiNotFoundError
>>>>>>> origin/main
  | StageNotFoundError
  | StagesHavePublishedDependenciesError
  | StageValidationError

union UpdateThemeSettingsError = UnauthorizedOperation | ValidationError

union UploadClientError =
<<<<<<< HEAD
  | ClientNotFoundError
=======
    ClientNotFoundError
>>>>>>> origin/main
  | ConcurrentOperationError
  | InvalidPersistedQueryError
  | UnauthorizedOperation
  | DuplicatedTagError

<<<<<<< HEAD
union UploadOpenApiCollectionError =
  | OpenApiCollectionNotFoundError
  | ConcurrentOperationError
  | UnauthorizedOperation
  | DuplicatedTagError
  | InvalidOpenApiCollectionArchiveError

union UploadSchemaError =
  | ApiNotFoundError
=======
union UploadFusionSubgraphError =
    InvalidFusionSourceSchemaArchiveError
  | ConcurrentOperationError
  | UnauthorizedOperation
  | DuplicatedTagError

union UploadSchemaError =
    ApiNotFoundError
>>>>>>> origin/main
  | ConcurrentOperationError
  | DuplicatedTagError
  | UnauthorizedOperation

union ValidateClientError =
<<<<<<< HEAD
  | StageNotFoundError
=======
    StageNotFoundError
>>>>>>> origin/main
  | ClientNotFoundError
  | UnauthorizedOperation

union ValidateFusionConfigurationCompositionError =
<<<<<<< HEAD
  | UnauthorizedOperation
  | FusionConfigurationRequestNotFoundError
  | InvalidProcessingStateTransitionError

union ValidateOpenApiCollectionError =
  | StageNotFoundError
  | OpenApiCollectionNotFoundError
  | UnauthorizedOperation

union ValidateSchemaError =
  | StageNotFoundError
  | SchemaNotFoundError
  | ApiNotFoundError
  | UnauthorizedOperation

union WorkspaceChangeError =
  | ChangeValidationFailed
  | HasBeenChangedConflict
  | HasBeenDeletedConflict
  | IdentifierCollisionConflict
  | UnexpectedErrorOnChange
  | WorkspaceNotFoundForChange

union WorkspaceChangeResult =
  | ApiDocument
=======
    UnauthorizedOperation
  | FusionConfigurationRequestNotFoundError
  | InvalidProcessingStateTransitionError

union ValidateSchemaError =
    StageNotFoundError
  | SchemaNotFoundError
  | ApiNotFoundError
  | UnauthorizedOperation

union WorkspaceChangeError =
    ChangeValidationFailed
  | HasBeenChangedConflict
  | HasBeenDeletedConflict
  | IdentifierCollisionConflict
  | UnexpectedErrorOnChange
  | WorkspaceNotFoundForChange

union WorkspaceChangeResult =
    ApiDocument
>>>>>>> origin/main
  | Api
  | WorkspaceDocument
  | Environment

union WorkspaceDocumentChangeError =
<<<<<<< HEAD
  | DocumentChangedConflict
=======
    DocumentChangedConflict
>>>>>>> origin/main
  | DocumentNameCollisionConflict
  | DocumentDeletionConflict
  | UnexpectedErrorOnDocumentChange
  | DocumentChangeValidationFailed
  | WorkspaceNotFoundForDocument

input ApiCreateChangeInput {
  httpConnection: ApiHttpConnectionInput
  kind: ApiKind
  name: String!
  path: [String!]!
  referenceId: String!
  workspaceId: ID!
}

input ApiDeleteChangeInput {
  id: ID!
  referenceId: String!
  version: Version!
  workspaceId: ID!
}

input ApiDocumentCreateChangeInput {
  apiId: ID!
  body: String!
  name: String!
  path: [String!]!
  referenceId: String!
  variables: String
  workspaceId: ID!
}

input ApiDocumentDeleteChangeInput {
  apiId: ID!
  id: ID!
  referenceId: String!
  version: Version!
  workspaceId: ID!
}

input ApiDocumentUpdateChangeInput {
  apiId: ID!
  body: String!
  id: ID!
  name: String!
  path: [String!]!
  referenceId: String!
  variables: String
  version: Version!
  workspaceId: ID!
}

input ApiHeaderInput {
  enabled: Boolean!
  name: String!
  value: String!
}

input ApiHttpAuthenticationInput {
  activeAuthenticationKind: String!
  basicOptions: BasicAuthenticationFlowOptionsInput
  bearerOptions: BearerAuthenticationFlowOptionsInput
  oAuth2Options: OAuth2AuthenticationFlowOptionsInput
}

input ApiHttpConnectionInput {
  authentication: ApiHttpAuthenticationInput
  endpoint: String!
  headers: [ApiHeaderInput!]
  includeCookies: Boolean!
  sdlEndpoint: String
  sseSubscriptionEndpoint: String
  subscriptionEndpoint: String
  subscriptionProtocol: String
  useGet: Boolean!
  useTunnel: Boolean!
}

input ApiKeyPermissionScopeInput @oneOf {
  apiId: ID
  workspaceId: ID
}

input ApiUpdateChangeInput {
  httpConnection: ApiHttpConnectionInput
  id: ID!
  kind: ApiKind
  name: String!
  path: [String!]!
  referenceId: String!
  version: Version!
  workspaceId: ID!
}

input ApproveDeploymentInput {
  deploymentId: ID!
}

input BasicAuthenticationFlowOptionsInput {
  password: String!
  username: String!
}

input BearerAuthenticationFlowOptionsInput {
  prefix: String
  token: String!
}

input BeginFusionConfigurationPublishInput {
  apiId: ID!
  stageName: String!
  subgraphApiId: ID
  subgraphName: String
  tag: String!
  waitForApproval: Boolean! = false
}

input CancelDeploymentInput {
  deploymentId: ID!
}

input CancelFusionConfigurationCompositionInput {
  requestId: ID!
}

input ClientInsightsOrderByInput {
  averageLatency: SortEnumType
  errorRate: SortEnumType
  impact: SortEnumType
  opm: SortEnumType
  totalCount: SortEnumType
  totalCountWithError: SortEnumType
}

input CommitFusionConfigurationPublishInput {
  configuration: Upload!
  requestId: ID!
}

input CreateApiKeyForApiInput {
  apiId: ID!
  name: String
}

input CreateApiKeyInput {
  name: String
  permissionScope: ApiKeyPermissionScopeInput!
  roleAssigmentCondition: RoleAssigmentConditionInput
  workspaceId: ID!
}

input CreateClientInput {
  apiId: ID!
  name: String!
}

input CreateMockSchemaInput {
  apiId: ID!
  baseSchemaFile: Upload!
  downstreamUrl: String!
  extensionsSchemaFile: Upload!
  name: String!
}

input CreateOpenApiCollectionInput {
  apiId: ID!
  name: String!
}

input CreatePersonalAccessTokenInput {
  description: String!
  expiresAt: DateTime!
}

input CreateWorkspaceInput {
  name: String!
}

input DeleteApiByIdInput {
  apiId: ID!
}

input DeleteApiKeyInput {
  apiKeyId: ID!
}

input DeleteClientByIdInput {
  clientId: ID!
}

input DeleteMockSchemaByIdInput {
  mockSchemaId: ID!
}

input DeleteOpenApiCollectionByIdInput {
  openApiCollectionId: ID!
}

input EnvironmentCreateChangeInput {
  name: String!
  referenceId: String!
  variables: [EnvironmentVariableInput!]! = []
  workspaceId: ID!
}

input EnvironmentDeleteChangeInput {
  id: ID!
  referenceId: String!
  version: Version!
  workspaceId: ID!
}

input EnvironmentUpdateChangeInput {
  id: ID!
  name: String!
  referenceId: String!
  variables: [EnvironmentVariableInput!]! = []
  version: Version!
  workspaceId: ID!
}

input EnvironmentVariableInput {
  id: String!
  isSecret: Boolean!
  name: String!
  value: String!
}

input GraphQLCoordinateOrderByInput {
  clientCount: SortEnumType
  errorRate: SortEnumType
  meanDuration: SortEnumType
  name: SortEnumType
  operationCount: SortEnumType
  opm: SortEnumType
  totalReferences: SortEnumType
  totalRequests: SortEnumType
  totalUsages: SortEnumType
}

input OAuth2AuthenticationFlowOptionsInput {
  accessTokenUrl: String!
  activeFlowKind: String!
  audience: String!
  authorizationUrl: String!
  clientId: String!
  clientSecret: String!
  credentialsInBody: Boolean!
  grantType: String!
  origin: String!
  password: String!
  pkceMethod: String!
  prefix: String!
  redirectUrl: String!
  resource: String!
  responseType: String!
  scope: String!
  state: String!
  usePkce: Boolean!
  username: String!
}

input OpenTelemetryTransactionInsightsOrderByInput {
  averageLatency: SortEnumType
  errorRate: SortEnumType
  impact: SortEnumType
  opm: SortEnumType
  totalCount: SortEnumType
  totalCountWithError: SortEnumType
}

input OperationInsightsOrderByInput {
  averageLatency: SortEnumType
  errorRate: SortEnumType
  impact: SortEnumType
  opm: SortEnumType
  totalCount: SortEnumType
  totalCountWithError: SortEnumType
}

input PartialApiSettingsInput {
  schemaRegistry: PartialSchemaRegistrySettingsInput
}

input PartialSchemaRegistrySettingsInput {
  allowBreakingSchemaChanges: Boolean! = false
  treatDangerousAsBreaking: Boolean! = false
}

input PollClientVersionPublishRequestInput {
  id: ID!
}

input PollClientVersionValidationRequestInput {
  id: ID!
}

input PollOpenApiCollectionVersionPublishRequestInput {
  id: ID!
}

input PollOpenApiCollectionVersionValidationRequestInput {
  id: ID!
}

input PollSchemaVersionPublishRequestInput {
  id: ID!
}

input PollSchemaVersionValidationRequestInput {
  id: ID!
}

input PublishClientInput {
  clientId: ID!
  force: Boolean! = false
  stage: String!
  tag: String!
  waitForApproval: Boolean! = false
}

input PublishOpenApiCollectionInput {
  force: Boolean! = false
  openApiCollectionId: ID!
  stage: String!
  tag: String!
  waitForApproval: Boolean! = false
}

input PublishSchemaInput {
  apiId: ID!
  force: Boolean! = false
  stage: String!
  tag: String!
  waitForApproval: Boolean! = false
}

input PushApiChangeInput {
  create: ApiCreateChangeInput
  delete: ApiDeleteChangeInput
  update: ApiUpdateChangeInput
}

input PushApiDocumentChangeInput {
  create: ApiDocumentCreateChangeInput
  delete: ApiDocumentDeleteChangeInput
  update: ApiDocumentUpdateChangeInput
}

input PushDocumentChangeInput {
  changes: [WorkspaceDocumentInput!]!
}

input PushEnvironmentChangeInput {
  create: EnvironmentCreateChangeInput
  delete: EnvironmentDeleteChangeInput
  update: EnvironmentUpdateChangeInput
}

input PushWorkspaceChangeInput {
  api: PushApiChangeInput
  apiDocument: PushApiDocumentChangeInput
  document: PushWorkspaceDocumentChangeInput
  environment: PushEnvironmentChangeInput
}

input PushWorkspaceChangesInput {
  changes: [PushWorkspaceChangeInput!]!
}

input PushWorkspaceDocumentChangeInput {
  create: WorkspaceDocumentCreateChangeInput
  delete: WorkspaceDocumentDeleteChangeInput
  update: WorkspaceDocumentUpdateChangeInput
}

input RemoveWorkspaceInput {
  id: ID!
}

input RenameWorkspaceInput {
  id: ID!
  name: String!
}

input ResolverInsightsOrderByInput {
  averageLatency: SortEnumType
  errorRate: SortEnumType
  impact: SortEnumType
  opm: SortEnumType
  totalCount: SortEnumType
  totalCountWithError: SortEnumType
}

input RevokePersonalAccessTokenInput {
  id: ID!
}

input RoleAssigmentConditionInput @oneOf {
  stageAuthorizationCondition: RoleAssignmentStageAuthorizationConditionInput
}

input RoleAssignmentStageAuthorizationConditionInput {
  name: String!
}

input SetActiveWorkspaceInput {
  workspaceId: ID!
}

input StageConditionUpdateInput {
  afterStage: String!
}

input StageUpdateInput {
  conditions: [StageConditionUpdateInput!]! = []
  displayName: String!
  name: String!
}

input StartFusionConfigurationCompositionInput {
  requestId: ID!
}

input SubgraphInsightsOrderByInput {
  averageLatency: SortEnumType
  errorRate: SortEnumType
  impact: SortEnumType
  opm: SortEnumType
  totalCount: SortEnumType
  totalCountWithError: SortEnumType
}

input UnpublishClientInput {
  clientId: ID!
  stage: String!
  tag: String!
}

input UpdateApiSettingsInput {
  apiId: ID!
  settings: PartialApiSettingsInput!
}

input UpdateFeatureFlagsInput {
  featureFlags: [String!]!
}

input UpdateMockSchemaInput {
  baseSchemaFile: Upload
  downstreamUrl: String
  extensionsSchemaFile: Upload
  id: ID!
  name: String
}

input UpdatePreferencesInput {
  preferences: Any!
}

input UpdateStagesInput {
  apiId: ID!
  updatedStages: [StageUpdateInput!]!
}

input UpdateThemeSettingsInput {
  darkThemeName: String
  lightThemeName: String
  themeName: String
  usePreferredOsAppearance: Boolean!
}

input UploadClientInput {
  clientId: ID!
  operations: Upload!
  tag: String!
}

<<<<<<< HEAD
input UploadOpenApiCollectionInput {
  collection: Upload!
  openApiCollectionId: ID!
=======
input UploadFusionSubgraphInput {
  apiId: ID!
  archive: Upload!
>>>>>>> origin/main
  tag: String!
}

input UploadSchemaInput {
  apiId: ID!
  schema: Upload!
  tag: String!
}

input ValidateClientInput {
  clientId: ID!
  operations: Upload!
  stage: String!
}

input ValidateFusionConfigurationCompositionInput {
  configuration: Upload!
  requestId: ID!
}

input ValidateOpenApiCollectionInput {
  collection: Upload!
  openApiCollectionId: ID!
  stage: String!
}

input ValidateSchemaInput {
  apiId: ID!
  schema: Upload!
  stage: String!
}

input WorkspaceDocumentAuthenticationInput {
  activeAuthenticationKind: String!
  basicOptions: BasicAuthenticationFlowOptionsInput
  bearerOptions: BearerAuthenticationFlowOptionsInput
  oAuth2Options: OAuth2AuthenticationFlowOptionsInput
}

input WorkspaceDocumentChangeInput {
  activeConnectionKind: String!
  body: String!
  httpConnection: WorkspaceDocumentHttpConnectionInput
  id: ID
  name: String!
  path: [String!]!
  referenceId: String!
  variables: String
  version: Version
  workspaceId: ID!
}

input WorkspaceDocumentCreateChangeInput {
  activeConnectionKind: String!
  body: String!
  httpConnection: WorkspaceDocumentHttpConnectionInput
  name: String!
  path: [String!]!
  referenceId: String!
  variables: String
  workspaceId: ID!
}

input WorkspaceDocumentDeleteChangeInput {
  id: ID!
  referenceId: String!
  version: Version!
  workspaceId: ID!
}

input WorkspaceDocumentDeleteInput {
  id: ID!
  referenceId: String!
  version: Version!
  workspaceId: ID!
}

input WorkspaceDocumentHeaderInput {
  enabled: Boolean!
  name: String!
  value: String!
}

input WorkspaceDocumentHttpConnectionInput {
  authentication: WorkspaceDocumentAuthenticationInput
  endpoint: String!
  headers: [WorkspaceDocumentHeaderInput!]
  includeCookies: Boolean!
  sdlEndpoint: String
  sseSubscriptionEndpoint: String
  subscriptionEndpoint: String
  subscriptionProtocol: String
  useGet: Boolean!
  useTunnel: Boolean!
}

input WorkspaceDocumentInput {
  delete: WorkspaceDocumentDeleteInput
  put: WorkspaceDocumentChangeInput
}

input WorkspaceDocumentUpdateChangeInput {
  activeConnectionKind: String!
  body: String!
  httpConnection: WorkspaceDocumentHttpConnectionInput
  id: ID!
  name: String!
  path: [String!]!
  referenceId: String!
  variables: String
  version: Version!
  workspaceId: ID!
}

enum ApiKind {
  COLLECTION
  SERVICE
  GATEWAY
}

"Defines when a policy shall be executed."
enum ApplyPolicy {
  "Before the resolver was executed."
  BEFORE_RESOLVER
  "After the resolver was executed."
  AFTER_RESOLVER
  "The policy is applied in the validation step before the execution."
  VALIDATION
}

enum AuthorizationEventEffect {
  ALLOW
  DENY
  BYPASSED
  UNSET
  OTHER
}

enum AuthorizationEventType {
  TENANT_ACCESS_BYPASSED
  TENANT_ACCESS
  PERMISSION_BYPASSED
  PERMISSION_MATCH
  PERMISSION_NO_MATCH
  OTHER
}

enum CoordinateKind {
  NONE
  OBJECT_TYPE
  OBJECT_FIELD
  OBJECT_FIELD_ARGUMENT
  INTERFACE_TYPE
  INTERFACE_FIELD
  INTERFACE_FIELD_ARGUMENT
  UNION_TYPE
  INPUT_OBJECT_TYPE
  INPUT_OBJECT_FIELD
  ENUM_TYPE
  ENUM_VALUE
  SCALAR_TYPE
  DIRECTIVE
  DIRECTIVE_ARGUMENT
  SCHEMA
}

enum DeploymentStatus {
  QUEUED
  READY
  PROCESSING
  WAITING_FOR_APPROVAL
  APPROVED
  SUCCEEDED
  FAILED
  CANCELLED
}

enum DirectiveLocation {
  QUERY
  MUTATION
  SUBSCRIPTION
  FIELD
  FRAGMENT_DEFINITION
  FRAGMENT_SPREAD
  INLINE_FRAGMENT
  VARIABLE_DEFINITION
  SCHEMA
  SCALAR
  OBJECT
  FIELD_DEFINITION
  ARGUMENT_DEFINITION
  INTERFACE
  UNION
  ENUM
  ENUM_VALUE
  INPUT_OBJECT
  INPUT_FIELD_DEFINITION
}

enum FusionConfigurationFormat {
  FGP
  FAR
}

enum OpenTelemetrySpanKind {
  UNSPECIFIED
  SERVER
  CLIENT
  INTERNAL
  PRODUCER
  CONSUMER
}

enum OperationKind {
  QUERY
  SUBSCRIPTION
  MUTATION
}

enum OrganizationPaymentMethod {
  CREDIT_CARD
  INVOICE
}

enum OrganizationPlanType {
  FREE
  SERVERLESS
  DEDICATED
  SELF_HOSTED
}

enum ProcessingState {
  QUEUED
  READY
  PROCESSING
  SUCCESS
  FAILED
  CANCELLED
  WAITING_FOR_APPROVAL
  APPROVED
}

enum RoleEffect {
  "Allows the role assignment"
  ALLOW
  "Denies the role assignment"
  DENY
}

enum SchemaChangeSeverity {
  SAFE
  DANGEROUS
  BREAKING
}

enum SortEnumType {
  ASC
  DESC
}

enum StageChangeLogKind {
  SCHEMA
  CLIENT
  FUSION_CONFIGURATION
  OPEN_API_COLLECTION
}

enum TypeSystemMemberKind {
  OBJECT
  ENUM
  INPUT_OBJECT
  DIRECTIVE
  INTERFACE
  UNION
  SCALAR
}

enum WorkspaceUserRole {
  OWNER
  ADMINISTRATOR
  MEMBER
}

"The `@defer` directive may be provided for fragment spreads and inline fragments to inform the executor to delay the execution of the current fragment to indicate deprioritization of the current fragment. A query with `@defer` directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred is delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`."
directive @defer(
  "Deferred when true."
  if: Boolean
  "If this argument label has a value other than null, it will be passed on to the result of this defer directive. This label is intended to give client applications a way to identify to which fragment a deferred result belongs to."
  label: String
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
The @lookup directive is used within a source schema to specify output fields
that can be used by the distributed GraphQL executor to resolve an entity by
a stable key.
"""
directive @lookup on FIELD_DEFINITION

"The `@oneOf` directive is used within the type system definition language to indicate that an Input Object is a OneOf Input Object."
directive @oneOf on INPUT_OBJECT

directive @shareable on OBJECT | FIELD_DEFINITION

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy(
  "The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types."
  url: String!
) on SCALAR

scalar Any

<<<<<<< HEAD
"The `DateTime` scalar represents an exact point in time. This point in time is specified by having an offset to UTC and does not use a time zone."
scalar DateTime
  @specifiedBy(url: "https://scalars.graphql.org/andimarek/date-time.html")
=======
"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https://www.graphql-scalars.com/date-time")
>>>>>>> origin/main

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

scalar URL @specifiedBy(url: "https://tools.ietf.org/html/rfc3986")

scalar UUID @specifiedBy(url: "https://tools.ietf.org/html/rfc4122")

"The `Upload` scalar type represents a file upload."
scalar Upload

scalar Version
