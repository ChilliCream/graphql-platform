schema {
  query: Query
  mutation: Mutation
}

interface Address {
  city: String
  coordinate: Coordinate
  country: Country!
  formattedAddress: String
  geoProviderType: GeoProviderType!
  id: Int!
  line1: String
  line2: String
  line3: String
  line4: String
  note: String
  placeId: String
  postalCode: String
  region: Region
}

interface BlacklistMatch {
  "A matched entry in the blacklist."
  entry: BlacklistEntry!
  "Highlight information that can be used to indicate to a user why the entry was matched."
  highlights: [BlacklistFieldHighlight!]
  "The identifier for the matched entry. This identifier is used when setting decisions for matches."
  matchId: String!
  "A score indicating how accurate the match is assumed to be. Some blacklist match providers cannot provide a score."
  score: Float
}

interface BlacklistableEntity {
  "Provides blacklist information related to this entity."
  blacklisting: BlacklistingContext!
}

interface ClaimActivity {
  occurredOn: DateTime!
  user: User!
}

interface ClaimContact implements BlacklistableEntity {
  address: Address
  bankAccount: BankAccount
  "Provides blacklist information related to this entity."
  blacklisting: BlacklistingContext!
  contactDetails: [ContactDetail!]!
  id: Int!
  isActive: Boolean!
  name: String!
  purchaseInvoiceBatches: [ClaimPurchaseInvoiceBatch!]!
  reference: String!
  remark: String!
  role: ClaimActorRole
}

interface ClaimJourneyTraveler {
  id: Int!
  name: String!
}

interface Client implements SearchableEntity & BlacklistableEntity {
  addresses: [ClientAddress!]!
  alternateId: String
  availableCommunicationParticipants: [CommunicationParticipant!]!
  availableCommunicationTemplates: [CommunicationTemplate!]!
  bankAccounts: [BankAccount!]!
  "Provides blacklist information related to this entity."
  blacklisting: BlacklistingContext!
  claims(filters: ClaimListFiltersInput order: ClaimOrderInput = { by: CREATED, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): ClaimList!
  communications(filters: CommunicationListFiltersInput order: CommunicationOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): CommunicationList!
  contactDetails: [ContactDetail!]!
  countryOfOrigin: Country
  customFields: CustomFieldContext!
  externalId: String
  id: Int!
  invoiceBatches: [ClaimPurchaseInvoiceBatch!]!
  isActive: Boolean!
  isPinned: Boolean!
  isVip: Boolean!
  language: Culture
  membershipNumber: String
  name: String!
  organisation: Organisation!
  policies(pagination: OptionalPaginationInput): PolicyList!
  tasks(filters: TaskListFiltersInput order: TaskOrderInput = { by: COMPLETED, direction: null, then: { by: DATE, direction: null, then: null } } pagination: OptionalPaginationInput): TaskList!
  uid: UUID!
}

interface Communication {
  "The plain text content of the communication. If the communication consists of a binary file, this field should still consist of a textual representation of that content\nin order to aid with search."
  content: String!
  "The HTML formatted content of the communication."
  contentFormatted: String!
  "The NIS user that created the communication."
  createdBy: User!
  "The time this communication was first saved to storage."
  createdOn: DateTime!
  id: Int!
  isVoided: Boolean!
  "The purchase invoice or payment guarantee connected to the communication."
  purchaseInvoiceOrGuarantee: ClaimPurchaseInvoiceOrPaymentGuarantee
  "The recipient chosen for this communication."
  recipient: CommunicationActor
  "The sender chosen for this communication."
  sender: CommunicationActor
  subject: String!
  "The tags connected to the communication."
  tags: [Tag!]!
  "The template this communication was created from."
  template: CommunicationTemplate
}

interface CommunicationFile {
  contentType: String!
  id: Int!
  name: String!
  size: Int!
}

interface CommunicationWithDirection {
  "The direction of this communication, incoming or outgoing."
  direction: CommunicationDirection!
  externalId: String
  "The time this communication was received in an external system."
  transmittedOn: DateTime
}

interface CommunicationWithFiles {
  "A list of files attached to this communication."
  files: [CommunicationFile!]!
  "Indicates whether this communication has any editable files attached."
  hasEditableFiles: Boolean!
  "Indicates whether this communication has any viewable files attached."
  hasViewableFiles: Boolean!
}

interface Payment {
  activities: [PaymentActivity!]!
  amount: Money!
  bankAccountName: String!
  bankAccountNo: String!
  bankAddress: Address
  bankBranch: String!
  bankControlKey: String!
  bankIban: String!
  bankName: String!
  bankSwift: String!
  createdBy: User!
  createdOn: DateTime!
  definition: PaymentDefinition
  department: Department
  direction: PaymentDirection!
  exchangeRate: Decimal!
  finalSignatureOn: Date
  id: Int!
  moneyAccount: MoneyAccount
  paidOn: Date!
  payInCurrencyCode: String!
  receivedByBankOn: Date
  receiverNote: String!
  recipientAddress: Address
  recipientName: String!
  remark: String!
  sequenceNo: String!
  signatureCount: Int!
  status: PaymentStatus!
  systemAmount: Money!
}

interface Product {
  "Indicates whether claims on policies using this product are allowed to generate financial transactions."
  allowsClaimTransactions: Boolean!
  availableAsSegmentCoverage: Boolean!
  "The calculations available in the product structure specifically for this product node. The same can be accomplished by looking up the matching element in the structure. This is a shortcut."
  calculations("The language used for labels in the product structure. If the requested language is not provided by the product, the default language is used." language: String): [ProductCalculation!]!
  code: String!
  conditionUrl: String!
  coverCauses: [CoverCause!]!
  displayName: String!
  id: Int!
  name: String!
  "The properties available in the product structure specifically for this product node. The same can be accomplished by looking up the matching element in the structure. This is a shortcut."
  properties("The language used for labels in the product structure. If the requested language is not provided by the product, the default language is used." language: String): [ProductProperty!]!
}

interface ProductAgreement {
  id: Int!
  isActive: Boolean!
  product: ProductRoot!
  validPeriod: DateRange!
}

interface ProductStructureChildNode {
  "The key of the parent element."
  parentElementKey: String!
}

interface ProductStructureNode {
  "A description of the node."
  description: String!
  "A key that uniquely identifies the node within the product structure."
  key: String!
  "The name of the node."
  name: String!
  "A value that indicates the order in which nodes should appear."
  orderingIndex: Int!
}

interface Questionnaire {
  "The answers that have been applied to the questionnaire."
  answers: [QuestionnaireAnswer!]!
  "The keys of all sections where all required questions have been answered."
  completedSections: [String!]!
  "Gets the definition of the questionnaire."
  definition("The language to use for the text strings in the definition.\nRequires that translations are defined in the questionnaire for the given language.\nOtherwise the text is returned in the default language for the questionnaire." language: String): QuestionnaireDefinition!
  "The keys of any question that has an invalid answer."
  invalidAnswers: [String!]!
  "Indicates whether the questionnaire has been completed. `true` when there are no unanswered or invalid questions."
  isCompleted: Boolean!
  "The keys of all required questions that have not been answered."
  unansweredQuestions: [String!]!
  "The keys of all questions that are currently visible."
  visibleQuestions: [String!]!
  "The keys of all sections that are currently visible."
  visibleSections: [String!]!
}

interface QuestionnaireAnswer {
  questionId: String!
}

interface QuestionnaireQuestion {
  key: String!
  name: String!
  text: String!
}

interface RootProduct implements Product {
  "Indicates whether claims on policies using this product are allowed to generate financial transactions."
  allowsClaimTransactions: Boolean!
  availableAsSegmentCoverage: Boolean!
  "Specifies various behaviors that indicate how the product is used."
  behaviors: [ProductBehavior!]!
  "The calculations available in the product structure specifically for this product node. The same can be accomplished by looking up the matching element in the structure. This is a shortcut."
  calculations("The language used for labels in the product structure. If the requested language is not provided by the product, the default language is used." language: String): [ProductCalculation!]!
  code: String!
  conditionUrl: String!
  coverCauses: [CoverCause!]!
  coverages: [ProductCoverage!]!
  currencies: [String!]!
  displayName: String!
  id: Int!
  name: String!
  "The properties available in the product structure specifically for this product node. The same can be accomplished by looking up the matching element in the structure. This is a shortcut."
  properties("The language used for labels in the product structure. If the requested language is not provided by the product, the default language is used." language: String): [ProductProperty!]!
  "Used for products with the `STRUCTURAL` behavior. This can be used to get the product structure which is used to show the customized product."
  structure("The language used for labels in the product structure. If the requested language is not provided by the product, the default language is used." language: String): ProductStructure
  "The date range in which policy coverage is allowed."
  validCoverPeriod: DateRange!
  version: String!
}

interface SearchModel {
  id: String!
}

interface SearchParameter {
  display: SearchParameterDisplayOptions
  group: String
  isHidden: Boolean!
  isRequired: Boolean!
  key: String!
  name: String!
}

interface SearchParameterDate {
  maxValue: Date
  minValue: Date
}

interface SearchParameterNumber {
  maxValue: Float
  minValue: Float
}

interface SearchableEntity {
  id: Int!
}

interface SelectionSearchParameterOption {
  label: String!
}

interface StalemateError {
  "Specifies the index of which calculation being performed this error applies to."
  calculationIndex: Int!
  "Specifies the index of the insured within the calculation this error applies to, if any."
  insuredIndex: Int
}

"An error that occurs when the current user is not allowed to access an object."
type AccessDeniedError {
  message: String
  objectDisplayName: String!
  objectId: String!
}

type AddedCustomBlacklistEntriesResponse {
  addedEntries: [BlacklistEntry!]!
}

type AddressSearchModel {
  address: String
  city: String
  countryCode: String
  location: Coordinate
  postalCode: String
  region: String
}

type AggregateCalculationResult {
  results: [CalculationResultItem!]!
}

type ApplicationSettings {
  showEmptyTabs: Boolean!
}

type AssistanceCase {
  accommodation: String!
  airline: String!
  assignee: User
  availablePhases: [ClaimPhase!]!
  availableStatuses: [ClaimStatus!]!
  carRental: String!
  departedOn: Date
  destination: String!
  event(id: Int!): AssistanceEvent
  events: [AssistanceEvent!]!
  phase: ClaimPhase
  reference: String!
  returnedOn: Date
  status: ClaimStatus
  ticketType: String!
  travelAgent: String!
  travelCompanions: Int!
  travelMethod: String!
  travelPurpose: String!
  tripPurchasedOn: DateTime
}

type AssistanceEvent {
  admittedOn: DateTime
  consultation: String!
  consultedOn: DateTime
  customFields: CustomFieldContext!
  dischargedOn: DateTime
  hasPriorApproval: Boolean!
  hospital: String!
  id: Int!
  isTransfer: Boolean!
  patientType: PatientType
  phone: String!
  physician: String!
  physicianPhone: String!
  provider: Provider
  room: String!
  specialty: String!
}

type BankAccount {
  accountNumber: String!
  address: Address
  bankName: String!
  bankReference: String!
  controlKey: String!
  currencyCode: String!
  holderName: String!
  iban: String!
  id: Int!
  isPrimary: Boolean!
  paymentDefinition: PaymentDefinition
  swift: String!
}

type BlacklistAddress {
  addresses: [String!]
  city: String
  country: String
  postalCode: String
  region: String
}

type BlacklistEntry {
  addresses: [BlacklistAddress!]
  affiliations: [String!]
  aliases: [String!]
  datesOfBirth: [FuzzyDate!]
  emails: [String!]
  id: String!
  identifiers: [String!]
  names: [String!]
  nationality: String
  notes: [String!]
  passportNumbers: [String!]
  placesOfBirth: [String!]
  "The blacklist source. Could for example be a certain sanctions list."
  source: BlacklistSource!
  "The id of the entry in the specific blacklist source this entry comes from."
  sourceEntryId: String!
  type: BlacklistEntryType!
}

type BlacklistFieldHighlight {
  "The name of the highlighted field."
  field: String!
  "In cases where the highlighted field is an array, the indicies point to the items in the array that matched."
  indicies: [Int!]
  "In cases where the highlighted field is an array within an array, the index points to the item in the nested array.\nFor example a specific address line on a specific address is matched. The `indicies` will point to the address on the entry, and this index will point to the address line."
  objectIndex: Int
  "The matched values of the field with emphasis indicators inserted, which can assist with displaying the exact reason for the match to the user.\nSome blacklist match providers do not support this."
  values: [String!]
}

type BlacklistHistoryEntry {
  action: BlacklistHistoryAction!
  changedOn: DateTime!
  id: Int!
  justification: String
  user: User!
}

type BlacklistMatchDecision {
  history: [BlacklistMatchDecisionHistoryEntry!]!
  id: Int!
  justification: String
  match: BlacklistMatchWithoutDecision!
  matchedOn: DateTime!
  outcome: BlacklistMatchDecisionOutcome
}

type BlacklistMatchDecisionHistoryEntry {
  changedFrom: BlacklistMatchDecisionOutcome
  changedOn: DateTime!
  changedTo: BlacklistMatchDecisionOutcome
  id: Int!
  justification: String
  previousJustification: String
  user: User!
}

type BlacklistMatchError {
  matches: [BlacklistMatchWithDecision!]!
  subject: BlacklistableEntity!
}

type BlacklistMatchSettings {
  "Performs a blacklist lookup of the claimant during creation of a claim."
  onClaimCreation: Boolean!
  "Performs a blacklist lookup of the payment recipient when signing payments."
  onPaymentSign: Boolean!
  "Performs a blacklist lookup when a provider is changed."
  onProviderChanges: Boolean!
}

type BlacklistMatchWithDecision implements BlacklistMatch {
  "A decision of whether the match is accurate or not."
  decision: BlacklistMatchDecision!
  "A matched entry in the blacklist."
  entry: BlacklistEntry!
  "Highlight information that can be used to indicate to a user why the entry was matched."
  highlights: [BlacklistFieldHighlight!]
  "The identifier for the matched entry. This identifier is used when setting decisions for matches."
  matchId: String!
  "A score indicating how accurate the match is assumed to be. Some blacklist match providers cannot provide a score."
  score: Float
}

type BlacklistMatchWithoutDecision implements BlacklistMatch {
  "A matched entry in the blacklist."
  entry: BlacklistEntry!
  "Highlight information that can be used to indicate to a user why the entry was matched."
  highlights: [BlacklistFieldHighlight!]
  "The identifier for the matched entry. This identifier is used when setting decisions for matches."
  matchId: String!
  "A score indicating how accurate the match is assumed to be. Some blacklist match providers cannot provide a score."
  score: Float
}

type BlacklistPermissions {
  "The user is allowed to add clients, providers, claim contacts or custom entries to the blacklist."
  canAdd: Boolean!
  "The user is allowed to change the decision outcome of blacklist matches."
  canMakeDecisions: Boolean!
  "The user is allowed to remove clients, providers, claim contacts or custom entries from the blacklist."
  canRemove: Boolean!
  "The user is allowed to view the history of manual addition\/removal to\/from the blacklist, and the history of match decision changes."
  canViewHistory: Boolean!
}

type BlacklistSettings {
  "Specifies whether blacklisting is enabled in general."
  isEnabled: Boolean!
  "Specifies when the application should block potentially blacklisted entities from being used."
  match: BlacklistMatchSettings!
}

type BlacklistSource {
  id: UUID!
  name: String!
}

type BlacklistingContext {
  "All existing decisions to prior matches for this entity."
  decisions: [BlacklistMatchDecision!]!
  "A blacklist entry representing this entity. If the entity is added to the blacklist database. This is the data that would be added."
  entry: BlacklistEntry!
  "History of manual blacklist assignments."
  history: [BlacklistHistoryEntry!]!
  "Specifies whether the entity is blacklisted based on a reviewed match against the blacklist database.\nFor example a match occurred while creating a claim, and a user determined that the match was accurate."
  isBlacklistMatched: Boolean!
  "A convenience field that returns true if either `isManuallyBlacklisted` or `isBlacklistMatched` is true."
  isBlacklisted: Boolean!
  "Specifies whether the entity has manually been added to the blacklist by a user."
  isManuallyBlacklisted: Boolean!
  "There are matches without a concluding decision outcome. Therefore the entity is considered a potential blacklist match."
  isPotentiallyBlacklisted: Boolean!
  "Performs a lookup in the blacklist database, and returns entries matching this entity."
  matches("Specifies whether highlight information should be returned. This can assist with displaying the reason for the match to the user." highlight: Boolean! = true): [BlacklistMatchWithDecision!]!
}

type BoolQuestionnaireAnswer implements QuestionnaireAnswer {
  questionId: String!
  value: Boolean!
}

type BooleanProductStructureValue {
  value: Boolean!
}

type BooleanSearchParameter implements SearchParameter {
  display: SearchParameterDisplayOptions
  group: String
  isHidden: Boolean!
  isRequired: Boolean!
  key: String!
  name: String!
}

type BusinessRuleError {
  message: String
}

type CalculatedCoverage {
  accumulatedAnnualPremium: Premium!
  accumulatedPremium: Premium!
  annualPremium: Premium!
  key: String!
  premium: Premium!
  product: Product!
}

type CalculationMessage {
  code: String
  message: String!
  severity: CalculationMessageSeverity!
  source: CalculationMessageSource!
}

type CalculationQuestionnaire implements Questionnaire {
  "The answers that have been applied to the questionnaire."
  answers: [QuestionnaireAnswer!]!
  "The keys of all sections where all required questions have been answered."
  completedSections: [String!]!
  "Gets the definition of the questionnaire."
  definition("The language to use for the text strings in the definition.\nRequires that translations are defined in the questionnaire for the given language.\nOtherwise the text is returned in the default language for the questionnaire." language: String): QuestionnaireDefinition!
  "The keys of any question that has an invalid answer."
  invalidAnswers: [String!]!
  "Indicates whether the questionnaire has been completed. `true` when there are no unanswered or invalid questions."
  isCompleted: Boolean!
  "Indicates whether the questionnaire is required to be answered."
  isRequired: Boolean!
  type: QuestionnaireType!
  "The keys of all required questions that have not been answered."
  unansweredQuestions: [String!]!
  "The keys of all questions that are currently visible."
  visibleQuestions: [String!]!
  "The keys of all sections that are currently visible."
  visibleSections: [String!]!
}

type CalculationResultItem {
  annualPremium: Premium!
  insured: [InsuredCalculationResult!]!
  "Indicates whether the given values result in a state that is valid to be applied."
  isValid: Boolean!
  messages: [CalculationMessage!]!
  payment: PolicyPaymentInformation
  premium: Premium!
  questionnaires: [CalculationQuestionnaire!]!
}

"An error that occurs when the product selections and\/or questionnaire answers given to a calculation caused a stalemate while being applied.\nMeaning that the quote\/policy never ended up in a state where selection could be applied."
type CalculationStalemateError {
  "The specific stalemate errors."
  errors: [StalemateError!]!
}

type CannotCloseClaimPurchaseInvoiceBatchError {
  batchId: Int!
  reason: String
}

type CannotPerformPaymentActionError {
  reason: String
}

type CannotVoidClaimPurchaseInvoiceBatchError {
  batchId: Int!
  reason: String
}

type CaseCreationSettings {
  "Specifies the default policy selection method."
  defaultPolicyMode: CaseCreationDefaultPolicyMode!
}

type CaseFinanceInvoiceBatchSettings {
  "Determines whether the batch is prefilled."
  batchPrefill: Boolean!
  "Determines whether the 'Close batch' checkbox on the case invoice create page should be checked by default for clients."
  clientCloseByDefault: Boolean!
  "Determines whether the 'Close batch' checkbox on the case invoice create page should be checked by default for providers."
  providerCloseByDefault: Boolean!
}

type CaseFinanceSettings {
  "Settings related to case invoice batches."
  invoiceBatches: CaseFinanceInvoiceBatchSettings!
  "Settings related to case invoices."
  invoices: CaseInvoiceSettings!
}

type CaseInvoiceLineSettings {
  "Determines whether the claim invoice lines should be locked after copy."
  lockAfterCopy: Boolean!
}

type CaseInvoiceSettings {
  "Settings related to claim invoice lines."
  lines: CaseInvoiceLineSettings!
}

type CaseSettings {
  "Settings related to case creation."
  creation: CaseCreationSettings!
  "Settings related to case finance."
  finance: CaseFinanceSettings!
}

type ChoiceQuestionnaireAnswer implements QuestionnaireAnswer {
  questionId: String!
  value: [String!]!
}

type Claim implements SearchableEntity {
  accountEntries(filters: ClaimAccountEntryListFiltersInput order: ClaimAccountEntryOrderInput pagination: OptionalPaginationInput): ClaimAccountEntryList!
  accounts: [ClaimAccount!]!
  activities: [ClaimActivity!]!
  assignee: User
  assistance: AssistanceCase!
  associatedClaims: [Claim!]!
  availableCommunicationParticipants: [CommunicationParticipant!]!
  availableCommunicationTemplates: [CommunicationTemplate!]!
  availableCurrencies: [Currency!]!
  availablePaymentDefinitions: [PaymentDefinition!]!
  availablePhases: [ClaimPhase!]!
  availableStatuses: [ClaimStatus!]!
  availableTravelers: [ClaimJourneyTraveler!]!
  balances: ClaimBalances
  calculatedGuaranteeLimitations(input: CreateClaimPaymentGuaranteeInput!): [LimitationCalculation!]!
  calculatedPurchaseInvoiceLimitations(input: CreateClaimPurchaseInvoiceInput!): [LimitationCalculation!]!
  canClose: OperationAllowedResult!
  canDeny: OperationAllowedResult!
  canVoid: OperationAllowedResult!
  claimAccountEntryOrigins: [ClaimAccountEntryOrigin!]!
  claimant: Claimant!
  clausesWithExcludedConditions: [PolicyClause!]!
  communications(filters: CommunicationListFiltersInput order: CommunicationOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): CommunicationList!
  complaint(complaintId: Int!): Complaint
  complaints: [Complaint!]!
  concurrencyToken: String!
  contact(claimContactId: Int!): ClaimContact
  contactDetails: [ContactDetail!]!
  contacts: [ClaimContact!]!
  coverCause: CoverCause!
  coverage: Product
  createdBy: User!
  createdOn: DateTime!
  currencyCode: String!
  customFields: CustomFieldContext!
  department: Department!
  description: String!
  diagnoses: [ClaimDiagnosis!]!
  event: ClaimEvent
  feeDefinitions(entryPoint: FeeEntryPoint!): [ClaimFeeDefinition!]!
  feeTransactions: [ClaimFeeTransaction!]!
  guarantee(id: Int!): ClaimPaymentGuarantee
  guarantees(filters: ClaimPaymentGuaranteeListFiltersInput order: ClaimPurchaseInvoiceOrPaymentGuaranteeOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): ClaimPaymentGuaranteeList!
  id: Int!
  incidentLocation: Address
  incidentOn: Date!
  insuredObjectUid: UUID!
  isDraft: Boolean!
  isPinned: Boolean!
  journey(id: Int!): ClaimJourney
  journeys: [ClaimJourney!]!
  locations: [ClaimLocation!]!
  notifiedOn: Date
  number: Int!
  organisation: Organisation!
  phase: ClaimPhase
  policy: Policy!
  policySituation: PolicySituation!
  product: OrganisationProductRoot!
  purchaseInvoice(id: Int!): ClaimPurchaseInvoice
  purchaseInvoices(filters: ClaimPurchaseInvoiceListFiltersInput order: ClaimPurchaseInvoiceOrPaymentGuaranteeOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): ClaimPurchaseInvoiceList!
  purchaseInvoicesAndGuarantees(filters: ClaimPurchaseInvoiceOrPaymentGuaranteeListFiltersInput order: ClaimPurchaseInvoiceOrPaymentGuaranteeOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): ClaimPurchaseInvoiceOrPaymentGuaranteeList!
  recoveries: [ClaimRecovery!]!
  recovery(id: Int!): ClaimRecovery
  reference: String!
  segments: [Segment!]!
  status: ClaimStatus!
  statusHistory: [ClaimStatusHistory!]!
  strategies: [ClaimStrategy!]!
  tags: [Tag!]!
  tasks(filters: TaskListFiltersInput order: TaskOrderInput = { by: COMPLETED, direction: null, then: { by: DATE, direction: null, then: null } } pagination: OptionalPaginationInput): TaskList!
  tasksWithQuestionnaires: [Task!]!
}

type ClaimAccount {
  coverCause: CoverCause
  entries: [ClaimAccountEntry!]!
  id: Int!
  isDisabled: Boolean!
  isPrimary: Boolean!
  paymentRequestsSum: Money!
  paymentsSum: Money!
  product: Product
  reductionsSum: Money!
  reservesSum: Money!
}

type ClaimAccountEntry {
  account: ClaimAccount
  amount: Money!
  claimAmount: Money!
  createdBy: User
  date: DateTime!
  exchangeRate: Decimal!
  exchangeRateDate: DateTime!
  id: Int!
  invoice: ClaimPurchaseInvoice
  origin: ClaimAccountEntryOrigin
  remark: String!
  reserveType: ReserveType
  type: ClaimAccountEntryType!
}

type ClaimAccountEntryList {
  items: [ClaimAccountEntry!]!
  totalCount: Long!
}

type ClaimActorRole {
  id: Int!
  title: String!
}

type ClaimBalances {
  assistance: Money!
  fees: Money!
  onTheSpotPayments: Money!
  payments: Money!
  pendingPayments: Money!
  recoveries: Money!
  recoveryReserves: Money!
  reserves: Money!
  supplierInvoices: Money!
}

type ClaimCollectiveInvoice {
  batch: ClaimPurchaseInvoiceBatch
  communications: [ClaimCollectiveInvoiceCommunication!]!
  costAgent: Provider
  createdBy: User!
  createdOn: DateTime!
  currencyCode: String!
  dueOn: Date
  id: Int!
  invoiceNumber: String!
  invoicedOn: Date
  isCommitted: Boolean!
  lineSchema: PurchaseInvoiceLineSchema
  lines: [ClaimCollectiveInvoiceLine!]!
  paidAmount: Money!
  provider: Provider!
  receivedOn: Date
  taskConfiguration: ClaimCollectiveInvoiceTaskConfiguration!
}

type ClaimCollectiveInvoiceCommunication {
  content: String!
  file: File
  subject: String!
}

type ClaimCollectiveInvoiceLine {
  benefitCount: Int!
  claim: Claim
  claimAccount: ClaimAccount
  dateFrom: Date!
  dateTo: Date!
  denialReason: ClaimPurchaseInvoiceDenialReason
  deniedAmount: Money!
  description: String!
  discount: Money!
  guarantee: ClaimPaymentGuarantee
  isCovered: Boolean!
  itemMedicalCount: Int!
  itemPrice: Money!
  preDiscount: Money!
  purchasedOn: Date!
  quantity: Int!
  rechargeAmount: Money!
  reductions: Money!
  savings: Money!
  totalPaid: Money!
}

type ClaimCollectiveInvoiceList {
  items: [ClaimCollectiveInvoice!]!
  totalCount: Long!
}

type ClaimCollectiveInvoiceTaskConfiguration {
  category: TaskCategory
  definition: TaskDefinition
  "This value is used as description for any tasks that are automatically generated based on this collective invoice."
  description: String
  "This value is used as title for any tasks that are automatically generated based on this collective invoice."
  title: String
}

type ClaimCommunicationCreatedActivity implements ClaimActivity {
  communication: GetCommunicationResult
  occurredOn: DateTime!
  user: User!
}

type ClaimCompanyContact implements ClaimContact & BlacklistableEntity & ClaimJourneyTraveler {
  address: Address
  bankAccount: BankAccount
  "Provides blacklist information related to this entity."
  blacklisting: BlacklistingContext!
  client: ClientCompany
  contactDetails: [ContactDetail!]!
  id: Int!
  isActive: Boolean!
  name: String!
  purchaseInvoiceBatches: [ClaimPurchaseInvoiceBatch!]!
  reference: String!
  remark: String!
  role: ClaimActorRole
}

type ClaimCreatedActivity implements ClaimActivity {
  occurredOn: DateTime!
  user: User!
}

type ClaimDenialReason {
  id: Int!
  name: String!
}

type ClaimDiagnosis implements SearchableEntity {
  code: String!
  id: Int!
  isPrimary: Boolean!
  name: String!
  trimmedName: String!
}

type ClaimEvent {
  createdBy: User
  createdOn: DateTime!
  id: Int!
  isActive: Boolean!
  name: String!
}

type ClaimFeeCategory {
  id: Int!
  name: String!
}

type ClaimFeeDefinition {
  categories: [ClaimFeeCategory!]!
  currencyCode: String!
  formula: String!
  id: Int!
  name: String!
  status: String!
  type: ClaimFeeType
}

type ClaimFeeTransaction {
  amount: Money!
  amountInClaimCurrency: ConvertMonetaryAmountResult!
  claim: Claim
  claimCurrency: String!
  createdBy: User!
  createdOn: DateTime!
  currencyCode: String!
  exchangeDate: DateTime!
  "The fee definition that this fee transaction was created on the basis of."
  feeDefinition: ClaimFeeDefinition!
  id: Int!
  invoiceNumber: Int!
  remark: String!
  vatAmount: Money!
}

type ClaimFeeType {
  id: Int!
  name: String!
}

type ClaimFinancialService {
  code: String!
  excludeFromReductionCalculation: Boolean!
  id: Int!
  isActive: Boolean!
  name: String!
  nominalAccount: MoneyAccount
  nominalPurchaseAccount: MoneyAccount
  permissionGroups: [PermissionGroup!]!
  vatGroup: VatGroup
}

type ClaimInvoiceSettings {
  useBatching: Boolean!
}

type ClaimJourney {
  availableSegmentTypes: [ClaimJourneySegmentType!]!
  booking(id: Int!): ClaimJourneyBooking
  bookings: [ClaimJourneyBooking!]!
  communications(filters: CommunicationListFiltersInput order: CommunicationOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): CommunicationList!
  createdBy: User!
  fitToTravelOn: Date!
  id: Int!
  isActive: Boolean!
  title: String!
  userInCharge: User!
}

type ClaimJourneyBooking {
  description: String
  id: Int!
  provider: Provider
  quotedAmount: Money!
  reference: String
  segments: [ClaimJourneySegment!]!
  status: ClaimJourneyBookingStatus!
  travelers: [ClaimJourneyTraveler!]!
}

type ClaimJourneySegment {
  id: Int!
  period: LocalDateTimeRange!
  "The position of this segment in the sequence of segments of a travel booking. The first segment has SequenceNumber 1, the next has SequenceNumber 2, etc."
  sequenceNumber: Int!
  type: ClaimJourneySegmentType!
  values: [ClaimJourneySegmentCustomFieldAssignment!]!
}

type ClaimJourneySegmentCustomField {
  defaultValue: String!
  isReadOnly: Boolean!
  isRequiredValue: Boolean!
  name: String!
  type: ClaimJourneySegmentFieldType!
}

type ClaimJourneySegmentCustomFieldAssignment {
  key: String!
  value: CustomFieldValue
}

type ClaimJourneySegmentType {
  fields: [ClaimJourneySegmentCustomField!]!
  id: Int!
  name: String!
}

type ClaimList {
  items: [Claim!]!
  totalCount: Long!
}

type ClaimLocation {
  address: Address!
  type: ClaimLocationType!
}

type ClaimOrganisationContact implements ClaimContact & BlacklistableEntity & ClaimJourneyTraveler {
  address: Address
  bankAccount: BankAccount
  "Provides blacklist information related to this entity."
  blacklisting: BlacklistingContext!
  contactDetails: [ContactDetail!]!
  id: Int!
  isActive: Boolean!
  name: String!
  organisation: Organisation
  purchaseInvoiceBatches: [ClaimPurchaseInvoiceBatch!]!
  reference: String!
  remark: String!
  role: ClaimActorRole
}

type ClaimPayment implements Payment {
  activities: [PaymentActivity!]!
  amount: Money!
  bankAccountName: String!
  bankAccountNo: String!
  bankAddress: Address
  bankBranch: String!
  bankControlKey: String!
  bankIban: String!
  bankName: String!
  bankSwift: String!
  batch: GetClaimPurchaseInvoiceBatchResult
  createdBy: User!
  createdOn: DateTime!
  definition: PaymentDefinition
  department: Department
  direction: PaymentDirection!
  exchangeRate: Decimal!
  finalSignatureOn: Date
  id: Int!
  moneyAccount: MoneyAccount
  paidOn: Date!
  payInCurrencyCode: String!
  receivedByBankOn: Date
  receiverNote: String!
  recipientAddress: Address
  recipientName: String!
  remark: String!
  sequenceNo: String!
  signatureCount: Int!
  status: PaymentStatus!
  systemAmount: Money!
}

type ClaimPaymentGuarantee {
  account: ClaimAccount
  admittedOn: Date!
  calculatedLimitations: [LimitationCalculation!]!
  claim: GetClaimResult!
  communications(filters: CommunicationListFiltersInput order: CommunicationOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): CommunicationList!
  costAgent: Provider
  createdBy: User!
  createdOn: DateTime!
  currencyCode: String!
  customFields: CustomFieldContext!
  dischargedOn: Date!
  "This field will eventually be called Status. It's temporarily named Guarantee to work around what seems to be a hotchocolate error where fields\non types that are used within a union type cannot have clashing names and be of different types.\n            \nThis field would clash with the ClaimPurchaseInvoice.Status field."
  guaranteeStatus: ClaimPaymentGuaranteeStatus!
  id: Int!
  lines: [ClaimPaymentGuaranteeLine!]!
  note: String!
  provider: Provider
  relatedInvoices: [ClaimPurchaseInvoice!]!
  relatedInvoicesCount: Int!
  reserveType: ReserveType
  tasks(filters: TaskListFiltersInput order: TaskOrderInput pagination: OptionalPaginationInput): TaskList!
  total: Money!
  totalInClaimCurrency: ConvertMonetaryAmountResult!
  updatedBy: User!
}

type ClaimPaymentGuaranteeCreatedActivity implements ClaimActivity {
  occurredOn: DateTime!
  paymentGuarantee: ClaimPaymentGuarantee!
  user: User!
}

type ClaimPaymentGuaranteeLine {
  amount: Money!
  benefitCount: Int!
  claimAccount: ClaimAccount
  dateFrom: Date!
  dateTo: Date!
  description: String!
  id: Int!
  itemPrice: Money!
  quantity: Decimal!
  segment: Segment
  service: ClaimFinancialService
}

type ClaimPaymentGuaranteeList {
  items: [ClaimPaymentGuarantee!]!
  totalCount: Long!
}

type ClaimPermissions {
  canCreateClaim: Boolean!
  canManageClaimEvents: Boolean!
  canManageSegments: Boolean!
  canSetEntryDateOnReserve: Boolean!
  canSetTotalReserveAmount: Boolean!
}

type ClaimPersonContact implements ClaimContact & BlacklistableEntity & ClaimJourneyTraveler {
  address: Address
  bankAccount: BankAccount
  "Provides blacklist information related to this entity."
  blacklisting: BlacklistingContext!
  client: ClientPerson
  contactDetails: [ContactDetail!]!
  dateOfBirth: Date
  firstName: String!
  id: Int!
  isActive: Boolean!
  lastName: String!
  name: String!
  purchaseInvoiceBatches: [ClaimPurchaseInvoiceBatch!]!
  reference: String!
  remark: String!
  role: ClaimActorRole
  socialSecurityNumber: String!
  title: ClientTitle
}

type ClaimPersonSearchModel {
  dateOfBirth: Date
  emails: [String!]
  isVip: Boolean!
  name: String!
  phoneNumbers: [String!]
}

type ClaimPhase {
  id: Int!
  name: String!
}

type ClaimPolicySearchModel {
  id: Int!
  number: Int!
  organisation: Organisation
  organisationId: Int!
  references: [String!]
}

type ClaimProviderContact implements ClaimContact & BlacklistableEntity & ClaimJourneyTraveler {
  address: Address
  bankAccount: BankAccount
  "Provides blacklist information related to this entity."
  blacklisting: BlacklistingContext!
  contactDetails: [ContactDetail!]!
  id: Int!
  isActive: Boolean!
  name: String!
  provider: Provider!
  purchaseInvoiceBatches: [ClaimPurchaseInvoiceBatch!]!
  reference: String!
  remark: String!
  role: ClaimActorRole
}

type ClaimPurchaseInvoice {
  admittedOn: Date
  approvedBy: User!
  availablePayees: [ClaimPurchaseInvoicePayee!]!
  batch: ClaimPurchaseInvoiceBatch
  behavior: ClaimPurchaseInvoiceBehavior!
  blockedByTask: Task
  calculatedLimitations: [LimitationCalculation!]!
  claim: GetClaimResult!
  communications(filters: CommunicationListFiltersInput order: CommunicationOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): CommunicationList!
  costAgent: Provider
  createdBy: User!
  createdOn: DateTime!
  currencyCode: String!
  customFields: CustomFieldContext!
  diagnoses: [Diagnosis!]!
  dischargedOn: Date
  dueOn: Date
  guarantee: ClaimPaymentGuarantee
  id: Int!
  "An externally generated invoice number. This is not guaranteed to be unique."
  invoiceNumber: String!
  invoicedOn: DateTime
  isOnHold: Boolean!
  lineSchema: PurchaseInvoiceLineSchema
  lines: [ClaimPurchaseInvoiceLine!]!
  note: String!
  paidAmount: Money!
  payment: ClaimPayment
  paymentDefinition: PaymentDefinition
  provider: Provider
  putOnHoldBy: User!
  receivedOn: Date
  "A flexible reference that can be used for multiple purposes.\nFor medical bills this is sometimes used as a reference to the patient."
  reference: String!
  refundedByInvoice: ClaimPurchaseInvoice
  refundedByPayment: ClaimPayment
  refundedOn: Date!
  refundsInvoice: ClaimPurchaseInvoice
  status: ClaimPurchaseInvoiceStatus!
  tasks(filters: TaskListFiltersInput order: TaskOrderInput pagination: OptionalPaginationInput): TaskList!
  total: Money!
  totalInClaimCurrency: ConvertMonetaryAmountResult!
  updatedBy: User!
  vatAmount: Money!
}

type ClaimPurchaseInvoiceBatch {
  bankAccount: BankAccount
  claimContact: ClaimContact
  client: Client
  closeDate: Date!
  createdBy: User
  createdOn: DateTime!
  id: Int!
  invoices(filters: ClaimPurchaseInvoiceListFiltersInput order: ClaimPurchaseInvoiceOrPaymentGuaranteeOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): ClaimPurchaseInvoiceList!
  name: String!
  note: String!
  payInCurrencyCode: String!
  payableStatus: ClaimPurchaseInvoiceBatchPayableStatus!
  paymentDefinition: PaymentDefinition
  payments: [ClaimPayment!]!
  provider: Provider
  status: ClaimPurchaseInvoiceBatchStatus!
  totalAmount: Money!
}

type ClaimPurchaseInvoiceBatchList {
  items: [ClaimPurchaseInvoiceBatch!]!
  totalCount: Long!
}

type ClaimPurchaseInvoiceBehavior {
  processOrganisationReimbursement: Boolean!
  processPurchase: Boolean!
}

type ClaimPurchaseInvoiceCreatedActivity implements ClaimActivity {
  occurredOn: DateTime!
  purchaseInvoice: ClaimPurchaseInvoice!
  user: User!
}

type ClaimPurchaseInvoiceDenialReason {
  id: Int!
  name: String!
}

type ClaimPurchaseInvoiceLine {
  amount: Money!
  benefitCount: Int!
  claimAccount: ClaimAccount
  dateFrom: Date!
  dateTo: Date!
  decision: ClaimPurchaseInvoiceLineDecision
  denialReason: ClaimPurchaseInvoiceDenialReason
  deniedAmount: Money!
  description: String!
  discount: Money!
  explanations: [ClaimPurchaseInvoiceLineExplanation!]!
  id: Int!
  isCovered: Boolean!
  "Indicates whether the stored price was input by the user excluding VAT"
  isPriceInputExVat: Boolean!
  itemMedicalCount: Decimal!
  itemPrice: Money!
  locked: Boolean!
  originalInvoiceLine: ClaimPurchaseInvoiceLine
  paidAmount: Money!
  preDiscount: Money!
  provider: Provider
  quantity: Decimal!
  savings: Money!
  segment: Segment
  service: ClaimFinancialService
  vatAmount: Money!
  vatGroup: VatGroup
}

type ClaimPurchaseInvoiceLineDecision {
  canBeRemoved: Boolean!
  code: String!
  id: Int!
  isActive: Boolean!
  name: String!
}

type ClaimPurchaseInvoiceLineExplanation {
  canBeRemoved: Boolean!
  code: String!
  id: Int!
  isActive: Boolean!
  name: String!
}

type ClaimPurchaseInvoiceList {
  items: [ClaimPurchaseInvoice!]!
  totalCount: Long!
}

type ClaimPurchaseInvoiceOrPaymentGuaranteeList {
  items: [ClaimPurchaseInvoiceOrPaymentGuarantee!]!
  totalCount: Long!
}

type ClaimRecovery {
  account: ClaimAccount!
  communications(filters: CommunicationListFiltersInput order: CommunicationOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): CommunicationList!
  currencyCode: String!
  customFields: CustomFieldContext!
  deadline: Date
  id: Int!
  invoice: ClaimPurchaseInvoice
  notifiedOn: Date
  obtained: Money!
  provider: Provider
  reference: String!
  remark: String!
  reserved: Money!
  status: ClaimRecoveryStatus!
  tasks(filters: TaskListFiltersInput order: TaskOrderInput = { by: COMPLETED, direction: null, then: { by: DATE, direction: null, then: null } } pagination: OptionalPaginationInput): TaskList!
  type: ClaimRecoveryType!
}

type ClaimRecoveryType {
  code: String!
  id: Int!
  name: String!
}

type ClaimSearchModel implements SearchModel {
  assignee: User
  assistanceAssignee: User
  assistanceStatus: ClaimStatus
  claimants: [ClaimPersonSearchModel!]!
  contacts: [ClaimPersonSearchModel!]
  coverCause: CoverCause
  createdOn: DateTime!
  department: Department!
  event: ClaimEvent
  id: String!
  incidentLocation: AddressSearchModel
  incidentOccurredOn: Date
  isDraft: Boolean!
  number: Int!
  policy: ClaimPolicySearchModel!
  references: [String!]
  status: ClaimStatus
}

type ClaimStatusChangedActivity implements ClaimActivity {
  assistanceStatus: ClaimStatus
  occurredOn: DateTime!
  status: ClaimStatus
  user: User!
}

type ClaimStatusHistory {
  assistancePhase: ClaimPhase
  assistanceStatus: ClaimStatus!
  changeDate: Date!
  changedBy: User!
  claimDenialReason: ClaimDenialReason!
  id: Int!
  phase: ClaimPhase
  status: ClaimStatus!
}

type ClaimStrategy {
  createdBy: User!
  createdOn: DateTime!
  id: String!
  revisions: [ClaimStrategy!]!
  strategy: String!
  type: ClaimStrategyType!
}

type ClaimTaskActivity implements ClaimActivity {
  occurredOn: DateTime!
  task: Task!
  user: User!
}

type ClaimTaskClosedActivity implements ClaimActivity {
  occurredOn: DateTime!
  task: Task!
  user: User!
}

type ClaimTaskCreatedActivity implements ClaimActivity {
  occurredOn: DateTime!
  task: Task!
  user: User!
}

type Claimant {
  client: Client!
  limitations(calculateOn: DateTime): [Limitation!]!
}

type ClauseCategory {
  id: Int!
  name: String!
}

type ClientAddress implements Address {
  city: String
  coordinate: Coordinate
  country: Country!
  formattedAddress: String
  geoProviderType: GeoProviderType!
  id: Int!
  isPrimary: Boolean!
  line1: String
  line2: String
  line3: String
  line4: String
  note: String
  placeId: String
  postalCode: String
  region: Region
  type: ClientAddressType!
}

type ClientAddressSearchModel {
  address: String
  city: String
  countryCode: String
  location: Coordinate
  postalCode: String
  region: String
  type: ClientAddressType!
}

type ClientCompany implements Client & SearchableEntity & BlacklistableEntity & ClaimJourneyTraveler {
  addresses: [ClientAddress!]!
  alternateId: String
  availableCommunicationParticipants: [CommunicationParticipant!]!
  availableCommunicationTemplates: [CommunicationTemplate!]!
  bankAccounts: [BankAccount!]!
  "Provides blacklist information related to this entity."
  blacklisting: BlacklistingContext!
  claims(filters: ClaimListFiltersInput order: ClaimOrderInput = { by: CREATED, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): ClaimList!
  communications(filters: CommunicationListFiltersInput order: CommunicationOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): CommunicationList!
  companyId: String!
  concurrencyToken: String!
  contactDetails: [ContactDetail!]!
  countryOfOrigin: Country
  customFields: CustomFieldContext!
  externalId: String
  id: Int!
  invoiceBatches: [ClaimPurchaseInvoiceBatch!]!
  isActive: Boolean!
  isPinned: Boolean!
  isVip: Boolean!
  language: Culture
  membershipNumber: String
  name: String!
  organisation: Organisation!
  policies(pagination: OptionalPaginationInput): PolicyList!
  tasks(filters: TaskListFiltersInput order: TaskOrderInput = { by: COMPLETED, direction: null, then: { by: DATE, direction: null, then: null } } pagination: OptionalPaginationInput): TaskList!
  uid: UUID!
}

type ClientPermissions {
  canManageVips: Boolean!
}

type ClientPerson implements Client & SearchableEntity & BlacklistableEntity & ClaimJourneyTraveler {
  addresses: [ClientAddress!]!
  alternateId: String
  availableCommunicationParticipants: [CommunicationParticipant!]!
  availableCommunicationTemplates: [CommunicationTemplate!]!
  bankAccounts: [BankAccount!]!
  "Provides blacklist information related to this entity."
  blacklisting: BlacklistingContext!
  claims(filters: ClaimListFiltersInput order: ClaimOrderInput = { by: CREATED, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): ClaimList!
  communications(filters: CommunicationListFiltersInput order: CommunicationOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): CommunicationList!
  concurrencyToken: String!
  contactDetails: [ContactDetail!]!
  countryOfOrigin: Country
  customFields: CustomFieldContext!
  dateOfBirth: Date
  dateOfDeath: Date
  employeeNumber: String
  externalId: String
  firstName: String!
  gender: Gender
  heightCm: Decimal
  id: Int!
  invoiceBatches: [ClaimPurchaseInvoiceBatch!]!
  isActive: Boolean!
  isDeceased: Boolean!
  isPinned: Boolean!
  isVip: Boolean!
  jobTitle: String
  language: Culture
  lastName: String!
  membershipNumber: String
  name: String!
  nationalityCountryCode: Country
  organisation: Organisation!
  passportCountryCode: Country
  passportExpiryDate: Date
  passportNumber: String
  policies(pagination: OptionalPaginationInput): PolicyList!
  preferredMeasurementSystem: MeasurementSystem!
  segments: [Segment!]!
  socialSecurityNumber: String
  tasks(filters: TaskListFiltersInput order: TaskOrderInput = { by: COMPLETED, direction: null, then: { by: DATE, direction: null, then: null } } pagination: OptionalPaginationInput): TaskList!
  title: ClientTitle
  uid: UUID!
  weightKg: Decimal
}

type ClientPolicySearchModel {
  policyNumber: String!
  productCode: String!
}

type ClientSearchModel implements SearchModel {
  addresses: [ClientAddressSearchModel!]
  alternateIds: [String!]
  claims: [Int!]
  companyIdNumbers: [String!]
  datesOfBirth: [Date!]
  datesOfDeath: [Date!]
  emails: [String!]
  employeeNumbers: [String!]
  externalIds: [String!]
  id: String!
  isActive: Boolean!
  isBlacklisted: Boolean!
  isDeceased: Boolean!
  isVip: Boolean!
  membershipNumbers: [String!]
  names: [String!]!
  organisationIds: [Int!]!
  organisations: [Organisation!]!
  passportNumbers: [String!]
  phoneNumbers: [String!]
  policies: [ClientPolicySearchModel!]
  socialSecurityNumbers: [String!]
  type: ClientType!
}

type ClientSettings {
  "Specifies whether clients with warning notes should be highlighted"
  warningNoteHighlight: Boolean!
}

type ClientTitle {
  gender: Gender
  id: Int!
  isBuiltIn: Boolean!
  name: String!
}

type CloseClaimPurchaseInvoiceBatchesResultList {
  results: [CloseClaimPurchaseInvoiceBatchResult!]!
}

type CommissionEntry {
  amount: Money!
  organisation: Organisation!
}

type CommunicationFieldValue {
  fieldName: String!
  value: String
}

type CommunicationFieldsResult {
  values: [CommunicationFieldValue!]!
}

type CommunicationList {
  items: [Communication!]!
  totalCount: Long!
}

type CommunicationParticipant {
  actor: CommunicationActor
  actorId: Int!
  emails: [String!]!
  faxNumbers: [String!]!
  isDefaultSender: Boolean!
  isNotificationContact: Boolean!
  name: String!
  roleType: CommunicationParticipantRoleType!
}

type CommunicationPermissions {
  canCreateAndEdit: Boolean!
  canManageTemplates: Boolean!
  canVoid: Boolean!
}

type CommunicationSettings {
  "Settings related to email communications."
  email: EmailSettings!
  "Settings related to fax communications."
  fax: FaxSettings!
}

type CommunicationTemplate {
  "The type of application that was used when creating the template."
  application: CommunicationTemplateType!
  "A type indicating if the template is limited to only be used on a certain communication type."
  communicationTypeLimitation: CommunicationTypeLimitation
  "The content (including subject) of the template. Communications created from this template should use these values per default."
  content(contextId: Int! contextType: CommunicationParentType! recipientId: Int! recipientType: CommunicationOutputRecipient!): CommunicationTemplateContent!
  "The id of the template."
  id: Int!
  "Indicates whether this template is an external template, meaning the processing of output is done by a non-NIS actor."
  isExternal: Boolean!
  "The display name of the template."
  name: String!
  "The list of permission groups that are allowed to use this template. If the list is empty, everyone is allowed to use the template."
  permissionGroups: [PermissionGroup!]!
  "A list of template resource objects."
  resources: [CommunicationTemplateResource!]!
  "The tags connected to the template."
  tags: [Tag!]!
  "A list of communication types (e.g. email body or text message)that the template is intended for use with."
  usableOn: [CommunicationTemplateUsableOn!]!
  "The special variable name of the template."
  variableName: String!
}

type CommunicationTemplateContent {
  html: String!
  subject: String!
}

type CommunicationTemplateResource {
  id: Int!
  subject: String!
}

"This class represents the ongoing creation of a new Communication in NIS. The communication token is created by NIS before\nthe generation\/editing of template output is handed off to an external service."
type CommunicationToken {
  "The list of ids of temporary files that should be attached to the final communication."
  attachedFileIds: [Int!]
  "The blind carbon copy list of recipient e-mail addresses."
  bcc: [String!]
  "The carbon copy list of recipient e-mail addresses."
  cc: [String!]
  "Querying Communication fields based on the referenced owner of the token.\n\n\n**Returns:**\nAn IEnumerable`1 instance."
  communicationFields("The list of field names that are being queried." fieldNames: [String!]!): [CommunicationFieldValue!]!
  "The content of the communication."
  content: String
  "The html formatted content of the communication."
  contentFormatted: String
  createdBy: User
  "The URL of the external editor."
  editorUrl: String
  "The recipient fax number chosen in NIS when initiating the communication."
  faxNumber: String
  "The id of the object that will own the finished communication."
  parentId: Int!
  "The type of the object that will own the finished communication."
  parentType: CommunicationParentType!
  "The e-mail of the recipient chosen in NIS when initiating the communication."
  recipientEmail: String
  "The id of the recipient object chosen in NIS when initiating the communication."
  recipientId: Int
  "The type of the recipient object chosen in NIS when initiating the communication."
  recipientType: String
  "The e-mail of the sender chosen in NIS when initiating the communication."
  senderEmail: String
  "The id of the sender chosen in NIS when initiating the communication."
  senderId: Int
  "The type of the sender chosen in NIS when initiating the communication."
  senderType: String
  "The subject of the communication."
  subject: String!
  "The tags that will be connected to the communication."
  tags: [String!]
  "The CommunicationTemplate id chosen in NIS."
  templateId: Int!
  "The id of this token, represented by a GUID string."
  tokenUid: String!
  "The type of the token."
  type: CommunicationTokenType!
  "The list of ids of temporary files that should be attached to the final communication as uploaded files."
  uploadedAttachedFileIds: [String!]
}

type Complaint {
  address: Address!
  approvedOn: DateTime
  category: ComplaintCategory!
  contactDetails: ContactDetail!
  createdOn: DateTime!
  details: String!
  finalResponse: String!
  id: Int!
  name: String!
  receivedBy: ComplaintReceivedBy!
  receivedOn: DateTime!
  state: ComplaintState!
  status: ComplaintStatus!
  title: String!
  type: ComplaintType!
}

type ComplaintCategory {
  id: Int!
  name: String!
}

type ComplaintState {
  behavior: ComplaintStateBehavior!
  id: Int!
  name: String!
}

type ComplaintType {
  id: Int!
  name: String!
}

type ContactDetail {
  id: Int!
  isPrimary: Boolean!
  type: ContactDetailType!
  value: String!
}

type Coordinate {
  latitude: Float!
  longitude: Float!
}

type Country {
  currencyCode: String!
  id: String!
  name: String!
  postalCodeRegex: String
  regions: [Region!]!
}

type CoverCause {
  code: String!
  id: Int!
  name: String!
  parents: [CoverCause!]!
  shortName: String!
}

type CreateExternalPolicyFailure {
  error: CreatePolicyError!
}

type CreateExternalPolicyResult {
  masterPolicyId: Int!
}

type CreatePolicyFromExternalPolicyError {
  message: String
}

type CreatedUserPersonalAccessToken {
  "The UserPersonalAccessToken object that was created."
  personalAccessToken: UserPersonalAccessToken!
  "The token used to authenticate with the application. This value cannot be retrieved again."
  token: String!
}

type Culture {
  id: String!
  localizedName: String!
  name: String!
}

type Currency {
  id: String!
  name: String
}

type CurrentUser implements SearchableEntity {
  availableClaimFinancialServices: [ClaimFinancialService!]!
  availableDepartments: [Department!]!
  availableOrganisations(departmentId: Int): [Organisation!]!
  canBeDeactivated: Boolean!
  coverLevel: Int!
  createdOn: DateTime!
  customDialogs: [CustomDialog!]!
  defaultDepartment: Department
  email: String!
  hasSignaturePassword: Boolean!
  id: Int!
  isActive: Boolean!
  isLocked: Boolean!
  isPasswordValid(password: String!): PasswordValidationCode!
  jobTitle: String!
  lastLogin: DateTime
  maxAuthorizedPayment: Money!
  maxAuthorizedPaymentType: MaxAuthorizedPaymentType!
  maxGuarantee: Money!
  maxReservation: Money!
  maxSelfSign: Money!
  mustChangePassword: Boolean!
  name: String!
  organisation: Organisation
  passwordNeverExpires: Boolean!
  permissionGroups: [PermissionGroup!]!
  permissions: UserPermissionAggregation!
  personalAccessTokens: [UserPersonalAccessToken!]!
  phone: String!
  pinned(pagination: OptionalPaginationInput): PinnableObjectList!
  productVisibilityGroups: [ProductVisibilityGroup!]!
  recentlyViewed(pagination: PaginationInput): RecentlyViewedObjectList!
  sessionKey: UUID!
  tasks(filters: TaskListFiltersInput order: TaskOrderInput = { by: COMPLETED, direction: null, then: { by: DATE, direction: null, then: null } } pagination: PaginationInput): TaskList!
  team: Team
  useProductVisibilityGroups: Boolean!
  username: String!
  visibilityLimit: VisibilityLimitMode!
}

type CustomDialog {
  createDate: DateTime!
  displayType: CustomDialogDisplayType!
  id: Int!
  isActive: Boolean!
  name: String!
  permissionGroups: [PermissionGroup!]!
  refreshWhenClosed: Boolean!
  type: CustomDialogType!
  url: String!
}

type CustomDialogList {
  items: [CustomDialog!]!
  totalCount: Long!
}

type CustomDialogPermissions {
  canManage: Boolean!
}

type CustomField {
  createDisplayMode: CustomFieldCreateDisplayMode!
  displayMode: CustomFieldDisplayMode
  id: Int!
  isBuiltIn: Boolean!
  isHidden: Boolean!
  isReadOnly: Boolean!
  key: String!
  name: String!
  options: [String!]!
  type: CustomFieldValueType
}

type CustomFieldAssignment {
  id: Int!
  key: String!
  value: CustomFieldValue
}

type CustomFieldContext {
  groups: [CustomFieldGroup!]!
  values: [CustomFieldAssignment!]!
}

type CustomFieldGroup {
  fields: [CustomField!]!
  id: Int!
  isHidden: Boolean!
  isReadOnly: Boolean!
  name: String!
}

type CustomFieldValue {
  bool: Boolean
  date: DateTime
  number: Float
  string: String
}

type DateProductStructureValue {
  value: Date!
}

type DateRange {
  end: Date!
  start: Date!
}

type DateRangeSearchParameter implements SearchParameter & SearchParameterDate {
  display: SearchParameterDisplayOptions
  group: String
  isHidden: Boolean!
  isRequired: Boolean!
  key: String!
  maxValue: Date
  minValue: Date
  name: String!
}

type DateSearchParameter implements SearchParameter & SearchParameterDate {
  display: SearchParameterDisplayOptions
  group: String
  isHidden: Boolean!
  isRequired: Boolean!
  key: String!
  maxValue: Date
  minValue: Date
  name: String!
}

type DateSelectionSearchParameterOption implements SelectionSearchParameterOption {
  label: String!
  value: Date!
}

type DateTimeQuestionnaireAnswer implements QuestionnaireAnswer {
  questionId: String!
  value: LocalDateTime!
}

type Department {
  "A code that can be used to uniquely identify the department."
  code: String!
  contactDetails: [ContactDetail!]!
  "The currency used in financial financial transactions for this department."
  currencyCode: String!
  id: Int!
  "A provider that, if specified, is used when making payments to clients via provider invoices."
  manualPaymentProvider: Provider!
  name: String!
  "List of organisations connected to this department."
  organisations(order: OrganisationOrderInput pagination: OptionalPaginationInput): OrganisationList!
  requireRemarkOnReserves: Boolean!
}

"Represents a derived product agreement. A derived product agreement inherits all properties except commission directly from its parent agreement.\nThe commission percentage on the derived agreement specifies the percentage of the parent's commission that should be inherited."
type DerivedProductAgreement implements ProductAgreement {
  derivedCommissionPercentage: Decimal!
  id: Int!
  isActive: Boolean!
  isBlocked: Boolean!
  product: ProductRoot!
  validPeriod: DateRange!
}

type Diagnosis implements SearchableEntity {
  code: String!
  id: Int!
  name: String!
  trimmedName: String!
}

type DiagnosisGroup {
  diagnoses: [Diagnosis!]!
  id: Int!
  name: String!
}

type DiagnosisList {
  items: [Diagnosis!]!
  totalCount: Long!
}

type DiagnosisSearchModel implements SearchModel {
  code: String!
  id: String!
  name: String!
  trimmedName: String!
}

type EmailCommunication implements Communication & CommunicationWithFiles & CommunicationWithDirection {
  "The list of blind carbon copy recipient e-mail addresses."
  bcc: [String!]!
  "The list of carbon copy recipient e-mail addresses."
  cc: [String!]!
  "The plain text content of the communication. If the communication consists of a binary file, this field should still consist of a textual representation of that content\nin order to aid with search."
  content: String!
  "The HTML formatted content of the communication."
  contentFormatted: String!
  "The NIS user that created the communication."
  createdBy: User!
  "The time this communication was first saved to storage."
  createdOn: DateTime!
  direction: CommunicationDirection!
  externalId: String
  "A list of files attached to this communication."
  files: [CommunicationFile!]!
  "The sender e-mail address."
  from: String!
  "Indicates whether this communication has any editable files attached."
  hasEditableFiles: Boolean!
  "Indicates whether this communication has any viewable files attached."
  hasViewableFiles: Boolean!
  id: Int!
  isVoided: Boolean!
  "The purchase invoice or payment guarantee connected to the communication."
  purchaseInvoiceOrGuarantee: ClaimPurchaseInvoiceOrPaymentGuarantee
  "The recipient chosen for this communication."
  recipient: CommunicationActor
  "The sender chosen for this communication."
  sender: CommunicationActor
  subject: String!
  "The tags connected to the communication."
  tags: [Tag!]!
  "The template this communication was created from."
  template: CommunicationTemplate
  "The list of main recipient e-mail addresses."
  to: [String!]!
  transmittedOn: DateTime
}

type EmailFile implements CommunicationFile {
  content: String!
  contentType: String!
  id: Int!
  name: String!
  size: Int!
}

type EmailSettings {
  "Specifies whether the user is allowed to change the sender when creating a new email communication."
  disableSenderOnCreate: Boolean!
  "Specifies whether the user is allowed to edit the body before sending email communication."
  useBuiltInEditor: Boolean!
}

"An common type that represents the result of an entity removal action."
type EntityRemovalResult {
  success: Boolean!
}

type EnvironmentSettings {
  appServicesSiteRootUrl: String!
  "The custom name given the application. Displayed in the application header."
  name: String!
  nordicLinkDownloadUrl: String!
}

type ExchangeRate {
  fromCurrencyCode: String!
  id: Int!
  rate: Decimal!
  toCurrencyCode: String!
  validFrom: DateTime!
}

type ExchangeRateList {
  items: [ExchangeRate!]!
  totalCount: Long!
}

type ExchangeRateNotFoundError {
  fromCurrency: String!
  onDate: Date!
  toCurrency: String!
}

type ExternalPolicy implements SearchModel {
  coverage: DateRange!
  holderDateOfBirth: Date!
  holderFullName: String!
  id: String!
  isExternal: Boolean!
  policyNumber: String
}

type ExternalPolicySearchResult {
  policy: ExternalPolicy!
  schema: SearchSchema!
}

type FaxCommunication implements Communication & CommunicationWithFiles {
  "The plain text content of the communication. If the communication consists of a binary file, this field should still consist of a textual representation of that content\nin order to aid with search."
  content: String!
  "The HTML formatted content of the communication."
  contentFormatted: String!
  "The NIS user that created the communication."
  createdBy: User!
  "The time this communication was first saved to storage."
  createdOn: DateTime!
  "The fax number of the recipient."
  faxNumber: String!
  "A list of files attached to this communication."
  files: [CommunicationFile!]!
  "Indicates whether this communication has any editable files attached."
  hasEditableFiles: Boolean!
  "Indicates whether this communication has any viewable files attached."
  hasViewableFiles: Boolean!
  id: Int!
  isVoided: Boolean!
  "The purchase invoice or payment guarantee connected to the communication."
  purchaseInvoiceOrGuarantee: ClaimPurchaseInvoiceOrPaymentGuarantee
  "The recipient chosen for this communication."
  recipient: CommunicationActor
  "The sender chosen for this communication."
  sender: CommunicationActor
  subject: String!
  "The tags connected to the communication."
  tags: [Tag!]!
  "The template this communication was created from."
  template: CommunicationTemplate
}

type FaxSettings {
  "Specifies whether the user is allowed to create fax communications."
  enabled: Boolean!
}

type File implements CommunicationFile {
  contentType: String!
  id: Int!
  name: String!
  size: Int!
}

type FileCommunication implements Communication & CommunicationWithFiles & CommunicationWithDirection {
  "The plain text content of the communication. If the communication consists of a binary file, this field should still consist of a textual representation of that content\nin order to aid with search."
  content: String!
  "The HTML formatted content of the communication."
  contentFormatted: String!
  "The NIS user that created the communication."
  createdBy: User!
  "The time this communication was first saved to storage."
  createdOn: DateTime!
  direction: CommunicationDirection!
  externalId: String
  "A list of files attached to this communication."
  files: [CommunicationFile!]!
  "Indicates whether this communication has any editable files attached."
  hasEditableFiles: Boolean!
  "Indicates whether this communication has any viewable files attached."
  hasViewableFiles: Boolean!
  id: Int!
  isVoided: Boolean!
  "The purchase invoice or payment guarantee connected to the communication."
  purchaseInvoiceOrGuarantee: ClaimPurchaseInvoiceOrPaymentGuarantee
  "The recipient chosen for this communication."
  recipient: CommunicationActor
  "The sender chosen for this communication."
  sender: CommunicationActor
  subject: String!
  "The tags connected to the communication."
  tags: [Tag!]!
  "The template this communication was created from."
  template: CommunicationTemplate
  transmittedOn: DateTime
}

type FileNotFoundError {
  message: String
}

type FinancePermissions {
  canManageFinance: Boolean!
  canManageFinancialAccounts: Boolean!
  canManageVatGroups: Boolean!
}

type FloatProductStructureValue {
  value: Float!
}

type FuzzyDate {
  from: Date
  to: Date
}

type GenericAddress implements Address {
  city: String
  coordinate: Coordinate
  country: Country!
  formattedAddress: String
  geoProviderType: GeoProviderType!
  id: Int!
  line1: String
  line2: String
  line3: String
  line4: String
  note: String
  placeId: String
  postalCode: String
  region: Region
}

type GenericQuestionnaire implements Questionnaire {
  "The answers that have been applied to the questionnaire."
  answers: [QuestionnaireAnswer!]!
  "The keys of all sections where all required questions have been answered."
  completedSections: [String!]!
  "Gets the definition of the questionnaire."
  definition("The language to use for the text strings in the definition.\nRequires that translations are defined in the questionnaire for the given language.\nOtherwise the text is returned in the default language for the questionnaire." language: String): QuestionnaireDefinition!
  "The keys of any question that has an invalid answer."
  invalidAnswers: [String!]!
  "Indicates whether the questionnaire has been completed. `true` when there are no unanswered or invalid questions."
  isCompleted: Boolean!
  "The keys of all required questions that have not been answered."
  unansweredQuestions: [String!]!
  "The keys of all questions that are currently visible."
  visibleQuestions: [String!]!
  "The keys of all sections that are currently visible."
  visibleSections: [String!]!
}

type GoogleSettings {
  apiKey: String!
}

type IdentityProvider {
  createdAt: DateTime!
  description: String!
  entityId: String!
  id: Int!
  metadataUrl: String
}

type IdentityProviderPermissions {
  canManageIdentityProviders: Boolean!
}

type ImportPaymentsResultList {
  results: [PaymentLedgerItem!]!
}

type InboxType {
  id: String!
  isActive: Boolean!
  name: String!
}

type InsuredCalculationResult {
  "The results of calculations for the insured."
  calculationValues: [ProductValue!]!
  "A list of coverages available to the insured."
  coverages: [CalculatedCoverage!]!
  "This is the key assigned to insured in the input of the calculation."
  key: String
  "The property values assigned to the insured."
  propertyValues: [ProductValue!]!
  "The questionnaires available to the insured."
  questionnaires: [CalculationQuestionnaire!]!
  "The keys of the elements of the product that are selected."
  selectedElements: [String!]!
  "Any tags generated by the calculation. These are typically used to automate certain things like generating fulfillments,\nbut could also be used for similar tasks externally."
  tags: [String!]!
}

type IntegerProductStructureValue {
  value: Int!
}

"An error that occurs when attempting to use input that results in an invalid calculation to mutate policies or quotes (create or change)."
type InvalidCalculationError {
  "The indices of the invalid calculation inputs."
  indices: [Int!]!
}

type InvalidPaymentImportFileError {
  message: String
}

type LetterCommunication implements Communication & CommunicationWithFiles {
  "The plain text content of the communication. If the communication consists of a binary file, this field should still consist of a textual representation of that content\nin order to aid with search."
  content: String!
  "The HTML formatted content of the communication."
  contentFormatted: String!
  "The NIS user that created the communication."
  createdBy: User!
  "The time this communication was first saved to storage."
  createdOn: DateTime!
  "A list of files attached to this communication."
  files: [CommunicationFile!]!
  "Indicates whether this communication has any editable files attached."
  hasEditableFiles: Boolean!
  "Indicates whether this communication has any viewable files attached."
  hasViewableFiles: Boolean!
  id: Int!
  isVoided: Boolean!
  "The purchase invoice or payment guarantee connected to the communication."
  purchaseInvoiceOrGuarantee: ClaimPurchaseInvoiceOrPaymentGuarantee
  "The recipient chosen for this communication."
  recipient: CommunicationActor
  "The sender chosen for this communication."
  sender: CommunicationActor
  subject: String!
  "The tags connected to the communication."
  tags: [Tag!]!
  "The template this communication was created from."
  template: CommunicationTemplate
}

type Limitation {
  calculatedRest: Decimal
  coverCause: CoverCause!
  id: Int!
  insuredScope: LimitationInsuredScope!
  product: Product!
  timeScope: LimitationTimeScope!
  type: LimitationType!
  value: LimitationValue!
}

type LimitationAmount {
  amount: Money!
}

type LimitationCalculation {
  calculationReference: String
  coverCause: CoverCause!
  id: Int!
  insuredObjectUid: UUID!
  isActive: Boolean!
  lines: [LimitationCalculationLine!]!
  postedOn: DateTime!
  product: Product!
  reference: Int!
}

type LimitationCalculationLine {
  code: String!
  id: Int!
  isReduction: Boolean!
  localValue: Decimal!
  value: Decimal!
}

type LimitationCount {
  count: Int!
}

type LimitationPercentage {
  "A value between 0 and 100 representing a percentage."
  percent: Decimal!
}

type LimitationType {
  code: String!
  id: Int!
  name: String!
}

type LinkedProviderService {
  id: Int!
  isCostAgentService: Boolean!
  isPrimary: Boolean!
  name: String!
  parents: [ProviderService!]!
}

type LocalDateTimeRange {
  end: LocalDateTime!
  start: LocalDateTime!
}

type LocationSettings {
  customMapUrl: String
}

type MappedGooglePlaceResult {
  address: GenericAddress!
  isPostalAddress: Boolean!
  validityAction: AddressValidityAction!
}

type MonetaryConversionResult {
  amount: Money!
  exchangeRate: Decimal!
  fromCurrency: String!
}

type Money {
  amount: Decimal!
  currency: String!
}

"Represents a monetary account, usually in connection to a banking institution."
type MoneyAccount {
  canBeRemoved: Boolean!
  "A code that can be used to uniquely identify the account."
  code: String!
  "The currency of the financial account. This is used to select the right account when creating invoices or payments."
  currencyCode: String!
  "An identifier that specifies the format used when exporting payments from this account. The identifier refers to a specific export format."
  exportFormat: String!
  "Identifier of the account for external system usage."
  externalId: String!
  id: Int!
  name: String!
  "The type of the financial account. This indicates whether the account is considered a Money, Organisational or Nominal account."
  type: MoneyAccountType!
}

type Mutation @authorize(apply: BEFORE_RESOLVER, policy: "authorized") {
  "Adds an entry based on the claim contact to the blacklist. The claim contact will be marked as manually blacklisted."
  addClaimContactToBlacklist(claimContactId: Int! justification: String): UpdateClaimContactResult
  "Adds an entry based on the client to the blacklist. The client will be marked as manually blacklisted."
  addClientToBlacklist(clientId: Int! justification: String): UpdateClientResult
  "Adds an entry based on the provider to the blacklist. The provider will be marked as manually blacklisted."
  addProviderToBlacklist(justification: String providerId: Int!): UpdateProviderResult
  "Adds entries to a custom blacklist. The id of each entry uniquely identifies the entry within the custom list. To update an entry, add a new entry with the same id."
  addToCustomBlacklist(entries: [BlacklistEntryInput!]!): AddToCustomBlacklistResult!
  "Picks up a given PhoneCall in NIS. This will change the status of the call to being active for the given user."
  answerPhoneCall(input: AnswerPhoneCallInput!): PhoneCallResult!
  approveClaimPurchaseInvoice(id: Int!): ApproveClaimPurchaseInvoiceResult
  approvePayments(ids: [Int!]! password: String!): PaymentActionsResult!
  "Calculates the price and structure of one or more policy quotes."
  calculateQuotes("The clients used within the calculation. They are referenced elsewhere using their index." clients: [CalculationClientSelectionInput!]! "The quotes to calculate." quotes: [QuoteCalculationItemInput!]! "Specifies whether the calculation should use strict mode or not.\nIt is generally not recommended to turn strict mode off, but it can be necessary in certain circumstances.\n            \nStrict mode will result in a CalculationStalemateError when parts of the given input cannot be applied at any point during calculation.\nFor example when the input specifies that an element on the product should be toggled, but that element is not available because its parent is not selected.\nOr a questionnaire answer is given, but the questionnaire is not available to be answered.\n            \nThese errors are intended to inform the caller that something invalid is being attempted.\nStrict mode is the default behavior everywhere product calculation input is accepted (`createQuotes`, `createPolicies` etc.), and can generally not be turned off,\nbecause it is expected that the given input doesn't contain anything \"accidental\".\n            \nDue to how iterative calls to `calculateQuotes` are used from a UI, it can be necessary to turn strict mode off.\nThis is the case because an element or property could be available in the UI based on auto-selection from the last calculation.\nIf that element or property is being toggled or assigned while the selection becomes unavailable, that would be invalid without the UI knowing that it's invalid\nuntil receiving the result of the calculation." strict: Boolean! = true): QuotesCalculationResult!
  cancelClaimPaymentGuarantee(id: Int!): CancelClaimPaymentGuaranteeResult
  cancelClaimPurchaseInvoice(id: Int!): CancelClaimPurchaseInvoiceResult
  closeClaim(id: Int!): UpdateClaimStatusResult
  closeClaimPurchaseInvoiceBatches(ids: [Int!]!): CloseClaimPurchaseInvoiceBatchesResult!
  commitPayments(payments: [CommitPaymentInput!]!): PaymentActionsResult!
  convertMonetaryAmount(amount: Decimal! fromCurrencyCode: String! onDate: DateTime toCurrencyCode: String!): ConvertMonetaryAmountResult!
  "Creates a new task based on an existing one.\nMost basic properties are copied from the existing task to the new one, including tags and questionnaire answers.\nThe outcome selected on the existing task (if any) is not copied to the new task.\nThe new task will be assigned to the user who performs the operation."
  copyTask("The id of the existing task." taskId: Int!): CreateTaskResult
  createClaim(input: CreateClaimInput!): CreateClaimResult!
  createClaimCollectiveInvoice(input: CreateClaimCollectiveInvoiceInput!): CreateClaimCollectiveInvoiceResult!
  createClaimEvent(input: CreateClaimEventInput!): CreateClaimEventResult!
  createClaimFinancialService(input: CreateClaimFinancialServiceInput!): CreateClaimFinancialServiceResult!
  createClaimPurchaseInvoiceLineDecision(input: CreateClaimPurchaseInvoiceLineDecisionInput!): CreateClaimPurchaseInvoiceLineDecisionResult!
  createClaimPurchaseInvoiceLineExplanation(input: CreateClaimPurchaseInvoiceLineExplanationInput!): CreateClaimPurchaseInvoiceLineExplanationResult!
  createCommunication(input: CreateCommunicationInput! parentId: Int! parentType: CommunicationParentType!): CommunicationActionResult
  createCommunicationFromToken(input: CreateCommunicationFromTokenInput!): CommunicationActionResult
  createCompanyClient(input: CreateCompanyClientInput! organisationId: Int!): CreateCompanyClientResult!
  createCustomDialog(input: CreateCustomDialogInput!): CreateCustomDialogResult!
  createExchangeRate(input: CreateExchangeRateInput!): CreateExchangeRateResult!
  createIdentityProvider(input: CreateIdentityProviderInput!): CreateIdentityProviderResult!
  createInboxType(input: CreateInboxTypeInput!): CreateInboxTypeResult!
  createMoneyAccount(input: CreateMoneyAccountInput!): CreateMoneyAccountResult!
  createOrganisation(input: CreateOrganisationInput!): CreateOrganisationResult
  createPersonClient(input: CreatePersonClientInput! organisationId: Int!): CreatePersonClientResult!
  "Creates a personal access token for a user."
  createPersonalAccessToken(input: CreateUserPersonalAccessTokenInput!): CreateUserPersonalAccessTokenResult!
  "Creates a PhoneCall in NIS, which starts out as not being picked up. The caller should save the return Id,\nin order to be able to reference the call later to pick up, update or end the call."
  createPhoneCall(input: CreatePhoneCallInput!): PhoneCallResult!
  "Creates one or more policies."
  createPolicies("The clients used within the calculation. They are referenced elsewhere using their index." clients: [CalculationClientSelectionInput!]! "The policies to create." policies: [PolicyCreateItemInput!]!): CreatePoliciesResult!
  createPolicyFromExternalPolicy(externalPolicyReference: String! schemaUid: UUID!): CreatePolicyFromExternalPolicyResult!
  createProductVisibilityGroup(input: CreateProductVisibilityGroupInput!): ProductVisibilityGroupResult!
  createProvider(input: CreateProviderInput!): CreateProviderResult!
  "Creates one or more quotes."
  createQuotes("The clients used within the calculation. They are referenced elsewhere using their index." clients: [CalculationClientSelectionInput!]! "The quotes to create." quotes: [QuoteCalculationItemInput!]!): CreateQuotesResult!
  createSegmentType(input: CreateSegmentTypeInput!): CreateSegmentTypeResult!
  createTask(input: CreateTaskInput! ownerId: Int! ownerType: TaskCreationType!): CreateTaskResult
  createTeam(input: CreateTeamInput!): CreateTeamResult!
  createUnassignedFile(input: CreateUnassignedFileInput!): UnassignedFileResult!
  createUser(input: CreateUserInput!): CreateUserResult!
  createVatGroup(input: CreateVatGroupInput!): CreateVatGroupResult!
  createWebHookListener(input: CreateWebHookListenerInput!): CreateWebHookListenerResult!
  deleteUnassignedFile(id: String!): UnassignedFileResult
  denyClaim(denyReasonId: Int denyRemark: String id: Int!): UpdateClaimStatusResult
  "Hangs up a PhoneCall in NIS. This will trigger the creation of any PhoneNote communications resulting from the call."
  endPhoneCall(input: EndPhoneCallInput!): PhoneCallResult!
  "Creates a questionnaire. This can be used to build a set of valid answers to a questionnaire.\nThe answers are not saved. The answers are meant to be given elsewhere that would save them, i.e. saving a task, or creating a quote\/policy."
  evaluateQuestionnaire("The answers to apply." answers: [QuestionnaireAnswerInput!] "The identifier of the questionnaire definition." definitionId: Int! "An optional list of tags that can be used to control which sections and elements are shown.\nThis is relevant for questionnaires used in policy\/quote calculation, where tags output by the product can influence the questionnaire." tags: [String!]): QuestionnaireEvaluationResult
  "Marks the given payments as exported, but does not generate a payment export file."
  exportPayments("A guid identifying the payment export format." exportFormatUid: UUID! "A list of payment identifiers." paymentIds: [Int!]!): ExportPaymentsResult!
  generateClaimDocument(claimId: Int! templateId: Int!): GenerateDocumentResult
  generateClientDocument(clientId: Int! templateId: Int!): GenerateDocumentResult
  "Generates a payment export file for the given payment export identifier."
  generatePaymentExportFile("A payment export identifier." paymentExportId: Int!): GeneratePaymentExportFileResult!
  "Generates a document for a policy."
  generatePolicyDocument("An optional UUID identifying a specific insured on the policy to generate the document for. This only has an effect if the template supports it." insuredObjectUid: UUID "The ID of the policy." policyId: Int! "The ID of the template to generate the document from." templateId: Int!): GenerateDocumentResult
  "Imports payments from the given file using the given payment import format."
  importPayments("An id of a file containing payments to be imported." fileId: String! "A guid identifying an import format." importFormatUid: UUID!): ImportPaymentsResult!
  openClaim(id: Int!): UpdateClaimStatusResult
  "Generates a payment export file for the given list of payments and the given payment export format."
  previewPaymentExportFile("A payment export format uid." paymentExportFormatUid: UUID! "A list of payment identifiers." paymentIds: [Int!]!): GeneratePaymentExportFileResult!
  refundClaimPurchaseInvoice(id: Int!): RefundClaimPurchaseInvoiceResult
  registerObjectView(id: Int! type: ViewRegistrationObjectType!): RecentlyViewedObject
  "Rejects a list of payments by their id. This function is used when payments that originate in NIS are sent outside NIS to be paid, but for any reason failed to be processed by the external system.\nThe external system should use this function to cancel the payments in NIS, so they can be acted upon by a user in NIS to correct the issue that made them fail.\nThe method supports all of claim, policy and financial type payments."
  rejectPayments("One or more payments to reject." payments: [RejectPaymentInput!]!): PaymentActionsResult!
  "If the claim contact has previously manually been blacklisted, this will remove the added entry, and revert the claim contact to not be marked as manually blacklisted."
  removeClaimContactFromBlacklist(claimContactId: Int! justification: String): UpdateClaimContactResult
  removeClaimPurchaseInvoiceLineDecision(id: Int!): RemoveClaimPurchaseInvoiceLineDecisionResult!
  removeClaimPurchaseInvoiceLineExplanation(id: Int!): RemoveClaimPurchaseInvoiceLineExplanationResult!
  "If the client has previously manually been blacklisted, this will remove the added entry, and revert the client to not be marked as manually blacklisted."
  removeClientFromBlacklist(clientId: Int! justification: String): UpdateClientResult
  removeCustomDialog(id: Int!): RemoveCustomDialogResult
  "Removes entries from a custom blacklist."
  removeFromCustomBlacklist("The ids assigned to the entries to be removed, when they were added." entryIds: [String!]!): RemoveFromCustomBlacklistResult!
  removeIdentityProvider(id: Int!): RemoveIdentityProviderResult
  removeMoneyAccount(id: Int!): RemoveMoneyAccountResult
  removeProductVisibilityGroup(id: Int!): RemoveProductVisibilityGroupResult!
  "If the provider has previously manually been blacklisted, this will remove the added entry, and revert the provider to not be marked as manually blacklisted."
  removeProviderFromBlacklist(justification: String providerId: Int!): UpdateProviderResult
  removeTeam(id: Int!): RemoveTeamResult
  removeVatGroup(id: Int!): RemoveVatGroupResult
  removeWebHookListener(id: Int!): RemoveWebHookListenerResult!
  "Revokes a personal access token from a user, making it unusable."
  revokePersonalAccessToken("The ID of the personal access token to remove. If it does not belong to the current user, a permission is required." id: Int!): RevokeUserPersonalAccessTokenResult!
  "Sets decisions of whether claim contact blacklist matches are accurate or not."
  setClaimContactBlacklistMatchDecisions(claimContactId: Int! decisions: [BlacklistMatchDecisionInput!]!): UpdateClaimContactResult
  "Sets decisions of whether client blacklist matches are accurate or not."
  setClientBlacklistMatchDecisions(clientId: Int! decisions: [BlacklistMatchDecisionInput!]!): UpdateClientResult
  "Sets decisions of whether provider blacklist matches are accurate or not."
  setProviderBlacklistMatchDecisions(decisions: [BlacklistMatchDecisionInput!]! providerId: Int!): UpdateProviderResult
  settleClaimPaymentGuarantee(id: Int!): SettleClaimPaymentGuaranteeResult
  signPayments(ids: [Int!]! password: String!): SignPaymentsResult!
  updateClaim(id: Int! input: UpdateClaimInput!): UpdateClaimResult
  updateClaimCollectiveInvoice(input: UpdateClaimCollectiveInvoiceInput!): UpdateClaimCollectiveInvoiceResult
  updateClaimEvent(id: Int! input: UpdateClaimEventInput!): UpdateClaimEventResult!
  updateClaimFinancialService(id: Int! input: UpdateClaimFinancialServiceInput!): UpdateClaimFinancialServiceResult!
  updateClaimPurchaseInvoiceBatch(input: UpdateClaimPurchaseInvoiceBatchInput!): UpdateClaimPurchaseInvoiceBatchResult!
  updateClaimPurchaseInvoiceLineDecision(id: Int! input: UpdateClaimPurchaseInvoiceLineDecisionInput!): UpdateClaimPurchaseInvoiceLineDecisionResult!
  updateClaimPurchaseInvoiceLineExplanation(id: Int! input: UpdateClaimPurchaseInvoiceLineExplanationInput!): UpdateClaimPurchaseInvoiceLineExplanationResult!
  updateClient(input: UpdateClientInput!): UpdateClientResult
  updateCommunication(input: UpdateCommunicationInput!): CommunicationActionResult
  updateCompanyClient(input: UpdateCompanyClientInput!): UpdateCompanyClientResult
  updateCustomDialog(id: Int! input: UpdateCustomDialogInput!): UpdateCustomDialogResult
  updateIdentityProvider(id: Int! input: UpdateIdentityProviderInput!): UpdateIdentityProviderResult
  updateInboxType(input: UpdateInboxTypeInput!): UpdateInboxTypeResult!
  updateMoneyAccount(id: Int! input: UpdateMoneyAccountInput!): UpdateMoneyAccountResult
  updateOrganisation(input: UpdateOrganisationInput!): UpdateOrganisationResult
  updatePayment(id: Int! input: UpdatePaymentInput!): UpdatePaymentResult
  updatePersonClient(input: UpdatePersonClientInput!): UpdatePersonClientResult
  "Updates a PhoneCall in NIS."
  updatePhoneCall(input: UpdatePhoneCallInput!): PhoneCallResult!
  updatePolicy(id: Int! input: UpdatePolicyInput!): UpdatePolicyResult
  updateProductVisibilityGroup(input: UpdateProductVisibilityGroupInput!): ProductVisibilityGroupResult!
  updateProvider(id: Int! input: UpdateProviderInput!): UpdateProviderResult!
  updateSegmentType(input: UpdateSegmentTypeInput!): UpdateSegmentTypeResult!
  updateTask(input: UpdateTaskInput!): UpdateTaskResult
  updateTeam(id: Int! input: UpdateTeamInput!): UpdateTeamResult!
  updateUnassignedFile(input: UpdateUnassignedFileInput!): UnassignedFileResult!
  updateUser(id: Int! input: UpdateUserInput!): UpdateUserResult
  updateUserPassword(input: UpdateUserPasswordInput!): UpdateUserPasswordResult!
  updateUserSignaturePassword(input: UpdateUserSignaturePasswordInput!): UpdateUserPasswordResult
  updateVatGroup(id: Int! input: UpdateVatGroupInput!): UpdateVatGroupResult
  updateWebHookListener(input: UpdateWebHookListenerInput!): UpdateWebHookListenerResult
  voidClaim(id: Int!): UpdateClaimStatusResult
  voidClaimPurchaseInvoiceBatches(ids: [Int!]!): VoidClaimPurchaseInvoiceBatchesResult!
  voidCommunication(id: Int!): CommunicationActionResult
  voidPayments(ids: [Int!]! password: String!): PaymentActionsResult!
}

type NoteCommunication implements Communication {
  "The plain text content of the communication. If the communication consists of a binary file, this field should still consist of a textual representation of that content\nin order to aid with search."
  content: String!
  "The HTML formatted content of the communication."
  contentFormatted: String!
  "The NIS user that created the communication."
  createdBy: User!
  "The time this communication was first saved to storage."
  createdOn: DateTime!
  id: Int!
  isVoided: Boolean!
  "The purchase invoice or payment guarantee connected to the communication."
  purchaseInvoiceOrGuarantee: ClaimPurchaseInvoiceOrPaymentGuarantee
  "The recipient chosen for this communication."
  recipient: CommunicationActor
  "The sender chosen for this communication."
  sender: CommunicationActor
  subject: String!
  "The tags connected to the communication."
  tags: [Tag!]!
  "The template this communication was created from."
  template: CommunicationTemplate
  "The type of the note."
  type: CommunicationNoteType!
}

type NumberRangeSearchParameter implements SearchParameter & SearchParameterNumber {
  display: SearchParameterDisplayOptions
  formatted: Boolean!
  group: String
  integer: Boolean!
  isHidden: Boolean!
  isRequired: Boolean!
  key: String!
  maxValue: Float
  minValue: Float
  name: String!
}

type NumberSearchParameter implements SearchParameter & SearchParameterNumber {
  display: SearchParameterDisplayOptions
  formatted: Boolean!
  group: String
  integer: Boolean!
  isHidden: Boolean!
  isRequired: Boolean!
  key: String!
  maxValue: Float
  minValue: Float
  name: String!
}

type NumberSelectionSearchParameterOption implements SelectionSearchParameterOption {
  label: String!
  value: Float!
}

type OperationAllowedResult {
  isAllowed: Boolean!
  reasons: [String!]!
}

type Organisation implements SearchableEntity {
  addresses: [OrganisationAddress!]!
  "Gets the ancestors of this organisation. This includes the organisation's direct parent, and any ancestors above that.\nThe list is sorted with the nearest ancestor first."
  ancestors: [Organisation!]!
  availableCommunicationParticipants: [CommunicationParticipant!]!
  availableCommunicationTemplates: [CommunicationTemplate!]!
  "Gets all direct children of this organisation. Grandchildren are not included."
  children(order: OrganisationOrderInput = { by: NAME, direction: null, then: null } pagination: OptionalPaginationInput): OrganisationList!
  code: String!
  communications(filters: CommunicationListFiltersInput order: CommunicationOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): CommunicationList!
  contactDetails: [ContactDetail!]!
  contacts: [OrganisationContact!]!
  currencies: [String!]!
  customFields: CustomFieldContext!
  department: Department!
  id: Int!
  isActive: Boolean!
  name: String!
  "Gets the direct parent of the organisation. Returns null if the organisation is a root organisation."
  parent: Organisation
  passwordPolicy: PasswordPolicy
  permissionGroups: [PermissionGroup!]!
  product(coverageOn: Date productId: Int!): OrganisationProductRoot
  "Gets groups of product agreements. Each group contains a product along with all product agreements that exist for that product on this organisation.\nProducts that do not have any existing agreements on this organisation are not included."
  productAgreementGroups: [ProductAgreementGroup!]!
  products(coverageOn: Date requiredBehaviors: [ProductBehavior!]): [OrganisationProductRoot!]!
  "Gets a list of products for which derived product agreements can be created on this organisation. This includes all products that have an agreement on\nthis organisation's parent organisation, and that do not already have an agreement on this organisation."
  productsAvailableForDerivedAgreements: [ProductRoot!]!
  secondaryTypes: [OrganisationType]!
  shortName: String!
  tasks(filters: TaskListFiltersInput order: TaskOrderInput = { by: COMPLETED, direction: null, then: { by: DATE, direction: null, then: null } } pagination: OptionalPaginationInput): TaskList!
  type: OrganisationType!
  users(order: UserOrderInput = { by: NAME, direction: null, then: null } pagination: PaginationInput): UserList!
  "A value added tax identification number or VAT identification number is an identifier used in many countries, including the countries of the European Union, for value added tax purposes."
  vatIdentificationNumber: String!
}

type OrganisationAddress implements Address {
  city: String
  coordinate: Coordinate
  country: Country!
  formattedAddress: String
  geoProviderType: GeoProviderType!
  id: Int!
  isBuiltIn: Boolean!
  line1: String
  line2: String
  line3: String
  line4: String
  note: String
  placeId: String
  postalCode: String
  region: Region
  type: OrganisationAddressType!
}

type OrganisationContact {
  contactDetails: [ContactDetail!]!
  department: String!
  id: Int!
  internalComment: String!
  isInternal: Boolean!
  jobTitle: String!
  name: String!
  title: ClientTitle
  type: OrganisationContactType!
}

type OrganisationList {
  items: [Organisation!]!
  totalCount: Long!
}

type OrganisationPermissions {
  canManageOrganisations: Boolean!
}

"Represents a special type of product that is used in contexts where an organisation and date of coverage is implicitly given.\nIn such contexts the coverages available on the product should be filtered to only include\nthose that are available for the given organisation on the given date of coverage.\n            \nAn example of this is when the product is accessed through a claim (which implicitly gives us an organisation and a date)."
type OrganisationProductRoot implements Product & RootProduct {
  "Indicates whether claims on policies using this product are allowed to generate financial transactions."
  allowsClaimTransactions: Boolean!
  availableAsSegmentCoverage: Boolean!
  "Specifies various behaviors that indicate how the product is used."
  behaviors: [ProductBehavior!]!
  calculations(language: String): [ProductCalculation!]!
  code: String!
  "Link to product description."
  conditionUrl: String!
  coverCauses: [CoverCause!]!
  "Gets a collection of coverages for the given product and organisation on the given coverage date"
  coverages: [ProductCoverage!]!
  currencies: [String!]!
  displayName: String!
  id: Int!
  name: String!
  properties(language: String): [ProductProperty!]!
  "Used for products with the `STRUCTURAL` behavior. This can be used to get the product structure which is used to show the customized product."
  structure("The language used for labels in the product structure. If the requested language is not provided by the product, the default language is used." language: String): ProductStructure
  validCoverPeriod: DateRange!
  version: String!
  versions: [ProductRoot!]!
}

type OrganisationSearchModel implements SearchModel {
  code: String!
  department: Department!
  id: String!
  name: String!
  shortName: String!
}

type OrganisationSettings {
  "Specifies whether password policy should be enforced when changing passwords."
  enforcePasswordPolicies: Boolean!
}

type PasswordIncorrectError {
  message: String
}

type PasswordPolicy {
  maxPasswordLength: Int!
  minPasswordLength: Int!
  specialCharacters: [String!]!
}

type PatientType {
  id: Int!
  isActive: Boolean!
  isBuiltIn: Boolean!
  isDefault: Boolean!
  name: String!
  shortName: String!
}

type PaymentActionsResultList {
  results: [PaymentActionResult!]!
}

type PaymentActivity {
  createdBy: User!
  createdOn: DateTime!
  description: String
  id: Int!
  type: PaymentActivityType!
}

type PaymentCommitFailure {
  error: PaymentCommitError!
  paymentId: Int!
}

type PaymentDefinition {
  "A code that can be used to uniquely identify the payment definition."
  code: String!
  currencies: [Currency!]!
  id: Int!
  "If a bank account is configured for usage with this definition, these fields must be filled out on the account."
  mandatoryBankAccountFields: [BankAccountFieldType!]!
  name: String!
}

type PaymentExport {
  exportedOn: Date!
  format: PaymentExportFormat!
  id: Int!
  payments(filters: PaymentListFiltersInput order: PaymentOrderInput pagination: PaginationInput): PaymentList!
  user: User!
}

type PaymentExportFormat {
  format: String!
  id: UUID!
  name: String!
}

type PaymentExportList {
  items: [PaymentExport!]!
  totalCount: Long!
}

type PaymentImportProvider {
  name: String!
  uid: UUID!
}

type PaymentInstalment {
  adjustment: Money!
  dueOn: Date!
  fee: Money!
  gross: Money!
  range: DateRange!
  roundingCorrection: Money!
  tax: Money!
  total: Money!
}

type PaymentLedgerItem {
  isLocked: Boolean!
  note: String!
  paidOn: Date!
  payment: Payment!
  receivedAmount: Money!
  receivedByBankOn: Date
  sequenceNo: String!
}

type PaymentLedgerSettings {
  warningThreshold: Decimal!
}

type PaymentList {
  items: [Payment!]!
  totalCount: Long!
}

type PaymentPermissions {
  canAcceptPaymentQuality: Boolean!
  canExportPayments: Boolean!
  canSignPayments: Boolean!
  canUsePaymentExportHistory: Boolean!
  canUsePaymentLedger: Boolean!
  canUsePaymentList: Boolean!
  canVoidApprovedPayments: Boolean!
  canVoidPaymentBatch: Boolean!
  canVoidPendingPayments: Boolean!
}

type PaymentSettings {
  paymentLedger: PaymentLedgerSettings!
}

type PaymentSignFailure {
  error: SignPaymentError!
  paymentId: Int!
}

type PaymentSignResultList {
  results: [SignPaymentResult!]!
}

type Permission {
  description: String!
  id: UUID!
  name: String!
}

"An error that occurs when the current user does not have the required permission to perform an action."
type PermissionDeniedError {
  permission: Permission
}

type PermissionGroup {
  id: Int!
  name: String!
  tags: [Tag!]!
}

type PhoneCall {
  "The phone number of the caller (incoming number)."
  callerPhoneNumber: String!
  "A list of claims with the caller number of this call on claimant's profile. If  is specified, only claims that match this term are returned."
  claims(term: String): SearchResults!
  "A list of clients with the caller number of this call on their profile. If  is specified, only clients that match this term are returned."
  clients(term: String): SearchResults!
  "The time at which the call was initiated."
  createdOn: DateTime!
  "The display mode of the phone call when it's being discovered by the application."
  displayMode: PhoneCallDisplayMode!
  "A list of external policies with the caller number of this call on their profile"
  externalPolicies: [ExternalPolicySearchResult!]!
  "Indicates whether the call has ended."
  hasEnded: Boolean!
  "The NIS id of the phone call, in the format of a GUID string."
  id: String!
  "Indicates whether the call is ongoing. The phone call becomes active when it's answered, and becomes inactive when it's ended."
  isActive: Boolean!
  "Indicates whether the phone call has been handled in one of the application instances; typically means that a dashboard has been opened and was focused by a user."
  isHandled: Boolean!
  "If this URL is provided it will be the recipient of a POST request, when PhoneNote communications are created based on this call.\nThe post request contains the ids of the notes that were created in a JSON object. Example:\n\n{\n   \"callId\" : 456879767,\n   \"communicationIds\" : [\n            34,\n            35\n       ]\n}"
  noteUrl: String!
  "A list of organisations linked to the phone call. This can be used for restricting the organisations on which claims can be created from this phone call."
  organisationCodes: [String!]!
  "A list of policies with the caller number of this call on one or more insureds' profile. If  is specified, only policies that match this term are returned."
  policies(term: String): SearchResults!
  "A list of products linked to the phone call. This can be used for restricting the products on which claims can be created from this phone call."
  productCodes: [String!]!
  "A list of providers with the caller number of this call on their profile. If  is specified, only providers that match this term are returned."
  providers(term: String): SearchResults!
  "The the recipient number, i.e. the number being called in the phone system."
  recipientPhoneNumber: String!
}

type PhoneCallSettings {
  "Specifies whether the phone call functionality is enabled."
  enabled: Boolean!
  "Specifies whether the phone call functionality should open links into a new window."
  openLinksInNewWindow: Boolean!
  "Specifies the interval in milliseconds between the frontend polling for new incoming calls."
  pollingInterval: Int!
}

type PinnableObjectList {
  items: [PinnableObject!]!
  totalCount: Long!
}

type PoliciesCollection {
  policies: [Policy!]!
}

type Policy implements SearchableEntity {
  "Finds an active policy situation that covers a given date."
  activeSituationOnDate(date: Date!): PolicySituation
  activeSituations: [PolicySituation!]!
  availableCommunicationParticipants: [CommunicationParticipant!]!
  availableCommunicationTemplates: [CommunicationTemplate!]!
  balance(date: DateTime): Money!
  claims(filters: ClaimListFiltersInput order: ClaimOrderInput = { by: CREATED, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): ClaimList!
  commission: [CommissionEntry!]!
  communications(filters: CommunicationListFiltersInput order: CommunicationOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): CommunicationList!
  currencyCode: String!
  "Retrieves the policy situation active today. Or the last active situation if the policy doesn't cover today."
  currentActiveSituation: PolicySituation!
  customFields: CustomFieldContext!
  displayNumber: String!
  firstActiveSituation: PolicySituation!
  id: Int!
  isCancelled: Boolean!
  isPinned: Boolean!
  isQuote: Boolean!
  isVoided: Boolean!
  lastActiveSituation: PolicySituation!
  number: Int!
  period: DateRange!
  segments: [Segment!]!
  situation(id: Int!): PolicySituation
  situations: [PolicySituation!]!
  tasks(filters: TaskListFiltersInput order: TaskOrderInput = { by: COMPLETED, direction: null, then: { by: DATE, direction: null, then: null } } pagination: OptionalPaginationInput): TaskList!
}

type PolicyClause {
  actorHits: [Decimal!]!
  amount: Decimal!
  category: ClauseCategory
  condition: DiagnosisGroup
  description: String!
  id: Int!
  isAppliedOnGross: Boolean!
  isConditionExcluded: Boolean!
  isIndexable: Boolean!
  isPartOfRenewal: Boolean!
  isShownOnPolicyPrint: Boolean!
  number: Int!
  percentage: Decimal!
  policy: PolicySituation!
  risk: ClauseRiskLevel!
  title: String!
}

type PolicyClientSearchModel {
  dateOfBirth: Date
  emails: [String!]
  id: Int!
  isVip: Boolean!
  name: String!
  phoneNumbers: [String!]
}

type PolicyCoverage {
  calculationResults: [ProductValue!]!
  "The calculations available in the product structure specifically for the product node associated with this coverage.\nThe same can be accomplished by looking up the matching element in the structure. This is a shortcut."
  calculations(language: String): [ProductCalculation!]!
  clauses: [PolicyClause!]!
  coverAmount: Decimal!
  description: String!
  id: Int!
  insured: PolicyInsured!
  limitations: [Limitation!]!
  parentId: Int!
  parents: [PolicyCoverage!]!
  product: Product!
  "The properties available in the product structure specifically for the product node associated with this coverage.\nThe same can be accomplished by looking up the matching element in the structure. This is a shortcut."
  properties(language: String): [ProductProperty!]!
  propertyValues: [ProductValue!]!
}

type PolicyInsured {
  calculatedAge: Int!
  calculationResults: [ProductValue!]!
  coverages: [PolicyCoverage!]!
  id: Int!
  isItem: Boolean!
  limitations(calculateOn: DateTime): [Limitation!]!
  name: String!
  object: InsurableObject
  propertyValues: [ProductValue!]!
  selectedElements: [String!]!
  uid: UUID!
}

type PolicyList {
  items: [Policy!]!
  totalCount: Long!
}

type PolicyPayment implements Payment {
  activities: [PaymentActivity!]!
  amount: Money!
  bankAccountName: String!
  bankAccountNo: String!
  bankAddress: Address
  bankBranch: String!
  bankControlKey: String!
  bankIban: String!
  bankName: String!
  bankSwift: String!
  createdBy: User!
  createdOn: DateTime!
  definition: PaymentDefinition
  department: Department
  direction: PaymentDirection!
  exchangeRate: Decimal!
  finalSignatureOn: Date
  id: Int!
  moneyAccount: MoneyAccount
  paidOn: Date!
  payInCurrencyCode: String!
  policy: GetPolicyResult
  receivedByBankOn: Date
  receiverNote: String!
  recipientAddress: Address
  recipientName: String!
  remark: String!
  sequenceNo: String!
  signatureCount: Int!
  status: PaymentStatus!
  systemAmount: Money!
}

type PolicyPaymentInformation {
  schedule: [PaymentInstalment!]!
}

type PolicySearchModel implements SearchModel {
  clients: [PolicyClientSearchModel!]!
  commonReferences: [String!]
  contractNumbers: [Int!]
  coverage: DateRange!
  externalReferences: [String!]
  formattedNumber: String
  id: String!
  internalReferences: [String!]
  isActive: Boolean!
  isCancelled: Boolean!
  isQuote: Boolean!
  isVoided: Boolean!
  issuedOn: Date!
  numbers: [Int!]!
  organisationIds: [Int!]!
  organisations: [Organisation!]!
  productCode: String!
}

type PolicySituation {
  balance: Decimal!
  commission: [CommissionEntry!]!
  commonReferenceNumber: String!
  coverages(insuredObjectUid: UUID): [PolicyCoverage!]!
  createdOn: DateTime!
  currencyCode: String!
  customFields: CustomFieldContext!
  externalReference: String!
  holder: Client!
  id: Int!
  insured: [PolicyInsured!]!
  internalReference: String!
  internalRemark: String!
  isActive: Boolean!
  isQuote: Boolean!
  isReplaced: Boolean!
  issuedOn: Date!
  organisation: Organisation!
  owner: Client
  period: DateRange!
  product: OrganisationProductRoot!
  remark: String!
  replacedBy: PolicySituation!
  specialConditions: String!
}

type Premium {
  adjustments: Money!
  gross: Money!
  tax: Money!
  total: Money!
}

type ProductAgreementGroup {
  agreements: [ProductAgreement!]!
  product: ProductRoot!
}

type ProductAgreementPermissions {
  canManageAgreements: Boolean!
}

type ProductAgreementRoot implements ProductAgreement {
  id: Int!
  isActive: Boolean!
  product: ProductRoot!
  validPeriod: DateRange!
}

type ProductCalculation implements ProductStructureNode & ProductStructureChildNode {
  "Specifies behaviors of the calculation. The behaviors can be used to instruct a UI how the calculation should be shown and behave."
  behaviors: [ProductCalculationBehavior!]!
  "A description of the node."
  description: String!
  "A key that uniquely identifies the node within the product structure."
  key: String!
  "The name of the node."
  name: String!
  "A value that indicates the order in which nodes should appear."
  orderingIndex: Int!
  "The key of the parent element."
  parentElementKey: String!
  "Specifies the type of the calculation result."
  type: ProductStructureValueType!
}

type ProductCoverage implements Product {
  "Indicates whether claims on policies using this product are allowed to generate financial transactions."
  allowsClaimTransactions: Boolean!
  availableAsSegmentCoverage: Boolean!
  calculations(language: String): [ProductCalculation!]!
  code: String!
  "Link to product description."
  conditionUrl: String!
  coverCauses: [CoverCause!]!
  displayName: String!
  id: Int!
  name: String!
  parentId: Int!
  properties(language: String): [ProductProperty!]!
}

type ProductElement implements ProductStructureNode {
  "Specifies behaviors of the element. The behaviors can be used to instruct a UI how the element should be shown and behave."
  behaviors: [ProductElementBehavior!]!
  "Specifies how children of this element can be selected.\n- `Free` - Typically, each child element would be shown as a checkbox.\n- `Single` - The child elements could be shown as a list of checkboxes where exactly one can be selected. A dropdown selection is another option.\n- `SingleOrNone` - Same behavior as `Single`, except either exactly one, or none of the elements can be selected."
  childSelectionMode: ProductElementChildSelectionMode!
  "A description of the node."
  description: String!
  "Specifies whether the element is selected per individual insured."
  isIndividual: Boolean!
  "Specifies whether the element is mandatory. Only applies when the parent element is selected."
  isMandatory: Boolean!
  "Specifies whether the element is selected by default when the parent element is selected."
  isSelectedByDefault: Boolean!
  "A key that uniquely identifies the node within the product structure."
  key: String!
  "The name of the node."
  name: String!
  "A value that indicates the order in which nodes should appear."
  orderingIndex: Int!
  "The key of the parent element. For the root element, this value will be `null`."
  parentElementKey: String
}

type ProductProperty implements ProductStructureNode & ProductStructureChildNode {
  "Specifies behaviors of the property. The behaviors can be used to instruct a UI how the property should be shown and behave."
  behaviors: [ProductPropertyBehavior!]!
  "Specifies the default value of the property, if any."
  defaultValue: ProductStructureValue
  "A description of the node."
  description: String!
  "Specifies whether the property is assigned per individual insured."
  isIndividual: Boolean!
  "A key that uniquely identifies the node within the product structure."
  key: String!
  "Specifies the maximum length of property value. Only applies to strings."
  maximumLength: Int
  "Specifies the maximum value of the property. Only applies to integers, floats and dates."
  maximumValue: ProductStructureValue
  "Specifies the minimum value of the property. Only applies to integers, floats and dates."
  minimumValue: ProductStructureValue
  "The name of the node."
  name: String!
  "Specifies a list of options to select from. When any option is defined, the property value must match the value of one of the options."
  options: [ProductPropertyOption!]!
  "A value that indicates the order in which nodes should appear."
  orderingIndex: Int!
  "The key of the parent element."
  parentElementKey: String!
  "Specifies the property value type."
  type: ProductStructureValueType!
}

type ProductPropertyOption {
  name: String!
  value: ProductStructureValue!
}

type ProductRoot implements Product & RootProduct {
  "Indicates whether claims on policies using this product are allowed to generate financial transactions."
  allowsClaimTransactions: Boolean!
  availableAsSegmentCoverage: Boolean!
  "Specifies various behaviors that indicate how the product is used."
  behaviors: [ProductBehavior!]!
  calculations(language: String): [ProductCalculation!]!
  code: String!
  "Link to product description."
  conditionUrl: String!
  coverCauses: [CoverCause!]!
  coverages: [ProductCoverage!]!
  currencies: [String!]!
  displayName: String!
  id: Int!
  name: String!
  properties(language: String): [ProductProperty!]!
  "Used for products with the `STRUCTURAL` behavior. This can be used to get the product structure which is used to show the customized product."
  structure("The language used for labels in the product structure. If the requested language is not provided by the product, the default language is used." language: String): ProductStructure
  validCoverPeriod: DateRange!
  version: String!
  versions: [ProductRoot!]!
}

type ProductStructure {
  "Specifies the calculations of the product. Each calculation belongs to an element.\nThe results of the calculations are what makes up most of the logic of a product, for example to calculate the premium of a policy.\nCalculations will be executed for each insured where the parent element is selected."
  calculations: [ProductCalculation!]!
  "A description of the product."
  description: String!
  "Contains various properties that specify how the product structure should be displayed."
  displayOptions: ProductStructureDisplayOptions!
  "Specifies the elements that make up the structure of the product. Elements are hierarchical, however they are returned in a flat list, for easy lookup.\nEach element (except for the root), points to the key of its parent. Elements cannot be selected unless their parent is selected."
  elements: [ProductElement!]!
  "The name of the product."
  name: String!
  "Specifies the properties of the product. Properties are values that can be assigned, and used in product logic and calculations.\nEach property belongs to an element. They can only be assigned when their parent element is selected."
  properties: [ProductProperty!]!
}

type ProductStructureDisplayOptions {
  "Indicates the orientation of the structure nodes."
  orientation: ProductStructureOrientation!
  "Indicates that the user should only be presented with nodes from the structure that are questions the user can answer."
  questionsOnly: Boolean!
}

type ProductValue {
  key: String!
  value: ProductStructureValue!
}

type ProductVisibilityGroup {
  id: Int!
  name: String!
  productCodes: [String!]!
}

type Provider implements SearchableEntity & BlacklistableEntity {
  address: Address
  bankAccounts: [BankAccount!]!
  "Provides blacklist information related to this entity."
  blacklisting: BlacklistingContext!
  claims(filters: ClaimListFiltersInput order: ClaimOrderInput = { by: CREATED, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): ClaimList!
  communications(filters: CommunicationListFiltersInput order: CommunicationOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): CommunicationList!
  contactDetails: [ContactDetail!]!
  contacts: [ProviderContact!]!
  costAgentBccEmails: [String!]!
  costAgentCcEmails: [String!]!
  currency: String!
  customFields: CustomFieldContext!
  defaultCostAgent: Provider
  defaultInvoiceLineSchema: PurchaseInvoiceLineSchema
  financialRating: Int!
  groups: [ProviderGroup!]!
  guarantees(filters: ClaimPaymentGuaranteeListFiltersInput order: ClaimPurchaseInvoiceOrPaymentGuaranteeOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput!): ClaimPaymentGuaranteeList!
  icon: ProviderIcon
  id: Int!
  invoiceBatchAutoCloseMethod: InvoiceBatchAutoCloseMethod
  invoiceBatchAutoCloseValue: Int
  invoiceBatches(claimId: Int!): [ClaimPurchaseInvoiceBatch!]!
  invoiceBatchingMethod: PurchaseInvoiceBatchingMethod!
  isActive: Boolean!
  isPractitioner: Boolean!
  isUsedAsManualPaymentProvider: Boolean!
  linkedProviders: [Provider!]!
  name: String!
  paymentDefinition: PaymentDefinition
  purchaseInvoices(filters: ClaimPurchaseInvoiceListFiltersInput order: ClaimPurchaseInvoiceOrPaymentGuaranteeOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): ClaimPurchaseInvoiceList!
  purchaseInvoicesAndGuarantees(filters: ClaimPurchaseInvoiceOrPaymentGuaranteeListFiltersInput order: ClaimPurchaseInvoiceOrPaymentGuaranteeOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput): ClaimPurchaseInvoiceOrPaymentGuaranteeList!
  qualityRating: Int!
  reference: String!
  remark: String!
  serviceRange: Int!
  services: [LinkedProviderService!]!
  vatId: String!
  vatPercentage: Decimal!
}

type ProviderContact {
  addresses: [ProviderContactAddress!]!
  bankAccounts: [BankAccount!]!
  contactDetails: [ContactDetail!]!
  firstName: String!
  id: Int!
  isActive: Boolean!
  lastName: String!
  "A name that represents a concatenation of the FirstName and LastName fields.\nThis field only exists for convenience, and does not provide any information that cannot be retrieved through the FirstName and LastName fields."
  name: String!
  remark: String!
  role: ClaimActorRole
  title: ClientTitle
}

type ProviderContactAddress implements Address {
  city: String
  coordinate: Coordinate
  country: Country!
  formattedAddress: String
  geoProviderType: GeoProviderType!
  id: Int!
  line1: String
  line2: String
  line3: String
  line4: String
  note: String
  placeId: String
  postalCode: String
  region: Region
  type: ProviderContactAddressType!
}

type ProviderGroup {
  id: Int!
  name: String!
}

type ProviderIcon {
  file: File!
  id: Int!
  name: String!
}

type ProviderList {
  items: [Provider!]!
  totalCount: Long!
}

type ProviderPermissions {
  canCreateProviders: Boolean!
  canEditProviderBankAccounts: Boolean!
  canEditProviders: Boolean!
  canManageProviders: Boolean!
}

type ProviderSearchModel implements SearchModel {
  address: AddressSearchModel!
  emails: [String!]
  financialRating: Int!
  groupIds: [Int!]
  groups: [ProviderGroup!]!
  id: String!
  isActive: Boolean!
  name: String!
  note: String
  phoneNumbers: [String!]
  qualityRating: Int!
  reference: String
  serviceAreas: [ProviderServiceAreaSearchModel!]
  serviceIds: [Int!]
  serviceRange: Int!
  services: [ProviderService!]!
}

type ProviderSearchResultMetadata {
  distance: Float
}

type ProviderService {
  id: Int!
  isCostAgentService: Boolean!
  name: String!
  parents: [ProviderService!]!
}

type ProviderServiceAreaSearchModel {
  country: String!
  financialRating: Int!
  id: Int!
  qualityRating: Int!
  region: String
}

type ProviderSettings {
  customNetworkUrl: String
}

"A configurable definition of which fields should be shown on invoice lines. This is primarily intended for use in the Nordic UI."
type PurchaseInvoiceLineSchema {
  "The fields that are hidden by the schema. Each field is referred to with a key known by the UI."
  fields: [String!]!
  id: Int!
  isActive: Boolean!
  "Specifies that the schema should be used by default on new invoices, unless a selected provider specifies otherwise."
  isDefault: Boolean!
  name: String!
}

type Query @authorize(apply: BEFORE_RESOLVER, policy: "authorized") {
  addressFromGooglePlace(geocodingResult: GoogleGeocodingResultInput!): MappedGooglePlaceResult!
  availableCommunicationParticipants(parentId: Int! parentType: CommunicationParentType!): [CommunicationParticipant!]!
  availableCommunicationTemplates(parentId: Int! parentType: CommunicationParentType!): [CommunicationTemplate!]!
  "Performs a blacklist lookup with the given criteria. This could for example be used to perform a blacklist lookup before a client has been saved."
  blacklistMatches(criteria: BlacklistMatchCriteriaInput!): [BlacklistMatchWithoutDecision!]!
  claim(id: Int!): GetClaimResult
  claimActorRoles: [ClaimActorRole!]!
  claimCollectiveInvoice(id: Int!): ClaimCollectiveInvoice
  claimCollectiveInvoices(order: ClaimCollectiveInvoiceOrderInput = { by: ID, direction: DESCENDING, then: null } pagination: PaginationInput): ClaimCollectiveInvoiceList!
  claimDenialReasons: [ClaimDenialReason!]!
  claimEvents: [ClaimEvent!]!
  claimFinancialServices: [ClaimFinancialService!]!
  claimPaymentGuarantees(filters: ClaimPaymentGuaranteeListFiltersInput order: ClaimPurchaseInvoiceOrPaymentGuaranteeOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: PaginationInput): ClaimPaymentGuaranteeList!
  claimPurchaseInvoiceBatch(id: Int!): GetClaimPurchaseInvoiceBatchResult
  claimPurchaseInvoiceBatches(filters: ClaimPurchaseInvoiceBatchListFiltersInput order: ClaimPurchaseInvoiceBatchOrderInput = { by: ID, direction: DESCENDING, then: null } pagination: PaginationInput): ClaimPurchaseInvoiceBatchList!
  claimPurchaseInvoiceDenialReasons: [ClaimPurchaseInvoiceDenialReason!]!
  claimPurchaseInvoiceLineDecisions: [ClaimPurchaseInvoiceLineDecision!]!
  claimPurchaseInvoiceLineExplanations: [ClaimPurchaseInvoiceLineExplanation!]!
  claimPurchaseInvoices(filters: ClaimPurchaseInvoiceListFiltersInput order: ClaimPurchaseInvoiceOrPaymentGuaranteeOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: PaginationInput): ClaimPurchaseInvoiceList!
  claimRecoveryTypes: [ClaimRecoveryType!]!
  claims(filters: ClaimListFiltersInput order: ClaimOrderInput = { by: CREATED, direction: DESCENDING, then: null } pagination: PaginationInput): ClaimList!
  client(id: Int!): GetClientResult
  clientTitles: [ClientTitle!]!
  clientsByExternalId(id: String!): [Client!]!
  communication(id: Int!): GetCommunicationResult
  "Querying Communication fields based on the referenced object and the provided field names.\nNOTE: This should not be used unless no other options is available. For external integration purpose it's recommended to query the fields over a communication token.\n\n\n**Returns:**\nAn instance of IGetCommunicationFieldsResult."
  communicationFields("The input determines the referenced object and field names to query." input: CommunicationFieldsInput!): GetCommunicationFieldsResult
  communicationTemplate(id: Int!): CommunicationTemplate
  communicationTemplates: [CommunicationTemplate!]!
  "Fetches a CommunicationToken from the given UID."
  communicationToken(uid: String!): CommunicationToken
  communications(filters: CommunicationListFiltersInput order: CommunicationOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: OptionalPaginationInput parentId: Int! parentType: CommunicationParentType!): CommunicationListResult!
  complaintCategories: [ComplaintCategory!]!
  complaintStates: [ComplaintState!]!
  complaintTypes: [ComplaintType!]!
  countries: [Country!]!
  coverCauses: [CoverCause!]!
  cultures: [Culture!]!
  currencies(fromCurrencyCode: String validOn: Date): [Currency!]!
  customDialog(id: Int!): CustomDialog
  customDialogs(filters: CustomDialogListFiltersInput order: CustomDialogOrderInput = { by: CREATE_DATE, direction: null, then: null } pagination: PaginationInput): CustomDialogList!
  customFieldGroups(ownerType: CustomFieldOwnerType!): [CustomFieldGroup!]!
  department(id: Int!): Department
  "Gets a department uniquely identified by the given code."
  departmentByCode(code: String!): Department
  departments: [Department!]!
  diagnoses(order: DiagnosisOrderInput pagination: PaginationInput): DiagnosisList!
  exchangeRate(fromCurrencyCode: String! onDate: DateTime toCurrencyCode: String!): ExchangeRate
  exchangeRates(filters: ExchangeRateListFiltersInput order: ExchangeRateOrderInput = { by: CREATED_ON, direction: DESCENDING, then: null } pagination: PaginationInput): ExchangeRateList!
  feeDefinition(id: Int!): GetFeeDefinitionResult
  feeTransaction(id: Int!): GetFeeTransactionResult
  identityProviders: [IdentityProvider!]!
  inboxType(code: String!): InboxType!
  inboxTypes: [InboxType!]!
  limitationTypes: [LimitationType!]!
  "Gets the currently logged in user."
  me: CurrentUser!
  "Gets a money account uniquely identified by the given code."
  moneyAccountByCode(code: String!): MoneyAccount
  moneyAccounts(type: MoneyAccountType): [MoneyAccount!]!
  organisation(id: Int!): Organisation
  "Gets an organisation uniquely identified by the given code."
  organisationByCode(code: String!): Organisation
  patientTypes: [PatientType!]!
  payment(id: Int!): Payment
  paymentDefinitions(departmentId: Int): [PaymentDefinition!]!
  paymentExport(id: Int!): PaymentExport
  paymentExportFormats: [PaymentExportFormat!]!
  paymentExports(order: PaymentExportOrderInput pagination: PaginationInput): PaymentExportList!
  paymentImportProviders: [PaymentImportProvider!]!
  payments(filters: PaymentListFiltersInput order: PaymentOrderInput pagination: PaginationInput): PaymentList!
  permissionGroups: [PermissionGroup!]!
  phases: [ClaimPhase!]!
  "Gets the PhoneCall with the given id."
  phoneCall(id: String!): PhoneCall!
  "Gets all PhoneCalls that targets the given userId."
  phoneCalls(userId: Int!): [PhoneCall!]!
  policy(id: Int!): GetPolicyResult
  "Gets product by a given product id."
  product(id: Int!): Product
  productVisibilityGroups: [ProductVisibilityGroup!]!
  provider(id: Int!): Provider
  providerGroups: [ProviderGroup!]!
  providerServices: [ProviderService!]!
  providers(filters: ProviderListFiltersInput order: ProviderOrderInput pagination: PaginationInput): ProviderList!
  purchaseInvoiceLineSchemas: [PurchaseInvoiceLineSchema!]!
  regions(countryId: String!): [Region!]!
  report(id: Int!): Report
  reportCategories: [ReportCategory!]!
  reserveTypes: [ReserveType!]!
  "Gets root product by id."
  rootProduct("Fetches root product by this id." id: Int!): ProductRoot
  "Gets root product by code and optionally version."
  rootProductByCode(code: String! version: String): ProductRoot
  "Gets the latest version of each root product."
  rootProducts: [ProductRoot!]!
  "Performs a search across one or more type of searchable entity using a simple search term. The results are sorted by relevance."
  search("Specifies whether search result highlight information should be returned. This will only apply if the underlying search provider supports it." highlight: Boolean "Specifies how results should be paginated." pagination: PaginationInput "Provides the ability to optionally pass in extra parameters that the search can use to further filter the results." parameters: [SearchParametersInput!] "The search term." term: String! "The type of entities to search for." types: [UUID!]): SearchResultUnion!
  searchSchemas: SearchSchemas!
  "Performs a search on a searchable entity using specific search parameters. The results are sorted by relevance."
  searchWithParameters("Specifies whether search result highlight information should be returned. This will only apply if the underlying search provider supports it." highlight: Boolean "Specifies how results should be paginated." pagination: PaginationInput "The parameter values to use in the search." parameters: [SearchParameterAssignmentInput!]! "The type of entity to search." type: UUID!): SearchResultUnion!
  segment(id: Int!): Segment!
  segmentType(id: Int!): SegmentType!
  segmentTypes: [SegmentType!]!
  settings: SettingsAggregation!
  systemUser: User!
  tags(availability: TagAvailability): [Tag!]!
  task(id: Int!): GetTaskResult
  taskCategories(ownerType: TaskOwnerType systemType: TaskSystemType): [TaskCategory!]!
  taskDefinition(id: Int!): TaskDefinition
  "Gets a task definition uniquely identified by the given code."
  taskDefinitionByCode(code: String!): TaskDefinition
  taskDefinitions(ownerType: TaskOwnerType! systemType: TaskSystemType): [TaskDefinition!]!
  tasks(filters: TaskListFiltersInput order: TaskOrderInput = { by: COMPLETED, direction: null, then: { by: DATE, direction: null, then: null } } pagination: PaginationInput): TaskList!
  teams(order: TeamOrderInput = { by: NAME, direction: null, then: null } pagination: OptionalPaginationInput): TeamList!
  unassignedFile(id: String!): UnassignedFile!
  unassignedFiles(filters: UnassignedFileListFiltersInput order: UnassignedFileOrderInput = { by: CREATE_DATE, direction: DESCENDING, then: null } pagination: PaginationInput): UnassignedFileList!
  user(id: Int!): User
  users(order: UserOrderInput = { by: NAME, direction: null, then: null } pagination: PaginationInput): UserList!
  vatGroups: [VatGroup!]!
  webHookEvents: WebHookEventsResult!
  webHookListener(id: Int!): WebHookListenerResult
  webHookListeners: WebHookListenersResult!
}

type QuestionnaireBooleanQuestion implements QuestionnaireQuestion {
  key: String!
  name: String!
  text: String!
}

type QuestionnaireChoiceOption {
  key: String!
  text: String!
}

type QuestionnaireChoiceQuestion implements QuestionnaireQuestion {
  canSelectMultiple: Boolean!
  isRequired: Boolean!
  key: String!
  name: String!
  options: [QuestionnaireChoiceOption!]!
  text: String!
}

type QuestionnaireDateTimeQuestion implements QuestionnaireQuestion {
  isRequired: Boolean!
  key: String!
  name: String!
  text: String!
  useTime: Boolean!
}

type QuestionnaireDefinition {
  id: Int!
  language: String
  sections: [QuestionnaireSection!]!
  title: String!
}

type QuestionnaireHeaderElement {
  text: String!
}

type QuestionnaireNoteElement {
  text: String!
}

type QuestionnaireSection {
  description: String!
  elements: [QuestionnaireElement!]!
  footer: String!
  key: String!
  title: String!
}

type QuestionnaireSeparatorElement {
  visible: Boolean!
}

"A stalemate error that relates to questionnaires.\nA set of answers to one or more questionnaires given was not able to be applied, because the questionnaire(s) are not available."
type QuestionnaireStalemateError implements StalemateError {
  "Specifies the index of which calculation being performed this error applies to."
  calculationIndex: Int!
  "Specifies the index of the insured within the calculation this error applies to, if any."
  insuredIndex: Int
  "The identifiers of the questionnaire definitions where answers could not be applied."
  questionnaires: [Int!]!
}

type QuestionnaireTextQuestion implements QuestionnaireQuestion {
  key: String!
  maxLength: Int
  minLength: Int
  name: String!
  text: String!
}

type RecentlyViewedObjectList {
  items: [RecentlyViewedObject!]!
  totalCount: Long!
}

type Region {
  id: String!
  name: String!
}

type RemovedCustomBlacklistEntriesResponse {
  removedEntryIds: [String!]!
}

type Report {
  externalUrl: String!
  id: Int!
  outputFormat: ReportOutputFormat!
  title: String!
}

type ReportCategory {
  id: Int!
  reports: [Report!]!
  title: String!
}

type ReportPermissions {
  canManageReports: Boolean!
}

type ReserveType {
  code: String!
  id: Int!
  isActive: Boolean!
  name: String!
}

type SearchParameterDisplayOptions {
  hints: [String!]!
}

type SearchParameterGroup {
  collapsedDefault: Boolean!
  collapsible: Boolean!
  key: String!
  name: String!
}

type SearchParameters {
  fields: [SearchParameter!]!
  groups: [SearchParameterGroup!]!
}

type SearchResult {
  "The matched entity fetched from the database. When possible, try to use `model` instead of this. It is potentially faster due to the need for fewer database calls."
  entity: SearchableEntity!
  highlights: [SearchResultHighlight!]!
  id: String!
  "Metadata associated with the result. If the search provider did not provide any, this will have no value."
  metadata: SearchResultMetadata
  "The search model returned directly from the search index. Using this rather than `entity` can potentially be faster."
  model: SearchModel!
  score: Float
}

type SearchResultHighlight {
  field: String!
  values: [String!]!
}

type SearchResults {
  items: [SearchResult!]!
  "The highest score in the result. If the underlying search provider doesn't support scoring, this will have no value."
  maxScore: Float
  "The total number of search results."
  totalCount: Long!
}

type SearchSchema {
  id: UUID!
  name: String!
  parameters(language: String): SearchParameters!
  supportsParameterizedSearch: Boolean!
  supportsTermSearch: Boolean!
}

type SearchSchemas {
  all: [SearchSchema!]!
  claim: SearchSchema!
  client: SearchSchema!
  diagnosis: SearchSchema!
  external: [SearchSchema!]!
  organisation: SearchSchema!
  policy: SearchSchema!
  provider: SearchSchema!
  user: SearchSchema!
}

type Segment {
  client: Client
  createDate: DateTime!
  createdBy: User!
  description: String
  id: Int!
  isActive: Boolean!
  isInUse: Boolean!
  name: String!
  originClaim: Claim!
  policy: Policy!
  policyCoverage: PolicyCoverage
  type: SegmentType!
  usedOnClaims: [Claim]
}

type SegmentType {
  createDate: DateTime!
  createdBy: User!
  id: Int!
  isActive: Boolean!
  name: String!
}

type SelectionSearchParameter implements SearchParameter {
  canSelectMultiple: Boolean!
  display: SearchParameterDisplayOptions
  group: String
  isHidden: Boolean!
  isRequired: Boolean!
  key: String!
  name: String!
  options: [SelectionSearchParameterOption!]!
}

type SettingsAggregation {
  "Settings related to application"
  application: ApplicationSettings!
  "Settings related to blacklist functionality."
  blacklist: BlacklistSettings!
  "Settings related to cases."
  case: CaseSettings!
  "Settings related to claim invoice functionality."
  claimInvoice: ClaimInvoiceSettings!
  "Settings related to clients."
  client: ClientSettings!
  "Settings related to communications."
  communication: CommunicationSettings!
  "Settings related to the application environment."
  environment: EnvironmentSettings!
  "Settings related to usage of the Google APIs."
  google: GoogleSettings!
  "Settings related to locations and maps."
  location: LocationSettings!
  "Settings related to organisations."
  organisation: OrganisationSettings!
  "Settings related to payments."
  payment: PaymentSettings!
  "Settings related to the incoming phone call functionality."
  phoneCall: PhoneCallSettings!
  "Settings related to providers and the provider network."
  provider: ProviderSettings!
  "Settings related to unassigned files."
  unassignedFile: UnassignedFileSettings!
  "Settings related to users."
  user: UserSettings!
}

type SignaturePasswordMustBeDifferentFromLoginError {
  message: String!
}

type SignaturePasswordMustBeDifferentFromOldError {
  message: String!
}

type StatusChangeNotAllowedError {
  reasons: [String!]!
}

type StringProductStructureValue {
  value: String!
}

type StringSearchParameter implements SearchParameter {
  display: SearchParameterDisplayOptions
  group: String
  isHidden: Boolean!
  isRequired: Boolean!
  key: String!
  name: String!
}

type StringSelectionSearchParameterOption implements SelectionSearchParameterOption {
  label: String!
  value: String!
}

"A stalemate error that relates to the structure of the product.\nOne or more of the elements selections or property values given could not be applied.\nWhich happens because either the parent of an element was not selected, or the element the property belongs to was not selected."
type StructureStalemateError implements StalemateError {
  calculationIndex: Int!
  elements: [String!]!
  insuredIndex: Int
  properties: [String!]!
}

type Tag {
  id: Int!
  name: String!
}

type TagPermissions {
  canCreate: Boolean!
}

type Task {
  assignee: User!
  availableTags: [Tag!]!
  category: TaskCategory
  completedBy: User
  completedOn: DateTime
  createdBy: User!
  createdOn: DateTime!
  definition: TaskDefinition!
  description: String!
  dueOn: DateTime!
  id: Int!
  isCompleted: Boolean!
  isVoidable: Boolean!
  isVoided: Boolean!
  organisation: Organisation!
  outcome: TaskOutcome
  parent: TaskParent
  priority: TaskPriority
  questionnaire: GenericQuestionnaire
  relatedEntity: TaskRelatedEntity
  remark: String!
  tags: [Tag!]!
  title: String!
}

type TaskCategory {
  code: String!
  id: Int!
  isActive: Boolean!
  name: String!
}

type TaskConfigurationError {
  message: String!
}

type TaskDefinition {
  areCompletedTasksVoidable: Boolean!
  canBeCompletedByCurrentUser: Boolean!
  category: TaskCategory
  "A code that can be used to uniquely identify this task definition."
  code: String!
  duration: Decimal!
  id: Int!
  "If true this definition will be picked up by the automated task job and executed with the parameter values of the configured activity."
  isActivity: Boolean!
  isTaskActive: Boolean!
  "Locks given aspects of tasks created from this definition from being edited by a user."
  locks: [TaskDefinitionLock!]!
  name: String!
  outcomes: [TaskOutcome!]!
  "The parent type this definition appears under."
  ownerType: TaskOwnerType
  priority: TaskPriority
  questionnaire(language: String): QuestionnaireDefinition
  "Which secondary parent type should this definition appear under."
  secondaryOwnerType: TaskOwnerType
  selectableOutcomes: [TaskOutcome!]!
  "The type of usage this task definition is meant for."
  systemType: TaskSystemType
  "The default tags of tasks created from this definition."
  tags: [Tag!]!
  "The default description of tasks created from this definition."
  taskDescription: String!
  "The default title of tasks created from this definition."
  taskTitle: String!
}

type TaskList {
  items: [Task!]!
  totalCount: Long!
}

type TaskOutcome {
  id: Int!
  isActive: Boolean!
  name: String!
  shortName: String!
  systemBehaviour: TaskOutcomeSystemBehaviour
}

type TaskOutcomeNotFoundError {
  outcomeShortNames: [String!]!
}

type TaskPermissions {
  canCreateAndEdit: Boolean!
}

type Team {
  canBeRemoved: Boolean!
  id: Int!
  name: String!
  tasks(filters: TaskListFiltersInput order: TaskOrderInput = { by: COMPLETED, direction: null, then: { by: DATE, direction: null, then: null } } pagination: PaginationInput): TaskList!
}

type TeamList {
  items: [Team!]!
  totalCount: Long!
}

type TemporaryFile {
  id: String!
  name: String!
}

type TextMessageCommunication implements Communication {
  "The plain text content of the communication. If the communication consists of a binary file, this field should still consist of a textual representation of that content\nin order to aid with search."
  content: String!
  "The HTML formatted content of the communication."
  contentFormatted: String!
  "The NIS user that created the communication."
  createdBy: User!
  "The time this communication was first saved to storage."
  createdOn: DateTime!
  id: Int!
  isVoided: Boolean!
  "The purchase invoice or payment guarantee connected to the communication."
  purchaseInvoiceOrGuarantee: ClaimPurchaseInvoiceOrPaymentGuarantee
  "The recipient chosen for this communication."
  recipient: CommunicationActor
  "The sender chosen for this communication."
  sender: CommunicationActor
  subject: String!
  "The tags connected to the communication."
  tags: [Tag!]!
  "The template this communication was created from."
  template: CommunicationTemplate
}

type TextQuestionnaireAnswer implements QuestionnaireAnswer {
  questionId: String!
  value: String!
}

type UnassignedFile {
  createdBy: User!
  createdOn: DateTime!
  currentUsers: [User!]!
  description: String
  filename: String
  id: String!
  tags: [String!]!
  title: String
  type: InboxType
}

type UnassignedFileList {
  items: [UnassignedFile!]!
  totalCount: Long!
}

type UnassignedFilePermissions {
  canManageUnassignedFiles: Boolean!
}

type UnassignedFileSettings {
  maxFileSizeInBytes: Int
  "Indicates if we should default to create a task when updating unassigned file actions"
  shouldCreateTaskPerDefault: Boolean
}

type User implements SearchableEntity {
  availableDepartments: [Department!]!
  availableOrganisations(departmentId: Int): [Organisation!]!
  canBeDeactivated: Boolean!
  coverLevel: Int!
  createdOn: DateTime!
  defaultDepartment: Department
  email: String!
  hasSignaturePassword: Boolean!
  id: Int!
  isActive: Boolean!
  isLocked: Boolean!
  isPasswordValid(password: String!): PasswordValidationCode!
  jobTitle: String!
  lastLogin: DateTime
  maxAuthorizedPayment: Money!
  maxAuthorizedPaymentType: MaxAuthorizedPaymentType!
  maxGuarantee: Money!
  maxReservation: Money!
  maxSelfSign: Money!
  mustChangePassword: Boolean!
  name: String!
  organisation: Organisation
  passwordNeverExpires: Boolean!
  permissionGroups: [PermissionGroup!]!
  personalAccessTokens: GetUserPersonalAccessTokensResult!
  phone: String!
  productVisibilityGroups: [ProductVisibilityGroup!]!
  team: Team
  useProductVisibilityGroups: Boolean!
  username: String!
  visibilityLimit: VisibilityLimitMode!
}

type UserList {
  items: [User!]!
  totalCount: Long!
}

type UserPermissionAggregation {
  blacklisting: BlacklistPermissions!
  claims: ClaimPermissions!
  clients: ClientPermissions!
  communications: CommunicationPermissions!
  customDialogs: CustomDialogPermissions!
  finance: FinancePermissions!
  identityProviders: IdentityProviderPermissions!
  organisations: OrganisationPermissions!
  payments: PaymentPermissions!
  productAgreements: ProductAgreementPermissions!
  providers: ProviderPermissions!
  reports: ReportPermissions!
  tags: TagPermissions!
  tasks: TaskPermissions!
  unassignedFile: UnassignedFilePermissions!
  users: UserPermissions!
}

type UserPermissions {
  canManageUsers: Boolean!
}

type UserPersonalAccessToken {
  createdBy: User!
  createdOn: DateTime!
  expiresOn: DateTime
  id: Int!
  isRevoked: Boolean!
  name: String!
  revokedBy: User
  revokedOn: DateTime
}

type UserPersonalAccessTokenList {
  tokens: [UserPersonalAccessToken!]!
}

type UserSearchModel implements SearchModel {
  email: String!
  id: String!
  name: String!
  organisationId: Int!
  username: String!
}

type UserSettings {
  maxAuthorityLevel: Int!
}

"An error that occurs when the given input is invalid."
type ValidationError {
  fields: [ValidationErrorField!]!
}

type ValidationErrorField {
  errors: [String!]!
  field: String!
}

type VatGroup {
  autoCalculateVat: Boolean!
  canBeRemoved: Boolean!
  code: String!
  id: Int!
  name: String!
  nominalAccount: MoneyAccount
  percentage: Decimal!
}

type VoidClaimPurchaseInvoiceBatchesResultList {
  results: [VoidClaimPurchaseInvoiceBatchResult!]!
}

type WebHookEvent {
  description(language: String): String!
  id: String!
  name(language: String): String!
}

type WebHookEventList {
  events: [WebHookEvent!]!
}

type WebHookListener {
  "Specifies whether the SSL certificate should be verified."
  enableSslVerification: Boolean!
  "The events this listener is listening to."
  events: [WebHookEvent!]!
  "The name of an HTTP header that can optionally be sent to the listener on each request."
  headerName: String
  "The value of an HTTP header that can optionally be sent to the listener on each request."
  headerValue: String
  id: Int!
  "The timeout of requests made to the listener in seconds."
  timeout: Int!
  url: String!
}

type WebHookListenerList {
  listeners: [WebHookListener!]!
}

union AddToCustomBlacklistResult = AddedCustomBlacklistEntriesResponse | PermissionDeniedError

union ApproveClaimPurchaseInvoiceResult = AccessDeniedError | PermissionDeniedError | BlacklistMatchError | ValidationError | ClaimPurchaseInvoice

union CancelClaimPaymentGuaranteeResult = AccessDeniedError | PermissionDeniedError | ClaimPaymentGuarantee

union CancelClaimPurchaseInvoiceResult = AccessDeniedError | PermissionDeniedError | ClaimPurchaseInvoice

union ClaimAccountEntryOrigin = ClaimRecovery | ClaimPurchaseInvoice | ClaimPaymentGuarantee

union ClaimPurchaseInvoiceOrPaymentGuarantee = ClaimPurchaseInvoice | ClaimPaymentGuarantee

union ClaimPurchaseInvoicePayee = ClientCompany | ClientPerson | ClaimCompanyContact | ClaimOrganisationContact | ClaimPersonContact | ClaimProviderContact

union CloseClaimPurchaseInvoiceBatchResult = ClaimPayment | CannotCloseClaimPurchaseInvoiceBatchError

union CloseClaimPurchaseInvoiceBatchesResult = CloseClaimPurchaseInvoiceBatchesResultList | PermissionDeniedError

union CommunicationActionResult = EmailCommunication | FaxCommunication | FileCommunication | LetterCommunication | NoteCommunication | TextMessageCommunication | AccessDeniedError | PermissionDeniedError | ValidationError

union CommunicationActor = Provider | ClientCompany | ClientPerson | ClaimCompanyContact | ClaimOrganisationContact | ClaimPersonContact | ClaimProviderContact | User | CurrentUser | Organisation | Department | ProviderContact

union CommunicationListResult = AccessDeniedError | CommunicationList

union ConvertMonetaryAmountResult = ExchangeRateNotFoundError | MonetaryConversionResult

union CreateClaimCollectiveInvoiceResult = ClaimCollectiveInvoice | PermissionDeniedError | FileNotFoundError | BusinessRuleError | ValidationError

union CreateClaimEventResult = PermissionDeniedError | ValidationError | ClaimEvent

union CreateClaimFinancialServiceResult = PermissionDeniedError | ValidationError | ClaimFinancialService

union CreateClaimPurchaseInvoiceLineDecisionResult = ValidationError | ClaimPurchaseInvoiceLineDecision

union CreateClaimPurchaseInvoiceLineExplanationResult = ValidationError | ClaimPurchaseInvoiceLineExplanation

union CreateClaimResult = Claim | PermissionDeniedError | BusinessRuleError | ValidationError

union CreateCompanyClientResult = ClientCompany | PermissionDeniedError | BusinessRuleError | ValidationError

union CreateCustomDialogResult = PermissionDeniedError | ValidationError | CustomDialog

union CreateExchangeRateResult = PermissionDeniedError | ValidationError | ExchangeRate

union CreateIdentityProviderResult = PermissionDeniedError | ValidationError | IdentityProvider

union CreateInboxTypeResult = ValidationError | InboxType

union CreateMoneyAccountResult = PermissionDeniedError | ValidationError | MoneyAccount

union CreateOrganisationResult = AccessDeniedError | PermissionDeniedError | ValidationError | Organisation

union CreatePersonClientResult = ClientPerson | PermissionDeniedError | BusinessRuleError | ValidationError

union CreatePoliciesResult = ValidationError | PoliciesCollection | CalculationStalemateError | InvalidCalculationError

union CreatePolicyError = CreatePolicyFromExternalPolicyError

union CreatePolicyFromExternalPolicyResult = CreateExternalPolicyFailure | CreateExternalPolicyResult | CreatePolicyFromExternalPolicyError

union CreateProviderResult = Provider | PermissionDeniedError | ValidationError

union CreateQuotesResult = ValidationError | PoliciesCollection | CalculationStalemateError | InvalidCalculationError

union CreateSegmentTypeResult = SegmentType | ValidationError

union CreateTaskResult = AccessDeniedError | PermissionDeniedError | ValidationError | Task

union CreateTeamResult = PermissionDeniedError | ValidationError | Team

union CreateUserPersonalAccessTokenResult = CreatedUserPersonalAccessToken | PermissionDeniedError

union CreateUserResult = PermissionDeniedError | ValidationError | User | CurrentUser

union CreateVatGroupResult = PermissionDeniedError | ValidationError | VatGroup

union CreateWebHookListenerResult = WebHookListener | PermissionDeniedError | ValidationError

union ExportPaymentsResult = PaymentExport | PermissionDeniedError | ValidationError

union GenerateDocumentResult = TemporaryFile | AccessDeniedError

union GeneratePaymentExportFileResult = TemporaryFile | PermissionDeniedError

union GetClaimPurchaseInvoiceBatchResult = AccessDeniedError | ClaimPurchaseInvoiceBatch

union GetClaimResult = Claim | AccessDeniedError

union GetClientResult = ClientCompany | ClientPerson | AccessDeniedError

union GetCommunicationFieldsResult = CommunicationFieldsResult | AccessDeniedError

union GetCommunicationResult = EmailCommunication | FaxCommunication | FileCommunication | LetterCommunication | NoteCommunication | TextMessageCommunication | AccessDeniedError

union GetFeeDefinitionResult = PermissionDeniedError | ClaimFeeDefinition

union GetFeeTransactionResult = PermissionDeniedError | ClaimFeeTransaction

union GetPolicyResult = Policy | AccessDeniedError

union GetTaskResult = AccessDeniedError | Task

union GetUserPersonalAccessTokensResult = UserPersonalAccessTokenList | PermissionDeniedError

union ImportPaymentsResult = ImportPaymentsResultList | InvalidPaymentImportFileError | PermissionDeniedError | FileNotFoundError | ValidationError

union InsurableObject = ClientCompany | ClientPerson

"Represents the value of a limitation. This value can be either an amount with a currency, a percentage, or a count."
union LimitationValue = LimitationAmount | LimitationCount | LimitationPercentage

union PaymentActionResult = ClaimPayment | PolicyPayment | PaymentCommitFailure | AccessDeniedError

union PaymentActionsResult = PasswordIncorrectError | PaymentActionsResultList | PermissionDeniedError | ValidationError

union PaymentCommitError = CannotPerformPaymentActionError | AccessDeniedError

union PhoneCallResult = PhoneCall | ValidationError

union PinnableObject = Policy | ClientCompany | ClientPerson | Claim

union ProductStructureValue = BooleanProductStructureValue | DateProductStructureValue | FloatProductStructureValue | IntegerProductStructureValue | StringProductStructureValue

union ProductVisibilityGroupResult = ProductVisibilityGroup | PermissionDeniedError | ValidationError

union QuestionnaireElement = QuestionnaireHeaderElement | QuestionnaireNoteElement | QuestionnaireSeparatorElement | QuestionnaireBooleanQuestion | QuestionnaireChoiceQuestion | QuestionnaireDateTimeQuestion | QuestionnaireTextQuestion

union QuestionnaireEvaluationResult = GenericQuestionnaire | ValidationError

union QuotesCalculationResult = ValidationError | AggregateCalculationResult | CalculationStalemateError

union RecentlyViewedObject = Policy | EmailCommunication | FaxCommunication | FileCommunication | LetterCommunication | NoteCommunication | TextMessageCommunication | ClientCompany | ClientPerson | Claim | Task | ClaimRecovery | ClaimPurchaseInvoice | ClaimPaymentGuarantee

union RefundClaimPurchaseInvoiceResult = AccessDeniedError | PermissionDeniedError | ValidationError | ClaimPurchaseInvoice

union RemoveClaimPurchaseInvoiceLineDecisionResult = EntityRemovalResult | ValidationError

union RemoveClaimPurchaseInvoiceLineExplanationResult = EntityRemovalResult | ValidationError

union RemoveCustomDialogResult = PermissionDeniedError | ValidationError | CustomDialog

union RemoveFromCustomBlacklistResult = RemovedCustomBlacklistEntriesResponse | PermissionDeniedError

union RemoveIdentityProviderResult = PermissionDeniedError | IdentityProvider

union RemoveMoneyAccountResult = EntityRemovalResult | PermissionDeniedError | ValidationError

union RemoveProductVisibilityGroupResult = EntityRemovalResult | PermissionDeniedError | ValidationError

union RemoveTeamResult = EntityRemovalResult | ValidationError

union RemoveVatGroupResult = EntityRemovalResult | PermissionDeniedError | ValidationError

union RemoveWebHookListenerResult = EntityRemovalResult | PermissionDeniedError

union RevokeUserPersonalAccessTokenResult = PermissionDeniedError | UserPersonalAccessToken

union SearchResultMetadata = ProviderSearchResultMetadata

union SearchResultUnion = SearchResults | ValidationError

union SettleClaimPaymentGuaranteeResult = AccessDeniedError | PermissionDeniedError | ClaimPaymentGuarantee

union SignPaymentError = CannotPerformPaymentActionError | AccessDeniedError | BlacklistMatchError

union SignPaymentResult = ClaimPayment | PolicyPayment | PaymentSignFailure | AccessDeniedError

union SignPaymentsResult = PasswordIncorrectError | PaymentSignResultList | PermissionDeniedError | ValidationError

union TaskParent = Policy | ClientCompany | ClientPerson | Claim | Organisation

union TaskRelatedEntity = EmailCommunication | FaxCommunication | FileCommunication | LetterCommunication | NoteCommunication | TextMessageCommunication | ClaimPurchaseInvoice | ClaimPaymentGuarantee

union UnassignedFileResult = PermissionDeniedError | ValidationError | UnassignedFile

union UpdateClaimCollectiveInvoiceResult = ClaimCollectiveInvoice | PermissionDeniedError | FileNotFoundError | BusinessRuleError | ValidationError

union UpdateClaimContactResult = ClaimCompanyContact | ClaimOrganisationContact | ClaimPersonContact | ClaimProviderContact | AccessDeniedError | PermissionDeniedError

union UpdateClaimEventResult = PermissionDeniedError | ValidationError | ClaimEvent

union UpdateClaimFinancialServiceResult = PermissionDeniedError | ValidationError | ClaimFinancialService

union UpdateClaimPurchaseInvoiceBatchResult = PermissionDeniedError | ValidationError | ClaimPurchaseInvoiceBatch

union UpdateClaimPurchaseInvoiceLineDecisionResult = ValidationError | ClaimPurchaseInvoiceLineDecision

union UpdateClaimPurchaseInvoiceLineExplanationResult = ValidationError | ClaimPurchaseInvoiceLineExplanation

union UpdateClaimResult = Claim | AccessDeniedError | PermissionDeniedError | BlacklistMatchError | BusinessRuleError | ValidationError

union UpdateClaimStatusResult = StatusChangeNotAllowedError | Claim | AccessDeniedError | PermissionDeniedError | BusinessRuleError | ValidationError

union UpdateClientResult = ClientCompany | ClientPerson | AccessDeniedError | PermissionDeniedError | BusinessRuleError | ValidationError

union UpdateCompanyClientResult = ClientCompany | AccessDeniedError | PermissionDeniedError | BusinessRuleError | ValidationError

union UpdateCustomDialogResult = PermissionDeniedError | ValidationError | CustomDialog

union UpdateIdentityProviderResult = PermissionDeniedError | ValidationError | IdentityProvider

union UpdateInboxTypeResult = ValidationError | InboxType

union UpdateMoneyAccountResult = PermissionDeniedError | ValidationError | MoneyAccount

union UpdateOrganisationResult = AccessDeniedError | PermissionDeniedError | ValidationError | Organisation

union UpdatePaymentResult = ClaimPayment | PolicyPayment | ValidationError

union UpdatePersonClientResult = ClientPerson | AccessDeniedError | PermissionDeniedError | BusinessRuleError | ValidationError

union UpdatePolicyResult = Policy | AccessDeniedError | PermissionDeniedError | ValidationError

union UpdateProviderResult = Provider | PermissionDeniedError | ValidationError

union UpdateSegmentTypeResult = SegmentType | ValidationError

union UpdateTaskResult = TaskConfigurationError | TaskOutcomeNotFoundError | AccessDeniedError | PermissionDeniedError | ValidationError | Task

union UpdateTeamResult = PermissionDeniedError | ValidationError | Team

union UpdateUserPasswordResult = SignaturePasswordMustBeDifferentFromLoginError | SignaturePasswordMustBeDifferentFromOldError | PermissionDeniedError | ValidationError | User | CurrentUser

union UpdateUserResult = PermissionDeniedError | ValidationError | User | CurrentUser

union UpdateVatGroupResult = PermissionDeniedError | ValidationError | VatGroup

union UpdateWebHookListenerResult = WebHookListener | PermissionDeniedError | ValidationError

union VoidClaimPurchaseInvoiceBatchResult = CannotVoidClaimPurchaseInvoiceBatchError | ClaimPurchaseInvoiceBatch

union VoidClaimPurchaseInvoiceBatchesResult = VoidClaimPurchaseInvoiceBatchesResultList | PermissionDeniedError

union WebHookEventsResult = WebHookEventList | PermissionDeniedError

union WebHookListenerResult = WebHookListener | PermissionDeniedError

union WebHookListenersResult = WebHookListenerList | PermissionDeniedError

input AddressPatchInput {
  city: String
  coordinate: CoordinateInput
  country: CountryCodesInput
  formattedAddress: String
  geoProviderType: GeoProviderType
  line1: String
  line2: String
  line3: String
  line4: String
  note: String
  placeId: String
  postalCode: String
}

input AnswerPhoneCallInput {
  "The Id of the NIS PhoneCall that is being answered."
  phoneCallId: String!
  "The Id of the NIS User that has picked up the call."
  userId: Int
}

input BlacklistAddressInput {
  addresses: [String!]
  city: String
  country: String
  postalCode: String
  region: String
}

input BlacklistAddressMatchCriteriaInput {
  addresses: [String!]
  city: String
  countryCode: String
  countryName: String
  postalCode: String
  regionCode: String
  regionName: String
}

input BlacklistEntryInput {
  addresses: [BlacklistAddressInput!]
  affiliations: [String!]
  aliases: [String!]
  datesOfBirth: [FuzzyDateInput!]
  emails: [String!]
  "An identifier unique to the custom blacklist. Subsequent changes to an entry is done by adding an entry with the same id."
  id: String!
  identifiers: [String!]
  names: [String!]
  nationality: String
  notes: [String!]
  passportNumbers: [String!]
  placesOfBirth: [String!]
  type: BlacklistEntryType!
}

input BlacklistMatchCriteriaInput {
  addresses: [BlacklistAddressMatchCriteriaInput!]
  dateOfBirth: Date
  emails: [String!]
  firstName: String
  identifier: String
  lastName: String
  name: String
  passportNumber: String
  type: BlacklistEntryType
}

input BlacklistMatchDecisionInput {
  "An optional justification of the decision."
  justification: String
  "Identifier of the match the decision is regarding."
  matchId: String!
  "The decision outcome. Setting it to null means the decision is pending."
  outcome: BlacklistMatchDecisionOutcome
}

input CalculationCategoryInput {
  "The name of the category."
  name: String!
}

input CalculationClientSelectionInput {
  "Use an existing company client, and optionally update it. The changes aren't saved unless given as part of a mutation that creates or alters a policy\/quote."
  company: UpdateCompanyClientInput
  "Creates a new company client."
  newCompany: CreateCompanyClientInput
  "Creates a new person client."
  newPerson: CreatePersonClientInput
  "Use an existing person client, and optionally update it. The changes aren't saved unless given as part of a mutation that creates or alters a policy\/quote."
  person: UpdatePersonClientInput
}

input CalculationInsuredInput {
  "When calculating a collective product, this should refer to the index of the category the insured belongs to. Cannot be specified when the insured is a client.\nThe Name is required when this is specified."
  categoryIndex: Int
  "When the insured is a client, this should refer to the zero-based index of the client added to the calculation.\nIn the context of creating a claim, it refers to the zero-based index of a claimant."
  clientIndex: Int
  "Specifies which elements are selected for this insured."
  elementSelection: [ProductElementSelectionInput!]
  "An optional key assigned to the insured. The key will be output on the corresponding insured in the result.\nThis is the recommended way to tie the result to the given input. Otherwise it's based on the order of the given insured."
  key: String
  "Specifies the name of the insured item or group. Cannot be specified when the insured is a client."
  name: String
  "Assigns values to product properties for this insured."
  propertyValues: [ProductPropertyAssignmentInput!]
  "Specifies answers to questionnaires that apply to the insured."
  questionnaires: [CalculationQuestionnaireAnswersInput!]
}

input CalculationQuestionnaireAnswersInput {
  answers: [QuestionnaireAnswerInput!]!
  questionnaireId: Int!
}

input ClaimAccountEntryListFiltersInput {
  accountId: Int
  guaranteeId: Int
  invoiceId: Int
  recoveryId: Int
  type: ClaimAccountEntryType
}

input ClaimAccountEntryListInput {
  add: CreateClaimAccountEntryInput!
}

input ClaimAccountEntryOrderInput {
  by: ClaimAccountEntryOrder!
  direction: OrderDirection
  then: ClaimAccountEntryOrderInput
}

input ClaimCollectiveInvoiceOrderInput {
  by: ClaimCollectiveInvoiceOrder!
  direction: OrderDirection
  then: ClaimCollectiveInvoiceOrderInput
}

input ClaimListFiltersInput {
  assignedUserIds: [Int!]
  assistancePhaseIds: [Int!]
  assistanceStatus: ClaimStatus
  coverCauseIds: [Int!]
  createdByUserIds: [Int!]
  createdOn: OptionalDateRangeInput
  departmentIds: [Int!]
  diagnoseIds: [Int!]
  drafts: Boolean
  incidentCountry: String
  incidentOn: OptionalDateRangeInput
  notificationOn: OptionalDateRangeInput
  organisationIds: [Int!]
  phaseIds: [Int!]
  status: ClaimStatus
  tags: [String!]
  teamIds: [Int!]
}

input ClaimOrderInput {
  by: ClaimOrder!
  direction: OrderDirection
  then: ClaimOrderInput
}

input ClaimPaymentGuaranteeListFiltersInput {
  costAgentId: Int
  guaranteeStatus: [ClaimPaymentGuaranteeStatus!]
  treatmentDate: OptionalDateRangeInput
}

input ClaimPurchaseInvoiceBatchListFiltersInput {
  payableStatuses: [ClaimPurchaseInvoiceBatchPayableStatus!]
  status: ClaimPurchaseInvoiceBatchStatus
}

input ClaimPurchaseInvoiceBatchOrderInput {
  by: ClaimPurchaseInvoiceBatchOrder!
  direction: OrderDirection
  then: ClaimPurchaseInvoiceBatchOrderInput
}

input ClaimPurchaseInvoiceBatchOwnerInput {
  claimContactId: Int
  clientId: Int
  providerId: Int
}

input ClaimPurchaseInvoiceBatchSelectionInput {
  create: CreateClaimPurchaseInvoiceBatchInput
  existing: UpdateClaimPurchaseInvoiceBatchInput
}

input ClaimPurchaseInvoiceBehaviorInput {
  processOrganisationReimbursement: Boolean! = true
  processPurchase: Boolean! = true
}

input ClaimPurchaseInvoiceListFiltersInput {
  costAgentId: Int
  invoiceStatus: [ClaimPurchaseInvoiceStatus!]
  treatmentDate: OptionalDateRangeInput
}

input ClaimPurchaseInvoiceOrPaymentGuaranteeListFiltersInput {
  costAgentId: Int
  guaranteeStatus: [ClaimPaymentGuaranteeStatus!]
  invoiceStatus: [ClaimPurchaseInvoiceStatus!]
  treatmentDate: OptionalDateRangeInput
}

input ClaimPurchaseInvoiceOrPaymentGuaranteeOrderInput {
  by: ClaimPurchaseInvoiceOrPaymentGuaranteeOrder!
  direction: OrderDirection
  then: ClaimPurchaseInvoiceOrPaymentGuaranteeOrderInput
}

input CommitPaymentInput {
  paidOn: Date
  paymentId: Int!
  receivedAmount: Decimal
  receivedByBankOn: Date
  receivedCurrencyCode: String
  remark: String
  sequenceNo: String
}

"An actor that either sends or receives a communication."
input CommunicationActorInput {
  "The id of the object that the communication actor references."
  id: Int!
  "The type of object that this communication actor  references."
  type: CommunicationActorType!
}

input CommunicationFieldsInput {
  "The field names of the configured template fields.\nIf no fields are found it will not be included in the result.\nIf the field exists but the value could not be found because of the given context it will return but contain null as the value."
  fieldNames: [String!]!
  "The identifier to the parent object."
  parentId: Int!
  "The type of the parent object. Example: \"claim\" or \"client\"."
  parentType: String!
  "The identifier of the recipient object to be used in combination with the recipient type."
  recipientId: Int
  "The type of the recipient if not using the default mechanism. Example: \"client\" or \"contact\"."
  recipientType: String
}

input CommunicationListFiltersInput {
  content: String
  createdOn: OptionalDateTimeRangeInput
  tags: [String!]
  types: [CommunicationType!]
  voided: Boolean
}

input CommunicationOrderInput {
  by: CommunicationOrder!
  direction: OrderDirection
  then: CommunicationOrderInput
}

input CoordinateInput {
  latitude: Float!
  longitude: Float!
}

input CountryCodesInput {
  iso2Code: String!
  regionId: String
}

input CreateAddressInput {
  city: String
  coordinate: CoordinateInput
  country: CountryCodesInput!
  formattedAddress: String
  geoProviderType: GeoProviderType
  line1: String
  line2: String
  line3: String
  line4: String
  note: String
  placeId: String
  postalCode: String
}

input CreateAssistanceCaseInput {
  accommodation: String
  airline: String
  assigneeId: Int
  carRental: String
  departedOn: Date
  destination: String
  phaseId: Int
  reference: String
  returnedOn: Date
  ticketType: String
  travelAgent: String
  travelCompanions: Int
  travelMethod: String
  travelPurpose: String
  tripPurchasedOn: DateTime
}

input CreateAssistanceEventInput {
  admittedOn: DateTime
  consultation: String
  consultedOn: DateTime
  customFields: [CustomFieldAssignmentInput!]
  dischargedOn: DateTime
  hasPriorApproval: Boolean
  hospital: String
  isTransfer: Boolean
  patientTypeId: Int
  phone: String
  physician: String
  physicianPhone: String
  providerId: Int
  room: String
  specialty: String
}

input CreateBankAccountInput {
  accountNumber: String
  address: CreateAddressInput
  bankName: String
  bankReference: String
  controlKey: String
  currencyCode: String!
  holderName: String
  iban: String
  isPrimary: Boolean
  paymentDefinitionId: Int!
  swift: String
}

input CreateClaimAccountEntryInput {
  "Adds the amount as the total reserve balance for the claim. When this is set to true, no other account entries can be added to the claim in the same mutation."
  addAsTotalBalance: Boolean
  amount: MoneyInput!
  entryOn: DateTime
  remark: String
  reserveTypeId: Int
  type: ClaimAccountEntryType!
}

input CreateClaimAccountInput {
  coverCauseId: Int!
  productCoverageId: Int!
}

input CreateClaimAssociationInput {
  associatedClaimId: Int!
}

input CreateClaimCollectiveInvoiceCommunicationInput {
  content: String
  fileId: String
  subject: String
}

input CreateClaimCollectiveInvoiceInput {
  batch: ClaimPurchaseInvoiceBatchSelectionInput
  communications: [CreateClaimCollectiveInvoiceCommunicationInput!]
  costAgentId: Int
  currencyCode: String!
  dueOn: Date
  invoiceNumber: String
  invoicedOn: Date
  isCommitted: Boolean
  isCreditNote: Boolean
  lineSchemaId: Int
  lines: [CreateClaimCollectiveInvoiceLineInput!]
  providerId: Int!
  receivedOn: Date
  taskConfiguration: CreateClaimCollectiveInvoiceTaskConfigurationInput
}

input CreateClaimCollectiveInvoiceLineInput {
  accountId: Int!
  benefitCount: Int
  claimNumber: Int!
  date: Date
  description: String
  guaranteeId: Int
  price: Decimal
  purchasedOn: Date
  quantity: Int
  reductions: CreateClaimPurchaseInvoiceLineReductionsInput
}

input CreateClaimCollectiveInvoiceTaskConfigurationInput {
  categoryId: Int
  definitionId: Int!
  description: String
  title: String
}

input CreateClaimContactCompanyInput {
  address: CreateAddressInput
  bankAccounts: [CreateBankAccountInput!]
  contactDetails: [CreateContactDetailInput!]
  name: String!
  reference: String
  remark: String
}

input CreateClaimContactInput {
  contact: CreateClaimContactSelectionInput!
  remark: String
  roleTypeId: Int
}

input CreateClaimContactPersonInput {
  address: CreateAddressInput
  bankAccounts: [CreateBankAccountInput!]
  contactDetails: [CreateContactDetailInput!]
  dateOfBirth: Date
  firstName: String!
  lastName: String!
  reference: String
  remark: String
  socialSecurityNumber: String
  titleId: Int
}

"Specifies the creation of a claim contact. Exactly one field must have a value."
input CreateClaimContactSelectionInput {
  "The contact should be created from an existing client."
  clientId: Int
  "Create a new company contact."
  company: CreateClaimContactCompanyInput
  "The contact should be created from an existing organisation."
  organisationId: Int
  "Create a new person contact."
  person: CreateClaimContactPersonInput
  "The contact should be created from an existing provider."
  providerId: Int
}

input CreateClaimEventInput {
  name: String!
}

input CreateClaimExistingPolicyInput {
  insuredObjectUid: UUID
  policySituationId: Int!
}

input CreateClaimFeeTransactionInput {
  amount: Decimal!
  feeId: Int!
  remark: String
}

input CreateClaimFinancialServiceInput {
  code: String!
  excludeFromReductionCalculation: Boolean
  name: String!
  nominalAccountId: Int
  nominalPurchaseAccountId: Int
  permissionGroupIds: [Int!]
  vatGroupId: Int
}

input CreateClaimIncidentInput {
  coverCauseId: Int!
  coverageId: Int!
  description: String
  incidentOn: Date!
  location: CreateAddressInput!
}

input CreateClaimInput {
  assigneeId: Int
  assistance: CreateAssistanceCaseInput
  "Specifies the claimants. Must have at least one. The first entry will be the primary claimant, the rest will be co-claimants."
  claimants: [CreateClaimantInput!]!
  contactDetails: [CreateContactDetailInput!]
  contacts: [CreateClaimContactInput!]
  customFields: [CustomFieldAssignmentInput!]
  diagnosisId: Int
  eventId: Int
  incident: CreateClaimIncidentInput!
  isDraft: Boolean
  notifiedOn: Date!
  phaseId: Int
  phoneCallId: String
  policy: CreateClaimPolicySelectionInput!
  reference: String
  tags: [String!]
}

input CreateClaimJourneyBookingInput {
  description: String
  providerId: Int
  quotedPrice: MoneyInput
  reference: String
  segments: [CreateClaimJourneySegmentInput!]
  status: ClaimJourneyBookingStatus!
  travelers: [CreateClaimJourneyTravelerInput!]
}

input CreateClaimJourneyInput {
  fitToTravelOn: Date!
  isActive: Boolean!
  title: String!
}

input CreateClaimJourneySegmentInput {
  customFields: [CustomFieldAssignmentInput!]
  period: LocalDateTimeRangeInput!
  "This input defines the position of this segment in the sequence of segments of a travel booking. The first segment has SequenceNumber 1, the next has SequenceNumber 2, etc."
  sequenceNumber: Int
  "The id of the selected travel segment type. (Transportation types, hotels etc.)"
  typeId: Int!
}

input CreateClaimJourneyTravelerInput {
  referenceId: Int!
  referenceType: ClaimJourneyTravelerType!
}

input CreateClaimPaymentGuaranteeInput {
  costAgentId: Int
  currencyCode: String!
  customFields: [CustomFieldAssignmentInput!]
  isDraft: Boolean
  lines: [CreateClaimPaymentGuaranteeLineInput!]!
  note: String
  providerId: Int!
  reserveTypeId: Int
  validOn: DateRangeInput!
}

input CreateClaimPaymentGuaranteeLineInput {
  accountId: Int!
  benefitCount: Int
  date: Date!
  description: String
  financialServiceId: Int
  price: Decimal!
  quantity: Int!
  segmentId: Int
}

input CreateClaimPolicyInput {
  "Specifies the insured categories of the policy\/quote. This is only used for collective products."
  categories: [CalculationCategoryInput!]
  "The cover period of the policy\/quote."
  coverage: DateRangeInput!
  "The currency code to use. Must be provided if the product specifies more than one currency."
  currencyCode: String
  "Specifies which non-individual elements are selected."
  elementSelection: [ProductElementSelectionInput!]
  "The index of the holder client of the policy\/quote.\nThe value is the zero-based index of a client added to the calculation.\nIn the context of creating a claim, it is the zero-based index of a claimant."
  holderClientIndex: Int! = 0
  "Specifies the insured clients\/items\/groups of the policy\/quote."
  insured: [CalculationInsuredInput!]!
  "The date the policy\/quote is issued on. When omitted, the policy will be issued today."
  issueOn: Date
  "The identifier of the organisation the policy\/quote should be issued under. When omitted, the organisation of the current user is used."
  organisationId: Int
  "The identifier of the product to issue\/quote."
  productId: Int!
  "Assigns values to product properties that are not assigned individually."
  propertyValues: [ProductPropertyAssignmentInput!]
  "Specifies answers to questionnaires that apply to the policy\/quote."
  questionnaires: [CalculationQuestionnaireAnswersInput!]
  reference: String
}

"Specifies the policy for a claim. Exactly one field must have a value."
input CreateClaimPolicySelectionInput {
  "Create a new policy. This should be used when the product has the `Structural` behavior."
  create: CreateClaimPolicyInput
  "Create a new policy, using simple details. This should be used when the product doesn't have the `Structural` behavior."
  createSimple: CreateClaimSimplePolicyInput
  "Use an existing policy."
  existing: CreateClaimExistingPolicyInput
}

input CreateClaimPurchaseInvoiceBatchInput {
  bankAccountId: Int
  "Determines whether the invoice batch should be closed. This will close the invoice batch and create a payment. A closed invoice batch cannot be reopened."
  isReadyToClose: Boolean
  name: String!
  note: String
  owner: ClaimPurchaseInvoiceBatchOwnerInput!
  payInCurrencyCode: String
  paymentDefinitionId: Int!
}

input CreateClaimPurchaseInvoiceInput {
  admittedOn: Date
  batch: ClaimPurchaseInvoiceBatchSelectionInput
  behavior: ClaimPurchaseInvoiceBehaviorInput!
  costAgentId: Int
  currencyCode: String!
  customFields: [CustomFieldAssignmentInput!]
  diagnosisIds: [Int!]
  dischargedOn: Date
  dueOn: Date
  guaranteeId: Int
  invoiceNumber: String
  invoicedOn: Date
  isDraft: Boolean
  lineSchemaId: Int
  lines: [CreateClaimPurchaseInvoiceLineInput!]!
  note: String
  providerId: Int
  receivedOn: Date
  reference: String
  settleGuarantee: Boolean
}

input CreateClaimPurchaseInvoiceLineDecisionInput {
  code: String
  isActive: Boolean
  name: String
}

input CreateClaimPurchaseInvoiceLineExplanationInput {
  code: String
  isActive: Boolean
  name: String
}

input CreateClaimPurchaseInvoiceLineInput {
  accountId: Int!
  benefitCount: Int
  date: Date!
  description: String
  financialServiceId: Int
  isPriceInputExVat: Boolean
  locked: Boolean
  originalInvoiceLineId: Int
  price: Decimal
  providerId: Int
  quantity: Int!
  reductions: CreateClaimPurchaseInvoiceLineReductionsInput
  segmentId: Int
  vatAmount: Decimal
  vatGroupId: Int
}

input CreateClaimPurchaseInvoiceLineReductionsInput {
  coveredQuantity: Int
  decisionId: Int
  denialReasonId: Int
  denied: Decimal
  discount: Decimal
  explanationIds: [Int!]
  isDenied: Boolean
  preDiscount: Decimal
  savings: Decimal
}

input CreateClaimRecoveryEntryInput {
  amount: MoneyInput!
  createdOn: DateTime
  isReserve: Boolean
  remark: String
}

input CreateClaimRecoveryInput {
  accountId: Int!
  customFields: [CustomFieldAssignmentInput!]
  deadline: Date
  invoiceId: Int
  notifiedOn: Date
  providerId: Int!
  reference: String
  remark: String
  typeId: Int!
}

input CreateClaimSegmentInput {
  description: String
  isActive: Boolean!
  name: String!
  policyLineId: Int
  segmentTypeId: Int!
}

input CreateClaimSimplePolicyInput {
  "The cover period of the policy."
  coverage: DateRangeInput!
  "The identifier of the organisation the policy should be issued under. When omitted, the organisation of the current user is used."
  organisationId: Int
  "The identifier of the product to issue."
  productId: Int!
  reference: String
}

input CreateClaimStrategyInput {
  strategy: String!
  type: ClaimStrategyType!
}

"Specifies the claimant for a claim. Exactly one field must have a value."
input CreateClaimantInput {
  "Uses an existing company client and updates it if it has changes."
  company: UpdateCompanyClientInput
  "Create a new company client."
  newCompany: CreateCompanyClientInput
  "Create a new person client."
  newPerson: CreatePersonClientInput
  "Uses an existing person client and updates it if it has changes."
  person: UpdatePersonClientInput
}

input CreateClientAddressInput {
  city: String
  coordinate: CoordinateInput
  country: CountryCodesInput!
  formattedAddress: String
  geoProviderType: GeoProviderType
  "Marks the address as primary. Only one address can be marked as primary within a given collection of client addresses.\nAdding a new primary address causes the existing primary address (if any) to be marked as non-primary."
  isPrimary: Boolean
  line1: String
  line2: String
  line3: String
  line4: String
  note: String
  placeId: String
  postalCode: String
  type: ClientAddressType
}

"The input type for creating a communication based on a communication token."
input CreateCommunicationFromTokenInput {
  "Gets or sets the content of the communication the the token will end up create."
  content: String
  "Gets or sets the formatted content of the communication the the token will end up create."
  contentFormatted: String
  "Gets or sets the email of the communication."
  email: String
  "Gets or sets the subject of the communication."
  subject: String
  "Gets or sets the GUID of the Communication Token to take input values from."
  tokenUid: String!
  "Gets or sets the uploaded file identifiers that was uploading using the temporary file storage."
  uploadedAttachedFileIds: [String!]
}

"Specifies a communication to be created. Exactly one field must have a value.\nWhich field has value determines which type of communication is created."
input CreateCommunicationInput {
  email: CreateEmailCommunicationInput
  fax: CreateFaxCommunicationInput
  file: CreateFileCommunicationInput
  letter: CreateLetterCommunicationInput
  note: CreateNoteCommunicationInput
  token: CreateTokenCommunicationInput
}

input CreateCompanyClientInput {
  addresses: [CreateClientAddressInput!]
  bankAccounts: [CreateBankAccountInput!]
  contactDetails: [CreateContactDetailInput!]
  countryOfOrigin: String
  externalId: String
  files: [CreateFileInput!]
  isVip: Boolean
  language: String
  name: String!
}

input CreateComplaintInput {
  address: CreateAddressInput
  approvedOn: DateTime
  contactDetails: [CreateContactDetailInput!]
  details: String!
  finalResponse: String
  name: String!
  receivedBy: ComplaintReceivedBy
  receivedOn: DateTime
  title: String
}

input CreateContactDetailInput {
  "Marks the contact detail as primary. Only one contact detail of a given type can be marked as primary within a given collection of contact details.\nAdding a new primary contact detail of a given type causes the existing primary contact detail of that type (if any) to be marked as non-primary."
  isPrimary: Boolean
  type: ContactDetailType!
  value: String!
}

input CreateCustomDialogInput {
  displayType: CustomDialogDisplayType!
  isActive: Boolean!
  name: String!
  permissionGroupIds: [Int!]
  refreshWhenClosed: Boolean!
  type: CustomDialogType!
  url: String!
}

input CreateDerivedProductAgreementInput {
  derivedCommissionPercentage: Decimal
  isBlocked: Boolean
  productCode: String!
}

input CreateEmailCommunicationInput {
  additionalRecipients: [String!]
  attachedFileIds: [Int!]
  bcc: [String!]
  cc: [String!]
  "The content of the email, in clear text. All formatting (like HTML) should be removed."
  content: String!
  "The content of the email, with formatting (like HTML)."
  contentFormatted: String
  direction: CommunicationDirection! = OUTGOING
  externalId: String
  "The recipient of the communication."
  recipient: CommunicationActorInput!
  recipientEmail: String!
  sendEmail: Boolean! = true
  "The sender chosen for this communication."
  sender: CommunicationActorInput!
  senderEmail: String!
  subject: String!
  "The list of tags connected to the communication."
  tags: [String!]
  "The id of the CommunicationTemplate used to generate the e-mail."
  templateId: Int!
  transmittedOn: DateTime
  uploadedAttachedFileIds: [String!]
}

input CreateExchangeRateInput {
  rate: Decimal!
  sourceCurrencyCode: String!
  targetCurrencyCode: String!
  validOn: DateTime
}

input CreateFaxCommunicationInput {
  "The recipient of the communication."
  recipient: CommunicationActorInput!
  subject: String!
  "The list of tags connected to the communication."
  tags: [String!]
  uploadedAttachedFileIds: [String!]
}

input CreateFileCommunicationInput {
  "The content of the note, in clear text. All formatting (like HTML) should be removed."
  content: String!
  "The content of the note, with formatting (like HTML)."
  contentFormatted: String
  direction: CommunicationDirection! = OUTGOING
  externalId: String
  "The recipient of the communication."
  recipient: CommunicationActorInput!
  subject: String!
  "The list of tags connected to the communication."
  tags: [String!]
  transmittedOn: DateTime
  uploadedAttachedFileIds: [String!]!
}

input CreateFileInput {
  tempFileId: String!
}

input CreateIdentityProviderInput {
  description: String!
  entityId: String!
  metadataUrl: String
}

input CreateInboxTypeInput {
  code: String!
  "Defaults to true if not provided"
  isActive: Boolean
  name: String!
}

input CreateLetterCommunicationInput {
  "The recipient of the communication."
  recipient: CommunicationActorInput!
  subject: String!
  "The list of tags connected to the communication."
  tags: [String!]
  templateId: Int!
}

input CreateMoneyAccountInput {
  code: String
  currencyCode: String
  exportFormat: String
  externalId: String
  name: String!
  type: MoneyAccountType
}

input CreateNoteCommunicationInput {
  "The content of the note, in clear text. All formatting (like HTML) should be removed."
  content: String!
  "The content of the note, with formatting (like HTML)."
  contentFormatted: String
  "The recipient of the communication."
  recipient: CommunicationActorInput!
  subject: String!
  "The list of tags connected to the communication."
  tags: [String!]
  type: CommunicationNoteType!
}

input CreateOrganisationAddressInput {
  city: String
  coordinate: CoordinateInput
  country: CountryCodesInput!
  formattedAddress: String
  geoProviderType: GeoProviderType
  line1: String
  line2: String
  line3: String
  line4: String
  note: String
  placeId: String
  postalCode: String
  type: OrganisationAddressType!
}

input CreateOrganisationContactInput {
  comment: String
  contactDetails: [CreateContactDetailInput!]
  department: String
  firstName: String!
  isInternal: Boolean
  jobTitle: String
  lastName: String
  preferredLanguage: String
  titleId: Int
  type: OrganisationContactType
}

input CreateOrganisationInput {
  code: String!
  currencies: [String!]
  isActive: Boolean
  name: String!
  parent: OrganisationParentInput!
  secondaryTypes: [OrganisationType!]
  shortName: String
  type: OrganisationType
  vatIdentificationNumber: String
}

input CreatePaymentActivityInput {
  description: String!
}

input CreatePaymentActivityListActionInput {
  add: CreatePaymentActivityInput!
}

input CreatePersonClientInput {
  addresses: [CreateClientAddressInput!]
  bankAccounts: [CreateBankAccountInput!]
  contactDetails: [CreateContactDetailInput!]
  countryOfOrigin: String
  dateOfBirth: Date
  employeeNumber: String
  externalId: String
  files: [CreateFileInput!]
  firstName: String!
  gender: Gender
  isVip: Boolean
  jobTitle: String
  language: String
  lastName: String!
  passportNumber: String
  socialSecurityNumber: String
  titleId: Int
}

input CreatePhoneCallInput {
  "The phone number of the caller (incoming number)."
  callerPhoneNumber: String!
  "The initial display mode of the phone call, it indicates whether or not the dashboard should be shown or hidden for the user.\nHidden indicates that the user has to navigate to the list of active phone calls themselves. Shown indicates it's being displayed on top of the current view of the user."
  initialDisplayMode: PhoneCallDisplayMode
  "If this URL is provided it will be the recipient of a POST request, when PhoneNote communications are created based on this call.\nThe post request contains the ids of the notes that were created in a JSON object. Example:\n\n{\n   \"callId\" : \"da7fde9c-e5d3-45be-ae18-84171bfa7a85\",\n   \"communicationIds\" : [\n            34,\n            35\n       ]\n}"
  noteUrl: String
  "A list of organisations linked to the phone call. This can be used for restricting the organisations on which claims can be created from this phone call."
  organisationCodes: [String!]
  "A list of products linked to the phone call. This can be used for restricting the products on which claims can be created from this phone call."
  productCodes: [String!]
  "The the recipient phone number, i.e. the number being called in the phone system."
  recipientPhoneNumber: String
  "The Id of the NIS User that is to be the recipient in Nordic of the call."
  userId: Int
}

input CreateProductVisibilityGroupInput {
  name: String!
  productCodes: [String!]!
}

input CreateProviderContactAddressInput {
  city: String
  coordinate: CoordinateInput
  country: CountryCodesInput!
  formattedAddress: String
  geoProviderType: GeoProviderType
  line1: String
  line2: String
  line3: String
  line4: String
  note: String
  placeId: String
  postalCode: String
  type: ProviderContactAddressType!
}

input CreateProviderContactInput {
  addresses: [CreateProviderContactAddressInput!]
  contactDetails: [CreateContactDetailInput!]
  firstName: String!
  lastName: String!
  remark: String
  roleTypeId: Int
  titleId: Int
}

input CreateProviderInput {
  address: CreateAddressInput!
  bankAccounts: [CreateBankAccountInput!]
  contactDetails: [CreateContactDetailInput!]
  currencyCode: String
  customFields: [CustomFieldAssignmentInput!]
  defaultCostAgentId: Int
  defaultInvoiceLineSchemaId: Int
  financialRating: Int
  iconId: Int
  invoiceBatchingMethod: PurchaseInvoiceBatchingMethod
  isPractitioner: Boolean
  linkedProviderIds: [Int!]
  name: String!
  networkIds: [Int!]
  paymentDefinitionId: Int
  qualityRating: Int
  reference: String
  remark: String
  serviceRange: Int
  services: [ProviderServiceInput!]
  vatId: String
  "Represents the VAT percentage of the provider. Valid values are 0 to 100 inclusive."
  vatPercentage: Decimal
}

input CreateSegmentTypeInput {
  isActive: Boolean!
  name: String!
}

input CreateTaskInput {
  assigneeId: Int
  autoAssign: Boolean
  categoryId: Int
  definitionId: Int!
  description: String
  dueOn: DateTime
  priority: TaskPriority
  remark: String
  tags: [String!]
  title: String
}

input CreateTeamInput {
  name: String!
}

input CreateTokenCommunicationInput {
  attachedFileIds: [Int!]
  bcc: [String!]
  cc: [String!]
  content: String
  contentFormatted: String
  faxNumber: String
  recipient: CommunicationActorInput
  recipientEmail: String
  sender: CommunicationActorInput
  senderEmail: String
  subject: String!
  tags: [String!]
  templateId: Int!
  tokenType: CommunicationTokenType!
  tokenUid: String
  uploadedAttachedFileIds: [String!]
}

input CreateUnassignedFileInput {
  createdByUserId: Int!
  description: String
  tags: [String!]!
  title: String
  uploadedFileId: String!
}

input CreateUserInput {
  authorityLevel: Int
  defaultDepartmentId: Int!
  departmentIds: [Int!]
  email: String!
  isActive: Boolean
  jobTitle: String
  maxAuthorizedPayment: MoneyInput
  maxAuthorizedPaymentType: MaxAuthorizedPaymentType
  maxGuarantee: MoneyInput
  maxReservation: MoneyInput
  maxSelfSign: MoneyInput
  mustChangePassword: Boolean
  name: String!
  organisationId: Int
  password: String!
  passwordNeverExpires: Boolean
  permissionGroupIds: [Int!]
  phoneNumber: String
  productVisibilityGroupIds: [Int!]
  signaturePassword: String
  teamId: Int
  useProductVisibilityGroups: Boolean
  username: String!
  visibilityLimit: VisibilityLimitMode
}

input CreateUserPersonalAccessTokenInput {
  "Specifies when the personal access token should expire. When omitted, the token never expires."
  expiresOn: DateTime
  name: String!
  "The ID of the user to create the personal access token for. When omitted, it will be created for the current user.\nA permission is required when specifying a different user."
  userId: Int
}

input CreateVatGroupInput {
  code: String
  name: String!
  percentage: Decimal
}

input CreateWebHookListenerInput {
  enableSslVerification: Boolean = true
  events: [String!]!
  headerName: String
  headerValue: String
  timeout: Int = 10
  url: String!
}

input CustomDialogListFiltersInput {
  type: CustomDialogType
}

input CustomDialogOrderInput {
  by: CustomDialogOrder!
  direction: OrderDirection
  then: CustomDialogOrderInput
}

input CustomFieldAssignmentInput {
  key: String!
  value: CustomFieldValueInput!
}

input CustomFieldValueInput {
  bool: Boolean
  date: DateTime
  number: Float
  string: String
}

input DateRangeInput {
  end: Date!
  start: Date!
}

input DiagnosisOrderInput {
  by: DiagnosisOrder!
  direction: OrderDirection
  then: DiagnosisOrderInput
}

input EndPhoneCallInput {
  "The Id of the NIS PhoneCall to end."
  phoneCallId: String!
  "The Id of the NIS User that ends the call."
  userId: Int
}

input ExchangeRateListFiltersInput {
  fromCurrencyCode: String
  toCurrencyCode: String
}

input ExchangeRateOrderInput {
  by: ExchangeRateOrder!
  direction: OrderDirection
  then: ExchangeRateOrderInput
}

input FuzzyDateInput {
  from: Date
  to: Date
}

input GoogleAddressComponentInput {
  long_name: String
  short_name: String
  types: [String]
}

input GoogleGeocodingResultInput {
  address_components: [GoogleAddressComponentInput]
  formatted_address: String
  geometry: GoogleGeometryInput
  place_id: String
  types: [String]
}

input GoogleGeometryInput {
  location: GoogleLocationInput
  location_type: String
  viewport: GoogleViewportInput
}

input GoogleLocationInput {
  lat: Float!
  lng: Float!
}

input GoogleViewportInput {
  northeast: GoogleLocationInput
  southwest: GoogleLocationInput
}

input LocalDateTimeRangeInput {
  end: LocalDateTime!
  start: LocalDateTime!
}

input MoneyInput {
  amount: Decimal!
  currency: String!
}

input OptionalDateRangeInput {
  end: Date
  start: Date
}

input OptionalDateTimeRangeInput {
  end: DateTime
  start: DateTime
}

input OptionalNumberRangeInput {
  end: Float
  start: Float
}

input OptionalPaginationInput {
  disabled: Boolean
  limit: Int
  offset: Int
}

input OrganisationOrderInput {
  by: OrganisationOrder!
  direction: OrderDirection
  then: OrganisationOrderInput
}

"An input type that represents the parent of an organisation.\n            \nAn organisation can either be created as a suborganisation under an existing organisation, or as a\nroot organisation under a department.\n            \nEither the DepartmentId or the OrganisationId must be set. Both cannot be set at the same time."
input OrganisationParentInput {
  departmentId: Int
  organisationId: Int
}

input PaginationInput {
  limit: Int
  offset: Int
}

input PaymentExportOrderInput {
  by: PaymentExportOrder!
  direction: OrderDirection
  then: PaymentExportOrderInput
}

input PaymentListFiltersInput {
  direction: PaymentDirection
  id: Int
  moneyAccountIds: [Int!]
  paidOn: OptionalDateRangeInput
  statuses: [PaymentStatus!]
  type: PaymentType
}

input PaymentOrderInput {
  by: PaymentOrder!
  direction: OrderDirection
  then: PaymentOrderInput
}

input PolicyCreateItemInput {
  "Specifies the insured categories of the policy\/quote. This is only used for collective products."
  categories: [CalculationCategoryInput!]
  "The cover period of the policy\/quote."
  coverage: DateRangeInput!
  "The currency code to use. Must be provided if the product specifies more than one currency."
  currencyCode: String
  "Specifies which non-individual elements are selected."
  elementSelection: [ProductElementSelectionInput!]
  "The index of the holder client of the policy\/quote.\nThe value is the zero-based index of a client added to the calculation.\nIn the context of creating a claim, it is the zero-based index of a claimant."
  holderClientIndex: Int! = 0
  "Specifies the insured clients\/items\/groups of the policy\/quote."
  insured: [CalculationInsuredInput!]!
  "Specifies that the policy should be marked as being created from an external source. This can for example be useful when a policy is created from an external web shop or portal."
  isExternal: Boolean
  "The date the policy\/quote is issued on. When omitted, the policy will be issued today."
  issueOn: Date
  "The identifier of the organisation the policy\/quote should be issued under. When omitted, the organisation of the current user is used."
  organisationId: Int
  "The index of the owner client of the policy\/quote. The owner is not part of the policy\/quote, but can be used to associate a policy\/quote with a client (i.e. a company)"
  ownerClientIndex: Int
  "Specifies how payment of the policy should happen."
  payment: PolicyPaymentInput!
  "The identifier of the product to issue\/quote."
  productId: Int!
  "Assigns values to product properties that are not assigned individually."
  propertyValues: [ProductPropertyAssignmentInput!]
  "Specifies answers to questionnaires that apply to the policy\/quote."
  questionnaires: [CalculationQuestionnaireAnswersInput!]
  salesChannelNumber: Int
}

input PolicyPaymentInput {
  "The frequency of payment. When omitted, payment will occur monthly, or whatever frequency the product permits."
  frequency: PaymentFrequency
  "The identifier of the payment method to use."
  methodId: UUID!
  "The index of the client to use as payee. When omitted, the holder will be used."
  payeeClientIndex: Int
}

input ProductElementSelectionInput {
  key: String!
  selected: Boolean = true
}

input ProductPropertyAssignmentInput {
  key: String!
  value: ProductPropertyValueInput!
}

input ProductPropertyValueInput {
  boolean: Boolean
  date: Date
  float: Float
  integer: Int
  string: String
}

input ProviderListFiltersInput {
  costAgent: Boolean
  isActive: Boolean
}

input ProviderOrderInput {
  by: ProviderOrder!
  direction: OrderDirection
  then: ProviderOrderInput
}

input ProviderServiceInput {
  id: Int!
  isPrimary: Boolean!
}

input QuestionnaireAnswerInput {
  questionId: String!
  value: QuestionnaireAnswerValueInput!
}

"Specifies the value of a questionnaire answer. Exactly one field must be assigned."
input QuestionnaireAnswerValueInput {
  "Used for questions of type QuestionnaireBooleanQuestion."
  bool: Boolean
  "Used for questions of type QuestionnaireChoiceQuestion."
  choices: [String!]
  "Used for questions of type QuestionnaireDateTimeQuestion."
  date: LocalDateTime
  "Used for questions of type QuestionnaireTextQuestion."
  string: String
}

input QuoteCalculationItemInput {
  "Specifies the insured categories of the policy\/quote. This is only used for collective products."
  categories: [CalculationCategoryInput!]
  "The cover period of the policy\/quote."
  coverage: DateRangeInput!
  "The currency code to use. Must be provided if the product specifies more than one currency."
  currencyCode: String
  "Specifies which non-individual elements are selected."
  elementSelection: [ProductElementSelectionInput!]
  "The index of the holder client of the policy\/quote.\nThe value is the zero-based index of a client added to the calculation.\nIn the context of creating a claim, it is the zero-based index of a claimant."
  holderClientIndex: Int! = 0
  "Specifies the insured clients\/items\/groups of the policy\/quote."
  insured: [CalculationInsuredInput!]!
  "The date the policy\/quote is issued on. When omitted, the policy will be issued today."
  issueOn: Date
  "The identifier of the organisation the policy\/quote should be issued under. When omitted, the organisation of the current user is used."
  organisationId: Int
  "The index of the owner client of the policy\/quote. The owner is not part of the policy\/quote, but can be used to associate a policy\/quote with a client (i.e. a company)"
  ownerClientIndex: Int
  "Specifies how payment of the eventual policy should happen. When specified, the result will include a payment schedule."
  payment: PolicyPaymentInput
  "The identifier of the product to issue\/quote."
  productId: Int!
  "Assigns values to product properties that are not assigned individually."
  propertyValues: [ProductPropertyAssignmentInput!]
  "Specifies answers to questionnaires that apply to the policy\/quote."
  questionnaires: [CalculationQuestionnaireAnswersInput!]
  salesChannelNumber: Int
}

"Specifies details about the rejection of a payment."
input RejectPaymentInput {
  "The external code for why the payment was canceled. This is recorded on the payment object."
  cancellationCode: String
  "The free text reason that the payment was canceled. This is recorded on the payment object."
  cancellationReason: String!
  "The NIS id of the payment."
  paymentId: Int!
}

input SearchParameterAssignmentInput {
  key: String!
  value: SearchParameterValueInput!
}

"Specifies the value of a search parameter. Exactly one field must be assigned."
input SearchParameterValueInput {
  "Used for parameters of type BooleanSearchParameter."
  bool: Boolean
  "Used for parameters of type DateSearchParameter."
  date: DateTime
  "Used for parameters of type DateRangeSearchParameter."
  dateRange: OptionalDateTimeRangeInput
  "Used for parameters of type SelectionSearchParameter with options of type DateSelectionSearchParameterOption."
  dateSelection: [DateTime!]
  "Used for parameters of type NumberSearchParameter."
  number: Float
  "Used for parameters of type NumberRangeSearchParameter."
  numberRange: OptionalNumberRangeInput
  "Used for parameters of type SelectionSearchParameter with options of type NumberSelectionSearchParameterOption."
  numberSelection: [Float!]
  "Used for parameters of type StringSearchParameter."
  string: String
  "Used for parameters of type SelectionSearchParameter with options of type StringSelectionSearchParameterOption."
  stringSelection: [String!]
}

input SearchParametersInput {
  "The search schema type the parameters apply to."
  type: UUID!
  values: [SearchParameterAssignmentInput!]!
}

input TaskListFiltersInput {
  assignedUserIds: [Int!]
  categoryIds: [Int!]
  "A value indicating whether completed tasks should be included in the result."
  completed: Boolean
  createdByUserIds: [Int!]
  createdOn: OptionalDateTimeRangeInput
  departmentIds: [Int!]
  dueOn: OptionalDateTimeRangeInput
  organisationIds: [Int!]
  parentTypes: [TaskParentType!]
  priorities: [TaskPriority!]
  "A value indicating whether tasks assigned to the SYSTEM user should be included in the result."
  system: Boolean
  tags: [String!]
  teamIds: [Int!]
}

input TaskOrderInput {
  by: TaskOrder!
  direction: OrderDirection
  then: TaskOrderInput
}

input TaskQuestionnaireInput {
  answers: [QuestionnaireAnswerInput!]!
  "If set to true, the task will be completed using the outcome selected by the questionnaire.\nThis only applies when the questionnaire has been completed."
  completeTask: Boolean!
  tags: [String!]!
}

input TeamOrderInput {
  by: TeamOrder!
  direction: OrderDirection
  then: TeamOrderInput
}

input UnassignedFileListFiltersInput {
  createdByUserIds: [Int!]
  createdOn: OptionalDateTimeRangeInput
  tags: [String!]
  typeCodes: [String!]
}

input UnassignedFileOrderInput {
  by: UnassignedFileOrder!
  direction: OrderDirection
  then: UnassignedFileOrderInput
}

input UpdateAssistanceCaseInput {
  accommodation: String
  airline: String
  assigneeId: Int
  carRental: String
  departedOn: Date
  destination: String
  events: [UpdateAssistanceEventListActionInput!]
  phaseId: Int
  reference: String
  returnedOn: Date
  status: ClaimStatus
  ticketType: String
  travelAgent: String
  travelCompanions: Int
  travelMethod: String
  travelPurpose: String
  tripPurchasedOn: DateTime
}

input UpdateAssistanceEventInput {
  admittedOn: DateTime
  consultation: String
  consultedOn: DateTime
  customFields: [CustomFieldAssignmentInput!]
  dischargedOn: DateTime
  hasPriorApproval: Boolean
  hospital: String
  id: Int!
  isTransfer: Boolean
  patientTypeId: Int
  phone: String
  physician: String
  physicianPhone: String
  providerId: Int
  room: String
  specialty: String
}

input UpdateAssistanceEventListActionInput {
  add: CreateAssistanceEventInput
  modify: UpdateAssistanceEventInput
  remove: Int
}

input UpdateBankAccountInput {
  accountNumber: String
  address: AddressPatchInput
  bankName: String
  bankReference: String
  controlKey: String
  currencyCode: String
  holderName: String
  iban: String
  id: Int!
  isPrimary: Boolean
  paymentDefinitionId: Int
  swift: String
}

input UpdateBankAccountListActionInput {
  add: CreateBankAccountInput
  modify: UpdateBankAccountInput
  remove: Int
}

input UpdateClaimAccountInput {
  entries: [ClaimAccountEntryListInput!]
  id: Int!
  isDisabled: Boolean
}

input UpdateClaimAccountListActionInput {
  add: CreateClaimAccountInput
  modify: UpdateClaimAccountInput
}

input UpdateClaimAssociationListActionInput {
  add: CreateClaimAssociationInput
  remove: Int
}

input UpdateClaimCollectiveInvoiceInput {
  batch: ClaimPurchaseInvoiceBatchSelectionInput
  communications: [CreateClaimCollectiveInvoiceCommunicationInput!]
  costAgentId: Int
  currencyCode: String
  dueOn: Date
  id: Int!
  invoiceNumber: String
  invoicedOn: Date
  isCommitted: Boolean
  lineSchemaId: Int
  lines: [CreateClaimCollectiveInvoiceLineInput!]
  receivedOn: Date
  taskConfiguration: UpdateClaimCollectiveInvoiceTaskConfigurationInput
}

input UpdateClaimCollectiveInvoiceTaskConfigurationInput {
  categoryId: Int
  definitionId: Int!
  description: String
  title: String
}

input UpdateClaimContactCompanyInput {
  address: AddressPatchInput
  bankAccounts: [UpdateBankAccountListActionInput!]
  contactDetails: [UpdateContactDetailListActionInput!]
  name: String
  reference: String
  remark: String
}

input UpdateClaimContactInput {
  company: UpdateClaimContactCompanyInput
  id: Int!
  isActive: Boolean
  person: UpdateClaimContactPersonInput
  roleTypeId: Int
}

input UpdateClaimContactListActionInput {
  add: CreateClaimContactInput
  modify: UpdateClaimContactInput
  remove: Int
}

input UpdateClaimContactPersonInput {
  address: AddressPatchInput
  bankAccounts: [UpdateBankAccountListActionInput!]
  contactDetails: [UpdateContactDetailListActionInput!]
  dateOfBirth: Date
  firstName: String
  lastName: String
  reference: String
  remark: String
  socialSecurityNumber: String
  titleId: Int
}

input UpdateClaimDiagnosesInput {
  diagnosisIds: [Int!]!
  primaryDiagnosisId: Int
}

input UpdateClaimEventInput {
  isActive: Boolean
  name: String
}

input UpdateClaimFeeTransactionListActionInput {
  add: CreateClaimFeeTransactionInput!
}

input UpdateClaimFinancialServiceInput {
  code: String
  excludeFromReductionCalculation: Boolean
  isActive: Boolean
  name: String
  nominalAccountId: Int
  nominalPurchaseAccountId: Int
  permissionGroupIds: [Int!]
  vatGroupId: Int
}

input UpdateClaimIncidentInput {
  coverCauseId: Int
  description: String
  incidentOn: Date
  location: AddressPatchInput
}

input UpdateClaimInput {
  accounts: [UpdateClaimAccountListActionInput!]
  assigneeId: Int
  assistance: UpdateAssistanceCaseInput
  associations: [UpdateClaimAssociationListActionInput!]
  communications: [UpdateCommunicationListActionInput!]
  complaints: [UpdateComplaintListActionInput!]
  contactDetails: [UpdateContactDetailListActionInput!]
  contacts: [UpdateClaimContactListActionInput!]
  customFields: [CustomFieldAssignmentInput!]
  diagnoses: UpdateClaimDiagnosesInput
  eventId: Int
  feeTransactions: [UpdateClaimFeeTransactionListActionInput!]
  guarantees: [UpdateClaimPaymentGuaranteeListActionInput!]
  incident: UpdateClaimIncidentInput
  isPinned: Boolean
  journeys: [UpdateClaimJourneyListActionInput!]
  notifiedOn: Date
  phaseId: Int
  purchaseInvoices: [UpdateClaimPurchaseInvoiceListActionInput!]
  purchaseInvoicesBatches: [UpdateClaimPurchaseInvoiceBatchListActionInput!]
  recoveries: [UpdateClaimRecoveryListActionInput!]
  reference: String
  segments: [UpdateClaimSegmentListActionInput!]
  strategies: [UpdateClaimStrategyListActionInput!]
  tags: [String!]
  tasks: [UpdateTaskListActionInput!]
}

input UpdateClaimJourneyBookingInput {
  description: String
  id: Int!
  providerId: Int
  quotedPrice: MoneyInput
  reference: String
  segments: [UpdateClaimJourneySegmentListActionInput!]
  status: ClaimJourneyBookingStatus
  travelers: [CreateClaimJourneyTravelerInput!]
}

input UpdateClaimJourneyBookingListActionInput {
  add: CreateClaimJourneyBookingInput
  modify: UpdateClaimJourneyBookingInput
  remove: Int
}

input UpdateClaimJourneyInput {
  bookings: [UpdateClaimJourneyBookingListActionInput!]
  communications: [UpdateCommunicationListActionInput!]
  fitToTravelOn: Date
  id: Int!
  isActive: Boolean
  title: String
}

input UpdateClaimJourneyListActionInput {
  add: CreateClaimJourneyInput
  modify: UpdateClaimJourneyInput
  remove: Int
}

input UpdateClaimJourneySegmentInput {
  customFields: [CustomFieldAssignmentInput!]
  id: Int!
  period: LocalDateTimeRangeInput
  "This input defines the position of this segment in the sequence of segments of a travel booking. The first segment has SequenceNumber 1, the next has SequenceNumber 2, etc."
  sequenceNumber: Int
  "The id of the selected travel segment type. (Transportation types, hotels etc.)"
  typeId: Int
}

input UpdateClaimJourneySegmentListActionInput {
  add: CreateClaimJourneySegmentInput
  modify: UpdateClaimJourneySegmentInput
  remove: Int
}

input UpdateClaimPaymentGuaranteeInput {
  communications: [UpdateCommunicationListActionInput!]
  costAgentId: Int
  currencyCode: String
  customFields: [CustomFieldAssignmentInput!]
  id: Int!
  isDraft: Boolean
  lines: [UpdateClaimPaymentGuaranteeLineListActionInput!]
  note: String
  providerId: Int
  reserveTypeId: Int
  tasks: [UpdateTaskListActionInput!]
  validOn: DateRangeInput
}

input UpdateClaimPaymentGuaranteeLineInput {
  accountId: Int
  benefitCount: Int
  date: Date
  description: String
  financialServiceId: Int
  id: Int!
  price: Decimal
  quantity: Int
  segmentId: Int
}

input UpdateClaimPaymentGuaranteeLineListActionInput {
  add: CreateClaimPaymentGuaranteeLineInput
  modify: UpdateClaimPaymentGuaranteeLineInput
  remove: Int
}

input UpdateClaimPaymentGuaranteeListActionInput {
  add: CreateClaimPaymentGuaranteeInput
  modify: UpdateClaimPaymentGuaranteeInput
}

input UpdateClaimPurchaseInvoiceBatchInput {
  bankAccountId: Int
  closeDate: Date
  id: Int!
  "Determines whether the invoice batch should be closed. This will close the invoice batch and create a payment. A closed invoice batch cannot be reopened."
  isReadyToClose: Boolean
  name: String
  note: String
  payInCurrencyCode: String
  paymentDefinitionId: Int
}

input UpdateClaimPurchaseInvoiceBatchListActionInput {
  add: CreateClaimPurchaseInvoiceBatchInput
  modify: UpdateClaimPurchaseInvoiceBatchInput
}

input UpdateClaimPurchaseInvoiceInput {
  admittedOn: Date
  batch: ClaimPurchaseInvoiceBatchSelectionInput
  behavior: ClaimPurchaseInvoiceBehaviorInput
  communications: [UpdateCommunicationListActionInput!]
  costAgentId: Int
  currencyCode: String
  customFields: [CustomFieldAssignmentInput!]
  diagnosisIds: [Int!]
  dischargedOn: Date
  dueOn: Date
  id: Int!
  invoiceNumber: String
  invoicedOn: Date
  isDraft: Boolean
  lineSchemaId: Int
  lines: [UpdateClaimPurchaseInvoiceLineListActionInput!]
  note: String
  providerId: Int
  receivedOn: Date
  reference: String
  tasks: [UpdateTaskListActionInput!]
}

input UpdateClaimPurchaseInvoiceLineDecisionInput {
  code: String
  isActive: Boolean
  name: String
}

input UpdateClaimPurchaseInvoiceLineExplanationInput {
  code: String
  isActive: Boolean
  name: String
}

input UpdateClaimPurchaseInvoiceLineInput {
  accountId: Int
  benefitCount: Int
  date: Date
  description: String
  financialServiceId: Int
  id: Int!
  isPriceInputExVat: Boolean!
  locked: Boolean!
  price: Decimal
  providerId: Int
  quantity: Int
  reductions: UpdateClaimPurchaseInvoiceLineReductionsInput
  segmentId: Int
  vatAmount: Decimal
  vatGroupId: Int
}

input UpdateClaimPurchaseInvoiceLineListActionInput {
  add: CreateClaimPurchaseInvoiceLineInput
  modify: UpdateClaimPurchaseInvoiceLineInput
  remove: Int
}

input UpdateClaimPurchaseInvoiceLineReductionsInput {
  coveredQuantity: Int
  decisionId: Int
  denialReasonId: Int
  denied: Decimal
  discount: Decimal
  explanationIds: [Int!]
  isDenied: Boolean
  preDiscount: Decimal
  savings: Decimal
}

input UpdateClaimPurchaseInvoiceListActionInput {
  add: CreateClaimPurchaseInvoiceInput
  modify: UpdateClaimPurchaseInvoiceInput
}

input UpdateClaimRecoveryEntryListActionInput {
  add: CreateClaimRecoveryEntryInput!
}

input UpdateClaimRecoveryInput {
  accountId: Int
  communications: [UpdateCommunicationListActionInput!]
  customFields: [CustomFieldAssignmentInput!]
  deadline: Date
  entries: [UpdateClaimRecoveryEntryListActionInput!]
  id: Int!
  invoiceId: Int
  notifiedOn: Date
  providerId: Int
  reference: String
  remark: String
  status: ClaimRecoveryStatus
  tasks: [UpdateTaskListActionInput!]
  typeId: Int
}

input UpdateClaimRecoveryListActionInput {
  add: CreateClaimRecoveryInput
  modify: UpdateClaimRecoveryInput
}

input UpdateClaimSegmentInput {
  description: String
  id: Int!
  isActive: Boolean
  name: String
  policyLineId: Int
  segmentTypeId: Int
}

input UpdateClaimSegmentListActionInput {
  add: CreateClaimSegmentInput
  modify: UpdateClaimSegmentInput
}

input UpdateClaimStrategyListActionInput {
  add: CreateClaimStrategyInput!
}

input UpdateClientAddressInput {
  city: String
  coordinate: CoordinateInput
  country: CountryCodesInput
  formattedAddress: String
  geoProviderType: GeoProviderType
  id: Int!
  "Marks the address as primary. Only one address can be marked as primary within a given collection of client addresses.\nMarking an address as primary causes the existing primary address (if any) to be marked as non-primary."
  isPrimary: Boolean
  line1: String
  line2: String
  line3: String
  line4: String
  note: String
  placeId: String
  postalCode: String
  type: ClientAddressType
}

input UpdateClientAddressListActionInput {
  add: CreateClientAddressInput
  modify: UpdateClientAddressInput
  remove: Int
}

input UpdateClientInput {
  addresses: [UpdateClientAddressListActionInput!]
  bankAccounts: [UpdateBankAccountListActionInput!]
  communications: [UpdateCommunicationListActionInput!]
  contactDetails: [UpdateContactDetailListActionInput!]
  countryOfOrigin: String
  customFields: [CustomFieldAssignmentInput!]
  externalId: String
  files: [UpdateFileListActionInput!]
  id: Int!
  isPinned: Boolean
  isVip: Boolean
  language: String
  tasks: [UpdateTaskListActionInput!]
}

input UpdateCommunicationFilesListActionInput {
  add: String
  remove: Int
}

"Exactly one of the fields document, email, fax, file and note should be given, depending on the type of the communication being changed."
input UpdateCommunicationInput {
  email: UpdateEmailCommunicationInput
  fax: UpdateFaxCommunicationInput
  file: UpdateFileCommunicationInput
  id: Int!
  letter: UpdateLetterCommunicationInput
  note: UpdateNoteCommunicationInput
}

input UpdateCommunicationListActionInput {
  add: CreateCommunicationInput
  modify: UpdateCommunicationInput
}

input UpdateCompanyClientInput {
  addresses: [UpdateClientAddressListActionInput!]
  bankAccounts: [UpdateBankAccountListActionInput!]
  communications: [UpdateCommunicationListActionInput!]
  contactDetails: [UpdateContactDetailListActionInput!]
  countryOfOrigin: String
  customFields: [CustomFieldAssignmentInput!]
  externalId: String
  files: [UpdateFileListActionInput!]
  id: Int!
  isActive: Boolean
  isPinned: Boolean
  isVip: Boolean
  language: String
  name: String
  tasks: [UpdateTaskListActionInput!]
}

input UpdateComplaintInput {
  address: AddressPatchInput
  approvedOn: DateTime
  contactDetails: [UpdateContactDetailListActionInput!]
  details: String
  finalResponse: String
  id: Int!
  name: String
  receivedBy: ComplaintReceivedBy
  receivedOn: DateTime
  status: ComplaintStatus
  title: String
}

input UpdateComplaintListActionInput {
  add: CreateComplaintInput
  modify: UpdateComplaintInput
}

input UpdateContactDetailInput {
  id: Int!
  "Marks the contact detail as primary. Only one contact detail of a given type can be marked as primary within a given collection of contact details.\nMarking a contact detail of a given type as primary causes the existing primary contact detail of that type (if any) to be marked as non-primary."
  isPrimary: Boolean
  type: ContactDetailType
  value: String
}

input UpdateContactDetailListActionInput {
  add: CreateContactDetailInput
  modify: UpdateContactDetailInput
  remove: Int
}

input UpdateCustomDialogInput {
  displayType: CustomDialogDisplayType
  isActive: Boolean
  name: String
  permissionGroupIds: [Int!]
  refreshWhenClosed: Boolean
  type: CustomDialogType
  url: String
}

input UpdateDerivedProductAgreementInput {
  derivedCommissionPercentage: Decimal
  id: Int!
  isBlocked: Boolean
}

input UpdateDerivedProductAgreementListActionInput {
  add: CreateDerivedProductAgreementInput
  modify: UpdateDerivedProductAgreementInput
  remove: Int
}

input UpdateEmailCommunicationInput {
  externalId: String
  tags: [String!]
}

input UpdateFaxCommunicationInput {
  externalId: String
  tags: [String!]
}

input UpdateFileCommunicationInput {
  "The content of the note, in clear text. All formatting (like HTML) should be removed."
  content: String
  "The content of the note, with formatting (like HTML)."
  contentFormatted: String
  externalId: String
  files: [UpdateCommunicationFilesListActionInput!]
  recipient: CommunicationActorInput
  subject: String
  tags: [String!]
}

input UpdateFileListActionInput {
  add: CreateFileInput
  remove: Int
}

input UpdateIdentityProviderInput {
  description: String
  entityId: String
  metadataUrl: String
}

input UpdateInboxTypeInput {
  code: String!
  isActive: Boolean
  name: String
}

input UpdateLetterCommunicationInput {
  externalId: String
  tags: [String!]
}

input UpdateMoneyAccountInput {
  code: String
  currencyCode: String
  exportFormat: String
  externalId: String
  name: String
  type: MoneyAccountType
}

input UpdateNoteCommunicationInput {
  "The content of the note, in clear text. All formatting (like HTML) should be removed."
  content: String
  "The content of the note, with formatting (like HTML)."
  contentFormatted: String
  externalId: String
  recipient: CommunicationActorInput
  subject: String
  tags: [String!]
  type: CommunicationNoteType
}

input UpdateOrganisationAddressInput {
  city: String
  coordinate: CoordinateInput
  country: CountryCodesInput
  formattedAddress: String
  geoProviderType: GeoProviderType
  id: Int!
  line1: String
  line2: String
  line3: String
  line4: String
  note: String
  placeId: String
  postalCode: String
  type: OrganisationAddressType
}

input UpdateOrganisationAddressListActionInput {
  add: CreateOrganisationAddressInput
  modify: UpdateOrganisationAddressInput
  remove: Int
}

input UpdateOrganisationContactInput {
  comment: String
  contactDetails: [UpdateContactDetailListActionInput!]
  department: String
  firstName: String
  id: Int!
  isInternal: Boolean
  jobTitle: String
  lastName: String
  preferredLanguage: String
  titleId: Int
  type: OrganisationContactType
}

input UpdateOrganisationContactListActionInput {
  add: CreateOrganisationContactInput
  modify: UpdateOrganisationContactInput
  remove: Int
}

input UpdateOrganisationInput {
  addresses: [UpdateOrganisationAddressListActionInput!]
  bankAccounts: [UpdateBankAccountListActionInput!]
  communications: [UpdateCommunicationListActionInput!]
  contactDetails: [UpdateContactDetailListActionInput!]
  contacts: [UpdateOrganisationContactListActionInput!]
  currencies: [String!]
  customFields: [CustomFieldAssignmentInput!]
  derivedProductAgreements: [UpdateDerivedProductAgreementListActionInput!]
  id: Int!
  isActive: Boolean
  name: String
  secondaryTypes: [OrganisationType!]
  shortName: String
  tasks: [UpdateTaskListActionInput!]
  type: OrganisationType
  vatIdentificationNumber: String
}

input UpdatePaymentInput {
  activities: [CreatePaymentActivityListActionInput!]
}

input UpdatePersonClientInput {
  addresses: [UpdateClientAddressListActionInput!]
  bankAccounts: [UpdateBankAccountListActionInput!]
  communications: [UpdateCommunicationListActionInput!]
  contactDetails: [UpdateContactDetailListActionInput!]
  countryOfOrigin: String
  customFields: [CustomFieldAssignmentInput!]
  dateOfBirth: Date
  employeeNumber: String
  externalId: String
  files: [UpdateFileListActionInput!]
  firstName: String
  gender: Gender
  "Gets or sets the height in cm."
  heightCm: Decimal
  id: Int!
  isPinned: Boolean
  isVip: Boolean
  jobTitle: String
  language: String
  lastName: String
  membershipNumber: String
  nationalityCountryCode: String
  passportCountryCode: String
  passportExpiryDate: Date
  passportNumber: String
  "Gets or sets the preferred measurement system. This just indicates how the height and weight should be converted. It is only for display purposes."
  preferredMeasurementSystem: MeasurementSystem
  socialSecurityNumber: String
  status: UpdatePersonStatusInput
  tasks: [UpdateTaskListActionInput!]
  titleId: Int
  "Gets or sets the weight in kg."
  weightKg: Decimal
}

"This type contains the properties that affect the status of a person.\n            \nSeveral rules are applied to this input to ensure that a person does not end up in an undesired state.\nFor instance a client cannot be active and have a date of death at the same time."
input UpdatePersonStatusInput {
  dateOfDeath: Date
  isActive: Boolean
  isDeceased: Boolean
}

input UpdatePhoneCallInput {
  "The phone number of the caller (incoming number)."
  callerPhoneNumber: String
  "If specified, the given claim will receive a new phone generated at the end of the call with the basic call info."
  claimId: Int
  "The flag to determine whether a phone call has been handled."
  isHandled: Boolean
  "The Id of the NIS PhoneCall to update."
  phoneCallId: String!
}

input UpdatePolicyInput {
  communications: [UpdateCommunicationListActionInput!]
  customFields: [CustomFieldAssignmentInput!]
  isPinned: Boolean
  tasks: [UpdateTaskListActionInput!]
}

input UpdateProductVisibilityGroupInput {
  id: Int!
  name: String
  productCodes: [String!]
}

input UpdateProviderContactAddressInput {
  city: String
  coordinate: CoordinateInput
  country: CountryCodesInput
  formattedAddress: String
  geoProviderType: GeoProviderType
  id: Int!
  line1: String
  line2: String
  line3: String
  line4: String
  note: String
  placeId: String
  postalCode: String
  type: ProviderContactAddressType
}

input UpdateProviderContactAddressListActionInput {
  add: CreateProviderContactAddressInput
  modify: UpdateProviderContactAddressInput
  remove: Int
}

input UpdateProviderContactInput {
  addresses: [UpdateProviderContactAddressListActionInput!]
  contactDetails: [UpdateContactDetailListActionInput!]
  firstName: String
  id: Int!
  lastName: String
  remark: String
  roleTypeId: Int
  titleId: Int
}

input UpdateProviderContactListActionInput {
  add: CreateProviderContactInput
  modify: UpdateProviderContactInput
  remove: Int
}

input UpdateProviderInput {
  address: AddressPatchInput
  bankAccounts: [UpdateBankAccountListActionInput!]
  contactDetails: [UpdateContactDetailListActionInput!]
  contacts: [UpdateProviderContactListActionInput!]
  currencyCode: String
  customFields: [CustomFieldAssignmentInput!]
  defaultCostAgentId: Int
  defaultInvoiceLineSchemaId: Int
  financialRating: Int
  iconId: Int
  invoiceBatchAutoCloseMethod: InvoiceBatchAutoCloseMethod
  invoiceBatchAutoCloseValue: Int
  invoiceBatchingMethod: PurchaseInvoiceBatchingMethod
  isActive: Boolean
  isPractitioner: Boolean
  linkedProviderIds: [Int!]
  name: String
  networkIds: [Int!]
  paymentDefinitionId: Int
  qualityRating: Int
  reference: String
  remark: String
  serviceRange: Int
  services: [ProviderServiceInput!]
  vatId: String
  vatPercentage: Decimal
}

input UpdateSegmentTypeInput {
  id: Int!
  isActive: Boolean!
  name: String!
}

input UpdateTaskInput {
  assigneeId: Int
  description: String
  dueOn: DateTime
  id: Int!
  isVoided: Boolean
  outcomeId: Int
  priority: TaskPriority
  questionnaire: TaskQuestionnaireInput
  remark: String
  tags: [String!]
  title: String
}

input UpdateTaskListActionInput {
  add: CreateTaskInput
  modify: UpdateTaskInput
}

input UpdateTeamInput {
  name: String
}

input UpdateUnassignedFileInput {
  communicationActor: CommunicationActorInput
  communicationParentId: Int
  communicationParentType: CommunicationParentType
  concurrentUserAction: ConcurrentUserAction
  concurrentUserId: Int
  description: String
  id: String!
  skipped: Boolean
  tags: [String!]
  taskDefinitionId: Int
  taskDescription: String
  taskTitle: String
  title: String
  typeCode: String
}

input UpdateUserInput {
  authorityLevel: Int
  defaultDepartmentId: Int
  email: String
  isActive: Boolean
  isLocked: Boolean
  jobTitle: String
  maxAuthorizedPayment: MoneyInput
  maxAuthorizedPaymentType: MaxAuthorizedPaymentType
  maxGuarantee: MoneyInput
  maxReservation: MoneyInput
  maxSelfSign: MoneyInput
  mustChangePassword: Boolean
  name: String
  password: String
  passwordNeverExpires: Boolean
  permissionGroupIds: [Int!]
  phoneNumber: String
  productVisibilityGroupIds: [Int!]
  teamId: Int
  useProductVisibilityGroups: Boolean
  visibilityLimit: VisibilityLimitMode
}

input UpdateUserPasswordInput {
  password: String!
  userId: Int!
}

input UpdateUserSignaturePasswordInput {
  password: String
  userId: Int!
}

input UpdateVatGroupInput {
  code: String
  name: String
  percentage: Decimal
}

input UpdateWebHookListenerInput {
  enableSslVerification: Boolean
  events: [String!]
  headerName: String
  headerValue: String
  id: Int!
  timeout: Int
  url: String
}

input UserOrderInput {
  by: UserOrder!
  direction: OrderDirection
  then: UserOrderInput
}

"Specifies what should happen based on the validity of an address."
enum AddressValidityAction {
  "The address is valid and\/or invalid addresses are ignored."
  NONE
  "The address is invalid, and a warning should be shown."
  WARN
  "The address is invalid, and any action using it should be blocked."
  BLOCK
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
}

enum BankAccountFieldType {
  ACCOUNT_HOLDER
  ACCOUNT_NO
  SWIFT
  IBAN
  CURRENCY
  BANK_NAME
  ADDRESS
  COUNTRY
  SORT_CODE
}

enum BlacklistEntryType {
  "The entry represents an individual."
  INDIVIDUAL
  "The entry represents a financial entity (company or organisation)."
  ENTITY
}

enum BlacklistHistoryAction {
  ADDED
  REMOVED
}

enum BlacklistMatchDecisionOutcome {
  "The match should be considered accurate, meaning that the entity is blacklisted."
  ACCURATE
  "The match is inaccurate (a false positive), and will be ignored."
  INACCURATE
}

enum CalculationMessageSeverity {
  INFORMATION
  WARNING
  ERROR
}

enum CalculationMessageSource {
  PRODUCT
  PRODUCT_CALCULATION
  QUESTIONNAIRE
}

enum CaseCreationDefaultPolicyMode {
  SEARCH
  CREATE
}

enum ClaimAccountEntryOrder {
  DATE
}

enum ClaimAccountEntryType {
  RESERVE
  PAYMENT
  ON_THE_SPOT_PAYMENT
  EXTERNAL_COST
  PAYMENT_REQUEST
  RECOVERY
  RECOVERY_RESERVE
  REDUCTION
}

enum ClaimCollectiveInvoiceOrder {
  ID
}

enum ClaimJourneyBookingStatus {
  DRAFT
  PLAN
  QUOTE_REQUEST_DRAFT
  QUOTE_REQUEST_SENT
  QUOTED
  RESERVED
  CONFIRMED
  ISSUED
}

enum ClaimJourneySegmentFieldType {
  STRING
  INTEGER
  DECIMAL
  BOOLEAN
  DATE
  DATE_TIME
}

enum ClaimJourneyTravelerType {
  CLAIMANT
  CLAIM_CONTACT
  CLIENT
}

enum ClaimLocationType {
  INCIDENT
  POLICY_HOLDER
  CONTACT
  INSURED
}

enum ClaimOrder {
  NUMBER
  CREATED
}

enum ClaimPaymentGuaranteeStatus {
  PENDING
  SETTLED
  DRAFT
  CONFIRMED
  CANCELLED
}

enum ClaimPurchaseInvoiceBatchOrder {
  ID
}

enum ClaimPurchaseInvoiceBatchPayableStatus {
  CLOSED
  PENDING
  PARTIALLY_READY
  READY
}

enum ClaimPurchaseInvoiceBatchStatus {
  OPEN
  CLOSED
  VOIDED
}

enum ClaimPurchaseInvoiceOrPaymentGuaranteeOrder {
  CREATE_DATE
}

enum ClaimPurchaseInvoiceStatus {
  UNDERWRITER_PAYMENT_RECEIVED
  PENDING
  WAIT_REIMBURSEMENT
  PAY
  IN_PAYMENT
  SETTLED
  DRAFT
  INCOMPLETE
  CANCELLED
}

enum ClaimRecoveryStatus {
  NEW
  PENDING
  CONFIRMED
  NO_COVERAGE
}

enum ClaimStatus {
  OPEN
  CLOSED
  DENIED
  NOT_APPLICABLE
  VOIDED
}

enum ClaimStrategyType {
  MEDICAL
  FINANCIAL
  ASSISTANCE
}

enum ClauseRiskLevel {
  NEUTRAL
  INCREASED
  DECREASED
}

enum ClientAddressType {
  HOME
  BUSINESS
  POSTAL
  OTHER
  DESTINATION
  PROPERTY
}

enum ClientType {
  PERSON
  COMPANY
}

enum CommunicationActorType {
  CLAIM_CONTACT
  USER
  CLIENT
  ORGANISATION
  DEPARTMENT
  PROVIDER_CONTACT
  "Represents a claim contact that points to a provider."
  CLAIM_CONTACT_WITH_PROVIDER
}

enum CommunicationDirection {
  INGOING
  OUTGOING
}

enum CommunicationNoteType {
  INTERNAL
  WARNING
  PHONE_INCOMING
  PHONE_OUTGOING
}

enum CommunicationOrder {
  CREATE_DATE
}

enum CommunicationOutputRecipient {
  CLAIM_CONTACT
  CLIENT
  ORGANISATION
  DEPARTMENT
}

enum CommunicationParentType {
  CLAIM
  CLAIM_JOURNEY
  CLAIM_RECOVERY
  CLIENT
  ORGANISATION
  POLICY
  PURCHASE_INVOICE
  PAYMENT_GUARANTEE
  PROVIDER
}

enum CommunicationParticipantRoleType {
  ANY
  SENDER
  RECEIVER
}

enum CommunicationTemplateType {
  WORD
  EXCEL
  REPORTING_SERVICES
  STATIC
  RAZOR
}

enum CommunicationTemplateUsableOn {
  EMAIL_BODY
  TEXT_MESSAGE
}

enum CommunicationTokenType {
  LETTER
  EMAIL
  FAX
}

enum CommunicationType {
  DOCUMENT
  FAX
  EMAIL
  NOTE
  ATTACHED_FILE
  TEXT_MESSAGE
  PHONE_CALL
}

enum CommunicationTypeLimitation {
  LETTER
  FAX
  EMAIL
  TEXT_MESSAGE
}

enum ComplaintReceivedBy {
  PHONE
  FAX
  EMAIL
  MAIL
}

enum ComplaintStateBehavior {
  UNRESTRICTED
  BLOCKING
  EXTENDED
}

enum ComplaintStatus {
  OPEN
  CLOSED
  VOIDED
}

enum ConcurrentUserAction {
  REGISTER
  REMOVE
}

enum ContactDetailType {
  PHONE
  PHONE_LANDLINE
  PHONE_MOBILE
  EMAIL
  FAX
  WEBSITE
}

enum CustomDialogDisplayType {
  SHOW_EMBEDDED
  OPEN_EXTERNAL
}

enum CustomDialogOrder {
  CREATE_DATE
}

enum CustomDialogType {
  CASE
  POLICY
  CLIENT
  INVOICE
  GUARANTEE
}

enum CustomFieldCreateDisplayMode {
  "The custom field only appears when editing existing entities."
  NEVER
  "The custom field appears both when creating the entity to which they belong, and when editing the resulting entity."
  ALWAYS
  "The custom field only appears when creating the entity if the custom field is flagged as required, but is always displayed when editing the resulting entity."
  IF_REQUIRED
}

enum CustomFieldDisplayMode {
  TEXTBOX
  TEXTAREA
  SELECT
  CHECKBOX
  RATING
  LOCATION
}

enum CustomFieldOwnerType {
  PERSON
  COMPANY
  CLAIM
  CLAIM_RECOVERY
  ORGANISATION
  ASSISTANCE_EVENT
  PAYMENT_GUARANTEE
  PURCHASE_INVOICE
  POLICY
  MASTER_POLICY
  PROVIDER
}

enum CustomFieldValueType {
  STRING
  DATE
  INTEGER
  DECIMAL
  BOOLEAN
  DATE_TIME
}

enum DiagnosisOrder {
  NAME
}

enum ExchangeRateOrder {
  VALID_FROM
  CREATED_ON
}

enum FeeEntryPoint {
  CLAIM_CLOSE
  CLAIM_DENIED
  CLAIM_PAYMENT
  CLAIM_RECOVERY
  CLAIM_RECOVERY_OBTAINED
  CLAIM_OPEN
  CLAIM_RE_OPEN
  CLAIM_RE_CLOSE
  MANUAL
  CLAIM_PAYMENT_SIGN_LEVEL1
  CLAIM_ACCOUNT_ENTRY_CREATED
  CLAIM_ASSISTANCE_CASE_CLOSED
  CLAIM_PAYMENT_ENTER_SIGN_LEVEL1
  PROVIDER_INVOICE_CREATED
  PROVIDER_INVOICE_APPROVED
  PROVIDER_INVOICE_SETTLED
  PROVIDER_INVOICE_VOIDED
  PROVIDER_INVOICE_REFUND_CREATED
  PROVIDER_INVOICE_REFUND_SETTLED
  CLAIM_VOIDED
  CLAIM_ACCOUNT_CREATED
  CLAIM_ASSISTANCE_CASE_RE_CLOSE
  CLAIM_ASSISTANCE_CASE_RE_OPEN
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum GeoProviderType {
  CUSTOM
  GOOGLE
}

enum InvoiceBatchAutoCloseMethod {
  DAYS_AFTER_CREATION
}

enum LimitationInsuredScope {
  "Individual insured only."
  INDIVIDUAL
  "All insured."
  ALL
  "Everything within the group of policies."
  GROUP
}

enum LimitationTimeScope {
  POLICY_CONTRACT_PERIOD
  POLICY_LIFE_TIME
  CALENDAR_YEAR
  CLAIM_LIFE_TIME
  BILL
  SPECIFIC_PERIOD
  CLAIM_CONTRACT_PERIOD
}

enum MaxAuthorizedPaymentType {
  PER_BATCH
  PER_INVOICE
}

enum MeasurementSystem {
  METRIC
  IMPERIAL
  IMPERIAL_US
}

enum MoneyAccountType {
  MONEY
  NOMINAL
  ORGANISATION
}

enum OrderDirection {
  ASCENDING
  DESCENDING
}

enum OrganisationAddressType {
  BUSINESS_ADDRESS
  POSTAL_ADDRESS
  BILLING_ADDRESS
  TAX_CALCULATION_ADDRESS
}

enum OrganisationContactType {
  SALES
  FINANCE
  CLAIMS
  OWNER
  MARKETING
  OTHER
  ACCOUNT_OWNER
  ACCOUNT_MANAGER
  EXECUTIVE_MANAGEMENT
  BACKUP_ACCOUNT_MANAGER
  SECONDARY_SALES
  CUSTOMER_SUCCESS_REPRESENTATIVE
  OPERATIONS
  IT
  LEGAL
  RESERVES
  ASSISTANCE
  BACKUP_CUSTOMER_SUCCESS_REPRESENTATIVE
  SERVICE_COORDINATOR
  VOICE_OF_CONTACT
  VOICE_OF_CONTACT2
  IN_PROVINCE_CONTACT
  LETTER_CONTACT
}

enum OrganisationOrder {
  NAME
}

enum OrganisationType {
  FRONTER
  MASTER
  CLAIMS
  BROKER
  ASSISTANCE_COMPANY
  DELEGATED_AUTHORITY
  CORPORATE
  POLICY_HOLDER
  HEAD_OFFICE
  SALES_OFFICE
  CO_ASSURANCE
  GROUP
  UNDERWRITER
  BRANCH
  DIVISION
  SCHOOL
  CONSULTANT
  PLAN_ADMINISTRATOR
  ASSOCIATION
  AFFINITY_GROUP
  THIRD_PARTY_ADMINISTRATOR
  MANAGING_GENERAL_AGENT
  COST_AGENT
}

enum PasswordValidationCode {
  OK
  MUST_BE_DIFFERENT_FROM_ACCEPT_PASSWORD
  MUST_BE_DIFFERENT_FROM_OLD
  PASSWORD_MISSING
  MIN_CHARACTERS
  MAX_CHARACTERS
  INVALID_CHARACTERS
  ILLEGAL_PASSWORD
  CANNOT_BE_REUSED
  LIMIT_DAILY_CHANGE
  MUST_NOT_CONTAIN_USERNAME
  MUST_CONTAIN_DIGITS
  MUST_CONTAIN_LOWER_CASE
  MUST_CONTAIN_UPPER_CASE
  MUST_CONTAIN_SPECIAL_CHARACTERS
  MUST_START_END_ALPHA_CHARACTER
}

enum PaymentActivityType {
  SIGNATURE
  QUALITY_CONTROL_APPROVED
  VOID
  MARKED_AS_TRANSFER_IN_PROGRESS
  MARKED_AS_TRANSFERRED
  MARKED_AS_QUALITY_CONTROL
  REFUNDED
  CREATED_AS_REFUND
  REJECTED
  EXTERNAL
}

enum PaymentDirection {
  OUTGOING
  INCOMING
}

enum PaymentExportOrder {
  EXPORTED_ON
}

enum PaymentFrequency {
  MONTHLY
  QUARTERLY
  SEMI_ANNUALLY
  ANNUALLY
  ONCE
}

enum PaymentOrder {
  ID
}

enum PaymentStatus {
  PENDING
  UNDER_APPROVAL
  APPROVED
  QUALITY_ASSURANCE
  TRANSFER_IN_PROGRESS
  TRANSFERRED
  REFUNDED
  REJECTED
  VOIDED
}

enum PaymentType {
  BANK_TRANSFER
  CHEQUE
  CREDIT_CARD
  INTERNAL
  MONEY_ORDER
}

"The display mode for the phone call indicates whether or not the"
enum PhoneCallDisplayMode {
  "Hidden means there is nothing displayed on screen other than a part of the phone list and indicator."
  HIDDEN
  "Shows the dashboard directly without an initial toaster to accept to open the dashboard."
  SHOW_DASHBOARD
}

enum ProductBehavior {
  "Indicates that insured on policies created from this product are items, and not people. In this case, insured are not clients. Instead they are insured objects with an assigned name."
  INSURED_IS_ITEM
  "Indicates that insured on policies created from this product are insured objects assigned to collective categories."
  COLLECTIVE
  "Indicates that policies can only be created from this product when a claim is created."
  CLAIMS_ONLY
  "Indicates that the product uses a structure that can be retrieved using the `structure` field."
  STRUCTURAL
  "Indicates that the products allows claims to be created with a claimant that is not explicitly insured on the policy."
  ALLOW_NON_INSURED_CLAIMANT
}

enum ProductCalculationBehavior {
  "The result of the calculation should be shown for each of the insured with a result."
  SHOW_RESULT_FOR_EACH_INSURED
  "The result of the calculation should be shown for the first insured with a result."
  SHOW_RESULT_FOR_FIRST_INSURED
}

enum ProductElementBehavior {
  "The element is automatically assigned based on product logic. It cannot be controlled manually."
  AUTO_ASSIGNED
  "The element represents a product coverage."
  COVERAGE
  "The element represents a section of a product, meaning that it should be presented in a way where insured added to that section should have this element selected,\nand only be able to interact with children of this element."
  SECTION
}

enum ProductElementChildSelectionMode {
  "Any of the selectable child elements can be selected freely."
  FREE
  "A single selectable child element must be selected."
  SINGLE
  "Either a single, or none of the selectable child elements must be selected."
  SINGLE_OR_NONE
}

enum ProductPropertyBehavior {
  "The value of the property is auto assigned based on product logic. It cannot be controlled manually."
  AUTO_ASSIGNED
}

enum ProductStructureOrientation {
  "Structure nodes should be listed horizontally, while insured should be listed vertically."
  HORIZONTAL
  "Structure nodes should be listed vertically, while insured should be listed horizontally."
  VERTICAL
}

enum ProductStructureValueType {
  STRING
  INTEGER
  FLOAT
  BOOLEAN
  DATE
}

enum ProviderContactAddressType {
  BUSINESS_ADDRESS
  POSTAL_ADDRESS
  BILLING_ADDRESS
  TAX_CALCULATION_ADDRESS
}

enum ProviderOrder {
  NAME
}

enum PurchaseInvoiceBatchingMethod {
  DEFAULT
  PER_CASE
}

enum QuestionnaireType {
  "The questionnaire is used to determine the eligibility of insured, which means the questionnaire should be shown during calculation."
  ELIGIBILITY
  "The questionnaire is a survey, which means it does not affect the quote\/policy, and can be shown after calculation."
  SURVEY
}

enum ReportOutputFormat {
  EXCEL
  PDF
  WORD
  CSV
  TEXT
  HTML
  XML
}

enum TagAvailability {
  COMMUNICATIONS
  TASKS
  CLAIMS
}

enum TaskCreationType {
  SUPPLIER_INVOICE
  POLICY
  CLAIM_RECOVERY
  CLAIM_CONTACT
  CLAIM
  CLIENT
  ORGANISATION
}

enum TaskDefinitionLock {
  PRIORITY
  DURATION
  START_DATE
}

enum TaskOrder {
  "Sorts pending tasks by due date, and completed tasks by completion date in the opposite direction"
  DATE
  PRIORITY
  "Sorts by whether the task is completed or not"
  COMPLETED
}

enum TaskOutcomeSystemBehaviour {
  VOIDED
  ACTIVITY_STARTED
  ACTIVITY_COMPLETED
  ACTIVITY_FAILED
}

enum TaskOwnerType {
  PAYMENT
  SUPPLIER_INVOICE
  POLICY
  CLAIM_RECOVERY
  CLAIM_CONTACT
  CLAIM
  CREDITOR_JOURNAL
  COMMUNICATION
  CLIENT
  PLACE_OF_TREATMENT
  ORGANISATION
  INBOX
}

"Represents the type of a task's parent.\nA task always belongs to one of these parent types.\n            \nIt can belong to a more specific TaskOwnerType too, but its root parent will be one of the TaskParentTypes."
enum TaskParentType {
  CLAIM
  CLIENT
  POLICY
  ORGANISATION
}

enum TaskPriority {
  LOW
  NORMAL
  SERIOUS
  HIGH
  ULTRA_HIGH
}

enum TaskSystemType {
  QUALITY_ASSURANCE
  NOTIFICATION
  WORK_FLOW
  YES_NO
  AUTOMATIC_TEMPLATE
  AUTOMATIC_TEMPLATE_APPLIED
}

enum TeamOrder {
  NAME
}

enum UnassignedFileOrder {
  CREATE_DATE
}

enum UserOrder {
  NAME
}

enum ViewRegistrationObjectType {
  CLAIM
  POLICY
  TASK
  CLIENT
  CLAIM_PURCHASE_INVOICE_OR_GUARANTEE
  CLAIM_RECOVERY
  COMMUNICATION
}

"Specifies the mode to use to limit the visibility of entities based on department\/organisation access."
enum VisibilityLimitMode {
  "The visibility is not limited for this user."
  NONE
  "The user can only see entities linked to the departments\/organisations the user has access to."
  SELECTED_ONLY
}

directive @authorize("Defines when when the resolver shall be executed.By default the resolver is executed after the policy has determined that the current user is allowed to access the field." apply: ApplyPolicy! = BEFORE_RESOLVER "The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!]) repeatable on SCHEMA | OBJECT | FIELD_DEFINITION

"The `@defer` directive may be provided for fragment spreads and inline fragments to inform the executor to delay the execution of the current fragment to indicate deprioritization of the current fragment. A query with `@defer` directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred is delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`."
directive @defer("Deferred when true." if: Boolean "If this argument label has a value other than null, it will be passed on to the result of this defer directive. This label is intended to give client applications a way to identify to which fragment a deferred result belongs to." label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy("The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types." url: String!) on SCALAR

"The `@stream` directive may be provided for a field of `List` type so that the backend can leverage technology such as asynchronous iterators to provide a partial list in the initial response, and additional list items in subsequent responses. `@include` and `@skip` take precedence over `@stream`."
directive @stream("Streamed when true." if: Boolean "The initial elements that shall be send down to the consumer." initialCount: Int! = 0 "If this argument label has a value other than null, it will be passed on to the result of this stream directive. This label is intended to give client applications a way to identify to which fragment a streamed result belongs to." label: String) on FIELD

"The `Date` scalar represents an ISO-8601 compliant date type."
scalar Date

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"The `Decimal` scalar type represents a decimal floating-point number."
scalar Decimal

"A date and time that is not associated with a specific time zone. A LocalDateTime value does not represent an instant on the global time line, because it has no associated time zone: \"January 12th 2021 7pm\" occurred at different instants for different people around the world."
scalar LocalDateTime

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

scalar UUID @specifiedBy(url: "https:\/\/tools.ietf.org\/html\/rfc4122")
